<!DOCTYPE HTML>
<html lang="zh" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>《Pico Pico - Embedded Programming with Rust》中文版</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-5733feae.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom-963dd77b.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex-d80313fa.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-e36d5c87.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">《Pico Pico - Embedded Programming with Rust》中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/Zhruoshui/pico-pico-zh" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="写在一开始"><a class="header" href="#写在一开始">写在一开始</a></h1>
<div style="background: linear-gradient(135deg, rgba(230, 126, 34, 0.12) 0%, rgba(230, 126, 34, 0.05) 100%); border: 1px solid rgba(230, 126, 34, 0.3); border-left: 6px solid #e67e22; padding: 25px; margin: 25px 0; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.08); backdrop-filter: blur(8px);">
    
<div style="display: flex; align-items: center; margin-bottom: 18px;">
        <span style="font-size: 2.2em; margin-right: 15px;">🦀</span>
        
<h3 style="margin: 0; color: #e67e22; font-size: 1.6em; letter-spacing: 1px; font-weight: 700;">译者说明 / Translator Note</h3>

    </div>

    
<p style="font-size: 1.15em; line-height: 1.7; margin-bottom: 15px;">
        <strong>本书翻译自picp-pico原项目，加入了一些译者的想法作为补充。译者是一名拥有 1 年嵌入式开发经验的独立开发者。由于水平有限，翻译过程中难免存在疏漏或不当之处。</strong>
    </p>

    
<p style="opacity: 0.9; margin-bottom: 20px; font-size: 1em;">如果您在阅读过程中发现任何问题（如翻译错误、技术偏差等），欢迎通过以下方式反馈，您的建议对我非常重要：</p>

    
<div style="display: flex; gap: 15px; flex-wrap: wrap;">
        <a href="https://github.com/Zhruoshui/pico-pico-zh" target="_blank" style="text-decoration: none;">
            <img src="https://img.shields.io/badge/GitHub-Report_Issue-181717?style=for-the-badge&amp;logo=github&amp;logoColor=white" alt="GitHub Issues">
        </a>
        <a href="mailto:Aruoshui_Zh@outlook.com" style="text-decoration: none;">
            <img src="https://img.shields.io/badge/Email-Contact_Me-D14836?style=for-the-badge&amp;logo=microsoftoutlook&amp;logoColor=white" alt="Email">
        </a>
    </div>

</div>

<div align="center">
    <img src="https://image.aruoshui.fun/i/2024/12/31/vkaiy2-0.webp" alt="菲伦保命" style="max-width: 280px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); border: 2px solid rgba(230, 126, 34, 0.2);">
</div>

<div style="text-align: center; margin: 40px 0; padding: 30px; border-top: 1px solid rgba(0,0,0,0.1); border-bottom: 1px solid rgba(0,0,0,0.1);">
    
<p style="font-size: 1.2em; margin-bottom: 20px;">🌟 <strong>原项目仓库 / Original Repository</strong></p>

    
<div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
        <a href="https://github.com/ImplFerris/pico-pico" target="_blank" style="text-decoration: none;">
            <img src="https://img.shields.io/github/stars/ImplFerris/pico-pico?style=social" alt="GitHub Repo stars">
        </a>
        <a href="https://github.com/ImplFerris/pico-pico" target="_blank" style="text-decoration: none;">
            <img src="https://img.shields.io/badge/Source_Code-ImplFerris/pico--pico-181717?style=for-the-badge&amp;logo=github&amp;logoColor=white" alt="GitHub">
        </a>
    </div>

    
<p style="margin-top: 20px; opacity: 0.8; font-size: 0.95em;">
        点击上方按钮前往原项目仓库，为原作者点个 Star 吧！<br />
        <small>Please visit the original repository and give it a star!</small>
    </p>

</div>

<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pico-pico---简介"><a class="header" href="#pico-pico---简介">Pico Pico - 简介</a></h1>
<p>在本书中，我们将使用 Raspberry Pi Pico 2，并使用 Rust 编程来探索各种有趣的项目。你将完成的练习包括：调暗 LED、控制舵机、使用超声波传感器测距、在 OLED 显示屏上显示 Ferris（🦀）图像、使用 RFID 读卡器、用蜂鸣器演奏歌曲、在室内光线不足时点亮 LED、测量温度等。</p>
<h2 id="认识硬件---pico-2"><a class="header" href="#认识硬件---pico-2">认识硬件 - Pico 2</a></h2>
<p>我们将使用的板子是基于新款 RP2350 芯片的 Raspberry Pi Pico 2。它提供双核灵活性，既支持 ARM Cortex-M33 内核，也可选用 Hazard3 RISC‑V 内核。默认情况下使用 ARM 内核，但开发者可根据需要尝试 RISC‑V 架构。</p>
<p>可在<a href="https://www.raspberrypi.com/products/raspberry-pi-pico-2/">官方网站</a>查看更详细的信息。</p>
<div class="image-with-caption" style="text-align:center;">
    <img src="images/pico2.png" alt="Raspberry Pi Debug 2" style="width:400px; height:auto; display:block; margin:auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Raspberry Pi Pico 2</div>

</div>

<blockquote>
<p><strong>注意</strong>：还有一代使用 RP2040 的旧款 Raspberry Pi Pico。本书使用的是更新的 <strong>Pico 2</strong>（搭载 <strong>RP2350</strong>）。购买硬件时请确认型号！</p>
</blockquote>
<p>还有一个带 Wi‑Fi 和蓝牙功能的变体 <code>Pico 2 W</code>，同样基于 RP2350，但与本书示例并非完全兼容。如希望直接按本书操作而不做额外修改，建议选择标准的非无线版本 Pico 2。</p>
<h2 id="可选硬件debug-probe"><a class="header" href="#可选硬件debug-probe">可选硬件：Debug Probe</a></h2>
<p>Raspberry Pi Debug Probe 能让向 Pico 2 烧录固件的过程更加便捷。没有调试器时，每次上传新固件都需按住 BOOTSEL 按钮。调试器同时提供完善的调试支持，非常实用。</p>
<p>该工具为可选项。除专门介绍调试器的章节外，本书的其它内容均可在没有调试器的情况下学习。我在刚开始接触 Pico 时也是先不使用调试器，随后才购入。</p>
<div class="image-with-caption" style="text-align:center;">
    <img src="images/Raspberry Pi Pico Debug Probe Hardware.jpg" alt="Raspberry Pi Debug Probe connected with Pico" style="width:400px; height:auto; display:block; margin:auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Raspberry Pi Pico Debug Probe</div>

</div>

<p><strong>如何选择？</strong></p>
<p>如果预算有限，可以暂时不购买，因其价格大约为一块 Pico 2 的两倍；若成本不是问题，则非常值得入手。如有第二块 Pico，也可将其配置成低成本的调试器。</p>
<h2 id="数据手册"><a class="header" href="#数据手册">数据手册</a></h2>
<p>如需更详细的技术信息、规格与指南，请查阅官方数据手册：</p>
<ul>
<li><a href="https://datasheets.raspberrypi.com/pico/pico-2-datasheet.pdf">Pico 2 Datasheet</a></li>
<li><a href="https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf">RP2350 chip Datasheet</a></li>
</ul>
<h2 id="许可协议"><a class="header" href="#许可协议">许可协议</a></h2>
<p>Pico Pico（本项目）按以下许可分发：</p>
<ul>
<li>代码示例及独立的 Cargo 项目同时遵循 <a href="https://opensource.org/licenses/MIT">MIT License</a> 与 <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License v2.0</a>。</li>
<li>本书的文字内容遵循 Creative Commons <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a> 许可协议。</li>
</ul>
<h2 id="支持本项目"><a class="header" href="#支持本项目">支持本项目</a></h2>
<p>你可以通过在 <a href="https://github.com/ImplFerris/pico-pico">GitHub</a> 上为该项目加星，或把本书分享给他人来支持它 😊</p>
<h3 id="免责声明"><a class="header" href="#免责声明">免责声明</a></h3>
<p>本文档中分享的实验与项目均由作者实践验证，但结果可能存在差异。实验过程中产生的任何问题或损坏，作者不承担责任。请谨慎操作并采取必要的安全措施。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="raspberry-pi-pico-2-引脚图"><a class="header" href="#raspberry-pi-pico-2-引脚图">Raspberry Pi Pico 2 引脚图</a></h1>
<blockquote>
<p><strong>注意：</strong> 现在无需记住或理解每一个引脚。在完成本书的练习时，我们会随时回到这一节。</p>
</blockquote>
<p><img src="images/raspberry-pi-pico2-rp2350-pinout-diagram.png" alt="Raspberry Pi Pico 2 Pinout Diagram"></p>
<h2 id="电源引脚"><a class="header" href="#电源引脚">电源引脚</a></h2>
<p>电源引脚对 Raspberry Pi Pico 2 至关重要，它们既为开发板供电，也为连接的传感器、LED、马达等外设提供电力。</p>
<p>Pico 2 具有如下电源引脚。它们在引脚图中以红色（电源）和黑色（地）标记，可用于为板子或外部器件供电。</p>
<ul>
<li>
<p><strong>VBUS</strong> 连接到来自 USB 端口的 5V。当通过 USB 供电时，该引脚大约为 5V。它可用于为小型外设供电，但不适合大电流负载。</p>
</li>
<li>
<p><strong>VSYS</strong> 是板子的主电源输入，可连接电池或稳压电源，电压范围为 1.8V 到 5.5V。该引脚为板载 3.3V 稳压器供电，进而为 RP2350 等部件供电。</p>
</li>
<li>
<p><strong>3V3(OUT)</strong> 提供来自板载稳压器的稳定 3.3V 输出，可用于为传感器或显示屏等外设供电，但建议将电流限制在 300mA 以内。</p>
</li>
<li>
<p><strong>GND</strong> 引脚用于完成电路并连接到系统接地。Pico 2 在板上提供多个 GND 引脚，便于连接外设时接地。</p>
</li>
</ul>
<h2 id="gpio-引脚"><a class="header" href="#gpio-引脚">GPIO 引脚</a></h2>
<p>当你希望微控制器（例如 Pico）与外界交互，如点亮灯、读取按键、感知温度或控制电机时，就需要通过 GPIO 引脚连接这些外部器件。GPIO 引脚就是 Raspberry Pi Pico 2 与外设之间的连接点。</p>
<p>Pico 2 提供 26 个通用输入/输出（GPIO）引脚，标号为 GPIO0 到 GPIO29，尽管并非所有标号都在排针上暴露。这些引脚高度灵活，可用于读取开关或传感器等输入，也可用于控制 LED、马达等输出。</p>
<p>所有 GPIO 的逻辑电平为 3.3V。因此接入的输入信号不应超过 3.3V，否则可能损坏开发板。许多 GPIO 支持基础的数字 I/O，部分引脚还支持模拟输入（ADC），或可配置为 I2C、SPI、UART 等通信线路。</p>
<h3 id="引脚编号"><a class="header" href="#引脚编号">引脚编号</a></h3>
<p>每个 GPIO 引脚有两种标识方式：软件中使用的 GPIO 编号和开发板上的物理引脚位置。编写代码时使用 GPIO 编号（例如 GPIO0）；实际连线时需确认该编号对应的物理针脚。</p>
<blockquote>
<p>GPIO25 比较特殊，它连接到板载 LED，可以直接在代码中控制，而无需外接布线。</p>
</blockquote>
<p>例如，当代码中引用 GPIO0 时，在硬件上应将导线连接到物理引脚 1；GPIO2 对应物理引脚 4。</p>
<h2 id="adc-引脚"><a class="header" href="#adc-引脚">ADC 引脚</a></h2>
<p>Pico 2 上的大多数引脚只能处理简单的开/关信号，适合控制 LED 或读取按钮。但如果你想测量房间亮度以自动点亮灯、监测土壤湿度或读取旋钮转动角度，这些任务需要能够感知连续变化的信号，而非仅有高低电平。</p>
<p>为此，需要使用 ADC（模数转换器）引脚。<strong>ADC</strong>（Analog-to-Digital Converter）会将模拟电压转换为程序可读的数字值。例如 0V 对应 0，3.3V 对应 4095（12 位分辨率的最大值）。本书后文会详细介绍 ADC 的使用。</p>
<p>Pico 2 有三个支持 ADC 的引脚，分别是 GPIO26、GPIO27 和 GPIO28，对应 ADC0、ADC1、ADC2。这些引脚可用于读取光敏、电阻式传感器等模拟信号。</p>
<p>此外还有两个与模拟输入相关的特殊引脚：</p>
<ul>
<li>
<p><strong>ADC_VREF</strong> 是 ADC 的参考电压。默认连接到 3.3V，意味着 ADC 会把 0V 到 3.3V 映射到数字范围内；你也可以输入其它参考电压（例如 1.25V）以在特定电压范围内获得更高分辨率。</p>
</li>
<li>
<p><strong>AGND</strong> 是模拟地，用于为模拟信号提供更干净的接地参考，有助于降低噪声并提高测量精度。使用模拟传感器时，建议将其地连接到 AGND 而不是普通 GND。</p>
</li>
</ul>
<h2 id="i2c-引脚"><a class="header" href="#i2c-引脚">I2C 引脚</a></h2>
<p>Pico 2 支持 I2C，总线仅需两根线即可连接多个设备，常用于传感器、显示屏等外设。</p>
<p>I2C 使用两条信号线：<strong>SDA</strong>（数据）和 <strong>SCL</strong>（时钟）。所有设备共享这两条线，每个设备有唯一地址，Pico 2 可通过同一对线与多个设备通信。</p>
<p>Pico 2 提供两个 I2C 控制器：I2C0 与 I2C1。每个控制器可以映射到多组 GPIO，引脚选择更灵活。</p>
<ul>
<li>
<p><strong>I2C0</strong> 可使用如下 GPIO：</p>
<ul>
<li>SDA（数据）：GPIO0、GPIO4、GPIO8、GPIO12、GPIO16 或 GPIO20</li>
<li>SCL（时钟）：GPIO1、GPIO5、GPIO9、GPIO13、GPIO17 或 GPIO21</li>
</ul>
</li>
<li>
<p><strong>I2C1</strong> 可使用如下 GPIO：</p>
<ul>
<li>SDA（数据）：GPIO2、GPIO6、GPIO10、GPIO14、GPIO18 或 GPIO26</li>
<li>SCL（时钟）：GPIO3、GPIO7、GPIO11、GPIO15、GPIO19 或 GPIO27</li>
</ul>
</li>
</ul>
<p>需从同一控制器中选择匹配的 SDA/SCL 对。</p>
<h2 id="spi-引脚"><a class="header" href="#spi-引脚">SPI 引脚</a></h2>
<p>SPI（串行外设接口）是另一种常用通信协议，适合连接显示屏、SD 卡和部分传感器。与 I2C 相比，SPI 使用更多线但速度更快，通常由一个控制器与一个或多个设备通信。</p>
<p>SPI 使用四条主要信号：</p>
<ul>
<li><strong>SCK</strong>（时钟）：控制数据传输节奏；</li>
<li><strong>MOSI</strong>（主出从入）：控制器到设备的数据；</li>
<li><strong>MISO</strong>（主入从出）：设备返回给控制器的数据；</li>
<li><strong>CS/SS</strong>（片选）：由控制器指定要通信的目标设备。</li>
</ul>
<p>在 Pico 2 的引脚图中，MOSI 标记为 <strong>Tx</strong>，MISO 标记为 <strong>Rx</strong>，CS 标记为 <strong>Csn</strong>。</p>
<p>Pico 2 提供 SPI0 与 SPI1 两个控制器，可映射到多组 GPIO：</p>
<ul>
<li>
<p><strong>SPI0</strong> 可使用：</p>
<ul>
<li>SCK：GPIO2、GPIO6、GPIO10、GPIO14、GPIO18</li>
<li>MOSI：GPIO3、GPIO7、GPIO11、GPIO15、GPIO19</li>
<li>MISO：GPIO0、GPIO4、GPIO8、GPIO12、GPIO16</li>
</ul>
</li>
<li>
<p><strong>SPI1</strong> 可使用：</p>
<ul>
<li>SCK：GPIO14、GPIO18</li>
<li>MOSI：GPIO15、GPIO19</li>
<li>MISO：GPIO8、GPIO12、GPIO16</li>
</ul>
</li>
</ul>
<p>可根据电路布局从同一控制器中选择兼容的一组引脚。CS（片选）不固定，可以使用任意空闲 GPIO。稍后章节会介绍如何配置 SPI 并连接外设。</p>
<h2 id="uart-引脚"><a class="header" href="#uart-引脚">UART 引脚</a></h2>
<p>UART（通用异步收发传输器）是最简单的串行通信方式之一，仅需两条主线：</p>
<ul>
<li><strong>TX</strong>（发送）：输出数据；</li>
<li><strong>RX</strong>（接收）：输入数据；</li>
</ul>
<p>UART 常用于连接 GPS 模块、蓝牙适配器或与电脑通信以进行调试。</p>
<p>Pico 2 提供两个 UART 控制器：<strong>UART0</strong> 与 <strong>UART1</strong>。每个控制器都能映射到多组 GPIO，布线更灵活。</p>
<ul>
<li>
<p><strong>UART0</strong> 可使用：</p>
<ul>
<li>TX：GPIO0、GPIO12、GPIO16</li>
<li>RX：GPIO1、GPIO13、GPIO17</li>
</ul>
</li>
<li>
<p><strong>UART1</strong> 可使用：</p>
<ul>
<li>TX：GPIO4、GPIO8</li>
<li>RX：GPIO5、GPIO9</li>
</ul>
</li>
</ul>
<p>需成对使用同一 UART 控制器的 TX 与 RX。例如，可选择 UART0 的 GPIO0（TX）和 GPIO1（RX），或 UART1 的 GPIO8（TX）和 GPIO9（RX）。</p>
<h2 id="swd-调试引脚"><a class="header" href="#swd-调试引脚">SWD 调试引脚</a></h2>
<p>Pico 2 提供专用的 3 针 SWD（Serial Wire Debug）调试接口，这是 ARM 标准的调试方式，能用于刷写固件、查看寄存器、设置断点和实时调试。</p>
<p><img src="images/raspberry-pi-pico2-rp2350-swd-pins.png" alt="Raspberry Pi Pico 2 SWD Pins"></p>
<p>该接口包含：</p>
<ul>
<li><strong>SWDIO</strong>：串行数据线</li>
<li><strong>SWCLK</strong>：串行时钟线</li>
<li><strong>GND</strong>：地参考</li>
</ul>
<p>这些引脚不与 GPIO 复用，位于板底独立的调试排针上。通常需要借助 Raspberry Pi Debug Probe、CMSIS-DAP 适配器或其它兼容工具（如 OpenOCD、probe-rs）连接这些引脚。</p>
<h2 id="板载温度传感器"><a class="header" href="#板载温度传感器">板载温度传感器</a></h2>
<p>Pico 2 内置一个温度传感器并内部连接到 <strong>ADC4</strong>。你可以像读取外部模拟传感器一样，通过 ADC 获取芯片温度。</p>
<p>该传感器测量的是 RP2350 芯片本身的温度，在芯片负载较高时可能高于室温，不能准确反映环境温度。</p>
<h2 id="控制引脚"><a class="header" href="#控制引脚">控制引脚</a></h2>
<p>这些引脚用于控制开发板的电源行为，可用于复位或关闭芯片。</p>
<ul>
<li>
<p><strong>3V3(EN)</strong> 是板载 3.3V 稳压器的使能引脚，将其拉低会关闭 3.3V 电源轨，从而使 RP2350 关闭。</p>
</li>
<li>
<p><strong>RUN</strong> 是 RP2350 的复位引脚，内部有上拉电阻，默认为高电平，拉低即复位芯片。可用于连接物理复位按钮或由其它设备触发复位。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附加硬件"><a class="header" href="#附加硬件">附加硬件</a></h1>
<p>在本节中，我们将了解在使用 Raspberry Pi Pico 时可能会用到的一些额外硬件。</p>
<h2 id="电子套件"><a class="header" href="#电子套件">电子套件</a></h2>
<p>你可以从基础电子套件开始，或在需要时购买元件。只要包含电阻、杜邦线和面包板，一个简单且低成本的套件就足以入门。这些物品在整个课程中都会用到。</p>
<div class="image-with-caption" style="text-align:center;">
    <img src="images/basic-electronic-kits.jpg" alt="基础电子套件" style="width:400px; height:auto; display:block; margin:auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">基础电子套件</div>

</div>

<p>本书使用的其他元件包括 LED、HC SR04 超声波传感器、有源和无源蜂鸣器、SG90 微型舵机、LDR、NTC 热敏电阻、RC522 RFID 读卡器、micro SD 卡适配器、HD44780 显示屏以及摇杆模块。</p>
<h2 id="可选硬件debug-probe-1"><a class="header" href="#可选硬件debug-probe-1">可选硬件：Debug Probe</a></h2>
<p>Raspberry Pi Debug Probe 让为 Pico 2 刷写固件变得容易得多。如果没有它，每次想上传新固件时都必须按下 BOOTSEL 按钮。该调试器还提供完善的调试支持，非常有用。</p>
<p>该工具是可选的。你可以在没有它的情况下完成整本书（与 debug probe 相关的部分除外）。我最初使用 Pico 时没有调试器，后来才购买了它。</p>
<div class="image-with-caption" style="text-align:center;">
    <img src="images/Raspberry Pi Pico Debug Probe Hardware.jpg" alt="Raspberry Pi Debug Probe 与 Pico 相连" style="width:400px; height:auto; display:block; margin:auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Raspberry Pi Pico Debug Probe</div>

</div>

<h3 id="如何决定"><a class="header" href="#如何决定">如何决定？</a></h3>
<p>如果预算紧张，可以暂时跳过它，因为其价格大约是 Pico 2 的两倍。如果成本不是问题，它是一次不错的购买，而且非常方便。如果你有第二块 Pico，也可以将其用作低成本的 debug probe。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="演示vscodenvim上进行嵌入式开发"><a class="header" href="#演示vscodenvim上进行嵌入式开发">演示：vscode/nvim上进行嵌入式开发</a></h1>
<p>视频？图文？</p>
<h2 id=""><a class="header" href="#"></a></h2>
<h2 id="当我完整的学完且体会完成了这个部分我再过来写这个体会"><a class="header" href="#当我完整的学完且体会完成了这个部分我再过来写这个体会">当我完整的学完且体会完成了这个部分我再过来写这个体会</a></h2>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h1>
<h2 id="安装-rust"><a class="header" href="#安装-rust">安装 Rust</a></h2>
<p>本书示例基于 Rust 工具链开发，推荐使用官方的 rustup 安装器完成配置。</p>
<ul>
<li><strong>Windows</strong>：访问 <a href="https://win.rustup.rs/">https://win.rustup.rs/</a> 下载并运行 <code>rustup-init.exe</code>，按提示选择默认安装。
如提示缺少构建工具，可先安装 <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Visual Studio Build Tools</a>。</li>
<li><strong>Linux</strong>：使用官方脚本安装：
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
</li>
<li><strong>macOS</strong>：可以同样使用官方脚本，或先通过 Homebrew 安装基础依赖后再运行 rustup：
<pre><code class="language-bash">/bin/bash -c "$(curl -fsSL https://sh.rustup.rs)"
</code></pre>
</li>
</ul>
<p>安装完成后，重启终端并确认版本：</p>
<pre><code class="language-bash">rustc --version
cargo --version
</code></pre>
<p>如果之前安装过旧版本，可执行 <code>rustup update</code> 升级。</p>
<p>之后，你还可以使用 <code>rustup</code> 命令来安装 Rust 和 Cargo 的测试版<code>（beta）</code>或 <code>nightly</code> 版本。</p>
<h2 id="picotool"><a class="header" href="#picotool">Picotool</a></h2>
<p><code>picotool</code> 是一个用于操作 RP2040/RP2350 二进制文件的工具，在设备进入 BOOTSEL 模式时可与其交互。</p>
<p><a href="https://github.com/raspberrypi/picotool">Picotool 仓库</a></p>
<div class="alert-box alert-box-info">
    <span class="icon"><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M144 80c0 26.5-21.5 48-48 48s-48-21.5-48-48s21.5-48 48-48s48 21.5 48 48zM0 224c0-17.7 14.3-32 32-32H96c17.7 0 32 14.3 32 32V448h32c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H64V256H32c-17.7 0-32-14.3-32-32z"/></svg></span></span>
    
<div class="alert-content">
        <b class="alert-title">预编译二进制</b>
        
<p>你也可以直接从 <a href="https://github.com/raspberrypi/pico-sdk-tools">这里</a> 下载 SDK 工具的预编译版本，这通常比按步骤构建更为简单。</p>

    </div>

</div>

<p>下面是我采用的快速安装步骤摘要：</p>
<pre><code class="language-sh"># 安装依赖
sudo apt install build-essential pkg-config libusb-1.0-0-dev cmake

mkdir embedded &amp;&amp; cd embedded

# 克隆 Pico SDK
git clone https://github.com/raspberrypi/pico-sdk
cd pico-sdk
git submodule update --init lib/mbedtls
cd ../

# 设置 Pico SDK 的环境变量
PICO_SDK_PATH=/MY_PATH/embedded/pico-sdk

# 克隆 Picotool 仓库
git clone https://github.com/raspberrypi/picotool
</code></pre>
<p>编译并安装 Picotool：</p>
<pre><code class="language-sh">cd picotool
mkdir build &amp;&amp; cd build
# cmake ../
cmake -DPICO_SDK_PATH=/MY_PATH/embedded/pico-sdk/ ../
make -j8
sudo make install
</code></pre>
<p>在 Linux 上，你可以添加 udev 规则以便无需 sudo 即可运行 picotool：</p>
<pre><code class="language-sh">cd ../
# 在 picotool 克隆目录下
sudo cp udev/60-picotool.rules /etc/udev/rules.d/
</code></pre>
<h2 id="rust-目标三元组"><a class="header" href="#rust-目标三元组">Rust 目标三元组</a></h2>
<p>要为 RP2350 芯片构建并部署 Rust 代码，需要添加相应的目标：</p>
<pre><code class="language-sh">rustup target add thumbv8m.main-none-eabihf
rustup target add riscv32imac-unknown-none-elf
</code></pre>
<h2 id="probe-rs--烧录与调试工具"><a class="header" href="#probe-rs--烧录与调试工具">probe-rs —— 烧录与调试工具</a></h2>
<p><code>probe-rs</code> 是一套现代的、原生 Rust 的嵌入式烧录与调试工具链，它同时支持 ARM 与 RISC-V 平台，并可以直接与硬件调试器配合使用。对于使用 Debug Probe 的 Pico 2，<code>probe-rs</code> 是进行烧录和调试的常用工具。</p>
<p>使用官方安装脚本安装 probe-rs：</p>
<pre><code class="language-bash">curl -LsSf https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.sh | sh
</code></pre>
<p>有关最新安装说明，请参考 <a href="https://probe.rs/">probe-rs 官方文档</a>。</p>
<p>默认情况下，Linux 上的调试器只能由 root 访问。为了避免每次都使用 sudo，建议安装相应的 udev 规则，使普通用户也能访问调试器。请按照<a href="https://probe.rs/docs/getting-started/probe-setup/">此处</a>的步骤进行配置。</p>
<p><strong>快速摘要：</strong></p>
<ol>
<li>从 probe-rs 仓库下载 udev 规则文件（<a href="https://probe.rs/files/69-probe-rs.rules">69-probe-rs.rules</a>）</li>
<li>将其复制到 <code>/etc/udev/rules.d/</code></li>
<li>使用 <code>sudo udevadm control --reload</code> 重新加载规则</li>
<li>拔掉并重新插入 Debug Probe</li>
</ol>
<p>完成上述配置后，你就可以在无需 root 权限的情况下使用 <code>probe-rs</code> 了。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="快速上手"><a class="header" href="#快速上手">快速上手</a></h1>
<p>在详细讲解原理之前，我们先直接动手操作：用一段简单的代码点亮 Pico 2 的板载 LED。</p>
<p>我们将使用 Embassy，这是为像 Raspberry Pi Pico 2 这样的微控制器设计的 Rust 框架。Embassy 允许你编写异步（async）代码，能同时处理多个任务，例如在读取按键的同时让 LED 闪烁，而不会阻塞其他任务的执行。</p>
<p>下面的代码通过在高电平（点亮）和低电平（熄灭）之间切换引脚输出实现闪烁效果。如引脚图所述，Pico 2 的板载 LED 连接在 GPIO25。本程序将该引脚配置为输出（当我们需要控制 LED、驱动电机或向其他设备发送信号时使用输出模式），并把初始状态设为低电平（关闭）。</p>
<h2 id="代码片段"><a class="header" href="#代码片段">代码片段</a></h2>
<p>此处仅展示 <code>main</code> 函数的代码。要让它完整运行，还需引入依赖并完成初始化，这些内容将在下一章深入讲解。现在我们主要体验运行效果。你可以克隆我提供的快速上手项目并立即运行。</p>
<blockquote>
<p>注意：此代码不适用于 Pico 2 W 版本。Pico 2 W 的 <code>GPIO25</code> 用于无线接口控制，若需控制板载 LED，需要采用不同的方法。</p>
</blockquote>
<pre class="playground"><code class="language-rust">#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let p = embassy_rp::init(Default::default());

    // 板载 LED 实际上连接在引脚 25
    let mut led = Output::new(p.PIN_25, Level::Low);

    loop {
        led.set_high(); // &lt;- 点亮 LED
        Timer::after_millis(500).await;

        led.set_low(); // &lt;- 熄灭 LED
        Timer::after_millis(500).await;
    }
}</code></pre>
<h2 id="克隆快速上手项目"><a class="header" href="#克隆快速上手项目">克隆快速上手项目</a></h2>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-quick
cd pico2-quick
</code></pre>
<h2 id="如何运行"><a class="header" href="#如何运行">如何运行？</a></h2>
<p>要把程序刷入 Pico 2，请按住 BOOTSEL 按钮，同时使用 Micro USB 数据线将其连接到电脑。USB 插好后即可松开按钮。</p>
<img style="display: block; margin: auto;" alt="bootsel" src="images/bootsel.png" />
<pre><code class="language-sh"># 运行程序
cargo run
</code></pre>
<p>该命令会把程序写入 Pico 2 的闪存并自动运行。如果成功，你会看到板载 LED 按固定间隔闪烁。若出现错误，请检查开发环境与硬件连接是否正确；若仍无法解决，请在 GitHub 提交 issue 并附上详细信息，以便我改进本指南。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="一切的开始cargo"><a class="header" href="#一切的开始cargo">一切的开始—cargo</a></h1>
<h2 id="cargo简介"><a class="header" href="#cargo简介">Cargo简介</a></h2>
<p><strong>Cargo：Rust的包管理工具</strong> Cargo 是 Rust 语言的官方包管理器。它负责下载你的 Rust 项目的依赖库，编译你的代码，生成可执行的包，并将这些包上传到 <a href="https://crates.io/">crates.io</a>——Rust 社区的官方包仓库。</p>
<div class="image-with-caption" style="text-align:center;">
    <img src="images/Cargo-Logo-Small.png" alt="cargo" style="width:400px; height:auto; display:block; margin:auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Cargo</div>

</div>

<p>在“快速上手”章节中，我们使用 cargo 指令将示例刷写到 Pico 2 中：</p>
<ol>
<li>克隆示例仓库并进入目录。</li>
<li>将 Pico 2 按住 BOOTSEL 后通过 USB 连接电脑，松开按键让设备进入可写模式。</li>
<li>执行 <code>cargo run</code>，cargo 会根据项目配置完成编译，并通过预设的 runner 将生成的镜像写入 Pico 2。</li>
<li>烧录完成后，板载 LED 会按固定频率闪烁。</li>
</ol>
<p>这个流程展示了 cargo 在嵌入式项目中的常见用法：一条命令同时完成构建与烧录，便于快速迭代。[这里补充C语言中是怎么进行的？]</p>
<p>!后续再慢慢进行优化吧，现在体会还不算太深入，一定要边进行C开发，一遍进行Rust开发，两者结合着来进行学习</p>
<h2 id="cargo-run都干啥了"><a class="header" href="#cargo-run都干啥了">Cargo run都干啥了</a></h2>
<p>cargo 在 <code>pico2-quick</code> 项目中串起了从编译到烧录的完整链路：</p>
<ul>
<li>目标与运行器：</li>
<li>构建脚本：<code>build.rs</code> 在编译前把 <code>memory.x</code> 复制到输出目录，并追加 <code>--nmagic</code>、<code>-Tlink.x</code>、<code>-Tdefmt.x</code> 等链接参数，保证内存布局和 defmt 支持符合嵌入式需求。</li>
<li>依赖与特性：<code>Cargo.toml</code> 启用 <code>embassy-rp</code> 的 <code>rp235xa</code>、<code>time-driver</code>、<code>binary-info</code> 等特性，以及 <code>defmt</code>、<code>panic-probe</code>，cargo 会按这些选项拉取并构建出能在 RP2350 上运行的固件。</li>
<li>环境变量：同一配置设定 <code>DEFMT_LOG=debug</code>，编译时写入日志等级，便于用 RTT 查看输出。</li>
</ul>
<h3 id="目标与运行器"><a class="header" href="#目标与运行器">目标与运行器</a></h3>
<p><code>.cargo/config.toml</code> 设定交叉编译目标 <code>thumbv8m.main-none-eabihf</code>，runner 为 <code>sudo picotool load -u -v -x -t elf</code>，因此 <code>cargo run</code> 会编译后自动调用 picotool 把 ELF(可链接文件) 写入 Pico 2。</p>
<pre><code class="language-toml">[target.'cfg(all(target_arch = "arm", target_os = "none"))']
#runner = "probe-rs run --chip RP2040"
#runner = "elf2uf2-rs -d"
runner = "sudo picotool load -u -v -x -t elf"

[build]
target = "thumbv8m.main-none-eabihf"

[env]
DEFMT_LOG = "debug"
</code></pre>
<h3 id="构建脚本"><a class="header" href="#构建脚本">构建脚本</a></h3>
<p>运行 <code>build.rs</code>，同步 <code>memory.x</code> 并注入链接参数。
<code>build.rs</code> 保障了裸机固件的内存脚本可用、链接参数正确，且只在相关文件变化时重跑，减少不必要的构建成本。</p>
<p>该构建脚本一般是官方模板/社区随模板提供的，基本不用自己修改</p>
<h3 id="依赖与特性"><a class="header" href="#依赖与特性">依赖与特性</a></h3>
<p><code>pico2-quick</code>项目中的<code>Cargo.toml</code>，定义嵌入式异步运行时（Embassy）、Pico 2 芯片支持（embassy-rp 及特性）、调试与 panic 输出（defmt/ panic-probe），并通过 Cortex-M 运行时完成裸机启动。</p>
<pre><code class="language-toml">[package]
name = "pico2-quick"
version = "0.2.0"
edition = "2024"

[dependencies]

# Embassy 的异步执行器，启用 Cortex-M 架构支持、线程化执行器和 defmt 日志集成。
embassy-executor = { version = "0.9", features = [
"arch-cortex-m",
"executor-thread",
"defmt",
] }

# panic 处理器，将崩溃信息通过 defmt 输出，便于 RTT 调试。
panic-probe = { version = "1.0", features = ["print-defmt"] }

# 异步定时器/计时工具。
embassy-time = { version = "0.5.0" }

# RP2 系列 HAL，启用 defmt 日志、时间驱动、临界区实现、RP235x A 版芯片支持，以及 picotool 用的 binary info 段。
embassy-rp = { version = "0.8.0", features = [
"defmt",
"time-driver",
"critical-section-impl",
"rp235xa",
"binary-info",
] }

# ARM Cortex-M 底层支持与运行时启动代码（向量表、reset handler）
cortex-m = { version = "0.7.6" }
cortex-m-rt = "0.7.5"

# 轻量日志框架及 RTT 后端，用于在调试器或 picotool 环境下输出日志。
defmt = "1.0.1"
defmt-rtt = "1.0"
</code></pre>
<h3 id="烧录和调试"><a class="header" href="#烧录和调试">烧录和调试</a></h3>
<p>调用 runner：<code>sudo picotool load -u -v -x -t elf &lt;生成的ELF&gt;</code>，向 BOOTSEL 模式的 Pico 2 烧录固件。烧录完成后设备复位运行，LED 开始闪烁；需要调试时可通过 RTT 读取 defmt 日志。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="抽象层"><a class="header" href="#抽象层">抽象层</a></h1>
<p>在嵌入式 Rust 开发中，你经常会遇到 PAC、HAL 和 BSP 这样的术语。它们是与硬件交互的不同抽象层，每一层在灵活性与易用性之间做出不同的权衡。</p>
<p>下面从高到低介绍这些抽象层。</p>
<p><a href="images/abstraction-layers.png"><img alt="abstraction layers" style="display: block; margin: auto;" src="images/abstraction-layers.png" /></a></p>
<h2 id="板级支持包bsp"><a class="header" href="#板级支持包bsp">板级支持包（BSP）</a></h2>
<p>BSP（在 Rust 中通常称为 Board Support Crate）是针对特定开发板的封装。它将 HAL 与板级配置结合，提供对板载组件（如 LED、按键、传感器）即插即用的接口，使开发者能更多关注应用逻辑而非底层细节。由于目前没有广泛使用的专门针对 Raspberry Pi Pico 2 的 BSP，本书不会采用该方式。</p>
<hr>
<h2 id="硬件抽象层hal"><a class="header" href="#硬件抽象层hal">硬件抽象层（HAL）</a></h2>
<p>HAL 位于 BSP 之下。如果你使用 Raspberry Pi Pico 或基于 ESP32 的板子，大多数场景会直接使用 HAL 层。HAL 通常以芯片为目标（例如 RP2350 或 ESP32），因此同一个 HAL 可以在多个使用相同微控制器的开发板间复用。针对 Raspberry Pi 家族微控制器，有社区维护的 <code>rp-hal</code> 仓库可供使用（https://github.com/rp-rs/rp-hal）。</p>
<p>HAL 构建在 PAC 之上，提供更简单的高层接口来操作外设。与直接操控寄存器不同，HAL 提供的方法与 trait 能更方便地完成定时器配置、串口初始化或 GPIO 控制等任务。</p>
<p>微控制器的 HAL 通常实现 <code>embedded-hal</code> trait，这是一套平台无关的外设接口（如 GPIO、SPI、I2C、UART），有助于编写可跨平台复用的驱动与库。</p>
<h3 id="对于-raspberry-piembassy"><a class="header" href="#对于-raspberry-piembassy">对于 Raspberry Pi：Embassy</a></h3>
<p>Embassy 在抽象层次上与 HAL 同级，但它提供了一个带异步能力的运行时环境。Embassy（在本书中特指 <code>embassy-rp</code>）基于 HAL 层构建，提供异步执行器、定时器等抽象，简化编写并发嵌入式程序的复杂度。</p>
<p>针对 Raspberry Pi 微控制器（RP2040 / RP235x），有专门的 <code>embassy-rp</code> crate，构建于 <code>rp-pac</code>（Raspberry Pi Peripheral Access Crate）之上。</p>
<p>在本书中，我们会根据练习需要同时使用 <code>rp-hal</code> 与 <code>embassy-rp</code>。</p>
<hr>
<blockquote>
<p>注意：</p>
<p>HAL 之下的层通常不会被直接使用。大多数情况下通过 HAL 访问 PAC 即可。除非你所使用的芯片没有可用的 HAL，否则一般无需直接与低层交互。本书重点关注 HAL 层的使用。</p>
</blockquote>
<h2 id="外设访问包pac"><a class="header" href="#外设访问包pac">外设访问包（PAC）</a></h2>
<p>PAC 是最低级别的抽象，通常由厂商的 SVD（System View Description）文件生成，提供类型安全的寄存器访问接口。PAC 为直接操作硬件寄存器提供了结构化且更安全的方式（通常通过 <code>svd2rust</code> 工具生成）。</p>
<h2 id="原始-mmio"><a class="header" href="#原始-mmio">原始 MMIO</a></h2>
<p>原始 MMIO（memory-mapped IO）指直接按地址读写硬件寄存器。这种方式类似传统 C 语言的寄存器操作，因其潜在风险在 Rust 中需要使用 <code>unsafe</code> 块。我们不会涉及这部分内容；在社区中这种做法并不常见。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="项目模板---使用-cargo-generate"><a class="header" href="#项目模板---使用-cargo-generate">项目模板 - 使用 <code>cargo-generate</code></a></h1>
<p><code>cargo-generate</code> 是一个便捷工具，能通过使用已有的 Git 仓库作为模板，快速创建新的 Rust 项目。</p>
<p>更多信息请参见：https://github.com/cargo-generate/cargo-generate</p>
<h2 id="前置要求"><a class="header" href="#前置要求">前置要求</a></h2>
<p>开始之前，请确保已安装以下工具：</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Rust</a></li>
<li><a href="https://github.com/cargo-generate/cargo-generate">cargo-generate</a>（用于生成项目模板）</li>
</ul>
<p>先安装 OpenSSL 开发包，因为 <code>cargo-generate</code> 依赖它：</p>
<pre><code class="language-sh">sudo apt install libssl-dev
</code></pre>
<p>你可以通过下面的命令安装 <code>cargo-generate</code>：</p>
<pre><code class="language-sh">cargo install cargo-generate
</code></pre>
<h2 id="第-1-步生成项目"><a class="header" href="#第-1-步生成项目">第 1 步：生成项目</a></h2>
<p>运行下面命令，从模板生成项目：</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git
</code></pre>
<p>执行后会提示你回答几个问题：</p>
<ul>
<li>Project name：为项目命名。</li>
<li>HAL choice：可在 <code>embassy</code> 或 <code>rp-hal</code> 之间选择。</li>
</ul>
<h2 id="第-2-步默认的-led-闪烁示例"><a class="header" href="#第-2-步默认的-led-闪烁示例">第 2 步：默认的 LED 闪烁示例</a></h2>
<p>默认生成的项目中包含一个简单的 LED 闪烁示例。项目结构可能类似：</p>
<p><code>src/main.rs</code>：包含默认的闪烁逻辑。</p>
<p><code>Cargo.toml</code>：包含为所选 HAL 添加的依赖项。</p>
<h2 id="第-3-步选择-hal-并修改代码"><a class="header" href="#第-3-步选择-hal-并修改代码">第 3 步：选择 HAL 并修改代码</a></h2>
<p>项目生成后，你可以保留默认的 LED 示例，也可以将其删除并根据所选 HAL 替换为自己的代码。</p>
<h2 id="移除不需要的代码"><a class="header" href="#移除不需要的代码">移除不需要的代码</a></h2>
<p>可以从 <code>src/main.rs</code> 中删掉示例的闪烁逻辑，并按需替换。根据项目需要修改 <code>Cargo.toml</code> 的依赖与项目结构。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="运行程序"><a class="header" href="#运行程序">运行程序</a></h1>
<p>在深入其他示例之前，我们先覆盖在 Raspberry Pi Pico 2 上构建并运行任意程序的一般步骤。Pico 2 包含 ARM Cortex-M33 与 Hazard3 RISC-V 两类处理器，这里会给出两种架构的构建说明。</p>
<p>注意：下列命令应在你的项目目录中执行。若尚未创建项目，请先参阅“快速上手”或“Blink LED”章节。</p>
<h2 id="在-arm-模式下构建与运行"><a class="header" href="#在-arm-模式下构建与运行">在 ARM 模式下构建与运行</a></h2>
<p>使用下面的命令为 Pico 2 的 ARM 模式（Cortex-M33）构建程序：</p>
<pre><code class="language-sh"># 构建程序
cargo build --target=thumbv8m.main-none-eabihf
</code></pre>
<p>要将应用刷入 Pico 2，请按住 BOOTSEL 按钮，同时用 Micro USB 将设备连接到电脑。USB 插入后即可松开按钮。</p>
<img style="display: block; margin: auto;" alt="bootsel" src="images/bootsel.png" />
<pre><code class="language-sh"># 运行程序
cargo run --target=thumbv8m.main-none-eabihf
</code></pre>
<p><strong>说明：</strong> 示例工程中在 <code>.cargo/config.toml</code> 中配置了 runner，例如：<br><code>runner = "picotool load -u -v -x -t elf"</code>。这意味着执行 <code>cargo run</code> 时会调用 <code>picotool load</code> 子命令来刷写程序。</p>
<h2 id="在-risc-v-模式下构建与运行"><a class="header" href="#在-risc-v-模式下构建与运行">在 RISC-V 模式下构建与运行</a></h2>
<p>使用下面的命令为 Pico 2 的 RISC‑V 模式（Hazard3）构建程序。</p>
<blockquote>
<p>注意：本书以 ARM 示例为主；部分示例在 RISC‑V 下可能需作调整。若想简化学习流程，建议优先按照 ARM 工作流进行操作。</p>
</blockquote>
<pre><code class="language-sh"># 构建程序
cargo build --target=riscv32imac-unknown-none-elf
</code></pre>
<p>按照前述 BOOTSEL 步骤把设备置于刷写模式，然后执行：</p>
<pre><code class="language-sh"># 运行程序
cargo run --target=riscv32imac-unknown-none-elf
</code></pre>
<h2 id="使用-debug-probe"><a class="header" href="#使用-debug-probe">使用 Debug Probe</a></h2>
<p>使用 Debug Probe 时，可以直接将程序刷入 Pico 2：</p>
<pre><code class="language-sh"># cargo flash --chip RP2350
# cargo flash --chip RP2350 --release
cargo flash --release
</code></pre>
<p>若希望在刷写的同时查看实时输出，可使用：</p>
<pre><code class="language-sh"># cargo embed --chip RP2350
# cargo embed --chip RP2350 --release
cargo embed --release
</code></pre>
<p><a href="https://probe.rs/docs/tools/cargo-embed/">cargo-embed</a> 是比 <code>cargo-flash</code> 更强大的工具，既能刷写程序，也能打开 RTT 终端与 GDB 服务。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="帮助与故障排查"><a class="header" href="#帮助与故障排查">帮助与故障排查</a></h1>
<p>在完成练习时如果遇到任何 bug、错误或其他问题，可以参考以下方法进行排查和解决。</p>
<h2 id="1-与可运行代码对比"><a class="header" href="#1-与可运行代码对比">1. 与可运行代码对比</a></h2>
<p>查看完整的代码示例，或克隆参考项目进行比对。仔细检查你的代码和 <code>Cargo.toml</code> 中的依赖版本。留意任何语法或逻辑错误。如果需要的 feature 未启用或存在 feature 不匹配，务必按练习所示启用正确的 feature。</p>
<p>如果发现版本不匹配，可以选择调整你的代码（查阅资料找到解决方案；这是学习和深入理解的好方法）以适配较新版本，或将依赖更新为教程中使用的版本。</p>
<h2 id="2-搜索或提交-github-issue"><a class="header" href="#2-搜索或提交-github-issue">2. 搜索或提交 GitHub Issue</a></h2>
<p>访问 GitHub issues 页面，查看是否有人遇到相同问题：
<a href="https://github.com/ImplFerris/pico-pico/issues?q=is%3Aissue">https://github.com/ImplFerris/pico-pico/issues?q=is%3Aissue</a></p>
<p>如果没有，你可以新建一个 issue，并清晰描述你的问题。</p>
<h2 id="3-向社区求助"><a class="header" href="#3-向社区求助">3. 向社区求助</a></h2>
<p>Rust Embedded 社区在 Matrix 聊天中非常活跃。Matrix 是一个开放网络，用于安全、去中心化的通信。</p>
<p>以下是与本书涵盖主题相关的一些有用 Matrix 频道：</p>
<ul>
<li>
<p><strong>Embedded Devices Working Group</strong><br><a href="https://matrix.to/#/#rust-embedded:matrix.org"><code>#rust-embedded:matrix.org</code></a><br>关于在嵌入式开发中使用 Rust 的通用讨论。</p>
</li>
<li>
<p><strong>RP Series Development</strong><br><a href="https://matrix.to/#/#rp-rs:matrix.org"><code>#rp-rs:matrix.org</code></a><br>面向 Raspberry Pi RP 系列芯片的 Rust 开发与讨论。</p>
</li>
<li>
<p><strong>Debugging with Probe-rs</strong><br><a href="https://matrix.to/#/#probe-rs:matrix.org"><code>#probe-rs:matrix.org</code></a><br>围绕 <a href="https://probe.rs">probe-rs</a> 调试工具包的支持与讨论。</p>
</li>
<li>
<p><strong>Embedded Graphics</strong><br><a href="https://matrix.to/#/#rust-embedded-graphics:matrix.org"><code>#rust-embedded-graphics:matrix.org</code></a><br>使用 <a href="https://docs.rs/embedded-graphics"><code>embedded-graphics</code></a>（面向嵌入式系统的绘图库）相关的交流。</p>
</li>
</ul>
<p>你可以创建 Matrix 账号并加入这些频道，从经验丰富的开发者那里获得帮助。</p>
<p>更多社区聊天室可在 <a href="https://github.com/rust-embedded/awesome-embedded-rust?tab=readme-ov-file#community-chat-rooms">Awesome Embedded Rust - Community Chat Rooms 部分</a>找到。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="用于-raspberry-pi-pico-2-的调试器debug-probe"><a class="header" href="#用于-raspberry-pi-pico-2-的调试器debug-probe">用于 Raspberry Pi Pico 2 的调试器（Debug Probe）</a></h1>
<p>每次烧录新程序时都要按 BOOTSEL 按钮非常麻烦。像 ESP32 DevKit 这样的开发板大多能自动完成这一步，因为开发板可以在需要时将芯片重置到引导加载程序（bootloader）模式。Pico 2 本身不具备此功能，但通过使用调试器（debug probe），你不仅能获得同样的便利性，还能拥有更强的调试能力。</p>
<p>本章将解释为什么调试器很有用，并逐步指导你如何设置并使用它，在无需按 BOOTSEL 按钮的情况下对 Pico 2 进行烧录和调试。</p>
<h2 id="raspberry-pi-调试器raspberry-pi-debug-probe"><a class="header" href="#raspberry-pi-调试器raspberry-pi-debug-probe">Raspberry Pi 调试器（Raspberry Pi Debug Probe）</a></h2>
<p>Raspberry Pi 调试器是官方推荐用于 Pico 和 Pico 2 上 SWD 调试的工具。它是一个小型 USB 设备，充当 CMSIS-DAP 适配器。CMSIS-DAP 是一种开源调试器标准，允许你的电脑通过 SWD 协议与微控制器通信。</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="debugging/images/Debug Probe for Raspberry Pi Pico 2 - Rust Debugging.jpg" alt="Raspberry Pi Debug Probe connected with Pico" style="max-width:100%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">图片来源：<a href="https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.html">raspberrypi.com</a> — 调试器连接 Pico。</div>

</div>

<p>该调试器提供两大核心功能：</p>
<ol>
<li><strong>SWD（Serial Wire Debug，串行线调试）接口</strong>：连接到 Pico 的调试引脚，用于烧录固件和进行实时调试。你可以设置断点、检查变量，就像在普通桌面应用程序中调试一样。</li>
<li><strong>UART 桥接器</strong>：提供 USB 转串口连接，让你能在电脑上查看控制台输出或与开发板通信。</li>
</ol>
<p>这两项功能都通过同一根连接到电脑的 USB 线实现，因此无需额外的 UART 设备，使整体设置更加简洁。</p>
<h2 id="焊接-swd-引脚"><a class="header" href="#焊接-swd-引脚">焊接 SWD 引脚</a></h2>
<p>在将调试器连接到 Pico 2 之前，你需要让 <a href="#swd-debugging-pins">SWD 引脚</a> 可被访问。这些引脚位于 Pico 板底部边缘，是一个独立于主 GPIO 引脚的小型 3 针调试排针。</p>
<div class="image-with-caption" style="text-align:center; display:inline-block;">
    <img src="images/raspberry-pi-pico2-rp2350-swd-pins.png" alt="Raspberry Pi Debug Probe connected with Pico" style="max-width:100%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">SWD 调试引脚</div>

</div>

<p>一旦焊接好 SWD 引脚，你的 Pico 就可以连接调试器了。</p>
<h2 id="准备调试器"><a class="header" href="#准备调试器">准备调试器</a></h2>
<p>你的调试器出厂时可能未预装最新固件，尤其是尚未包含对 Pico 2（RP2350 芯片）支持的版本。建议在开始使用前先更新固件。</p>
<p>Raspberry Pi 官方文档提供了清晰的调试器固件更新说明。请按照<a href="https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.html#updating-the-firmware-on-the-debug-probe">此处</a>提供的步骤操作。</p>
<h2 id="将-pico-与调试器连接"><a class="header" href="#将-pico-与调试器连接">将 Pico 与调试器连接</a></h2>
<p>调试器侧面有两个端口：</p>
<ul>
<li><strong>D 端口</strong>：用于 SWD（调试）连接</li>
<li><strong>U 端口</strong>：用于 UART（串口）连接</li>
</ul>
<h3 id="swd-连接必需"><a class="header" href="#swd-连接必需">SWD 连接（必需）</a></h3>
<p>SWD 连接用于烧录固件和使用调试器。请使用随调试器附带的 JST 转杜邦线。</p>
<p>将调试器 D 端口的线缆按如下方式连接到 Pico 2 引脚：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>调试器线缆颜色</th><th>Pico 2 引脚</th></tr>
</thead>
<tbody>
<tr><td>橙色</td><td>SWCLK</td></tr>
<tr><td>黑色</td><td>GND</td></tr>
<tr><td>黄色</td><td>SWDIO</td></tr>
</tbody>
</table>
</div>
<p>连接前请确保 Pico 2 的 SWD 引脚已正确焊接。</p>
<h3 id="uart-连接可选"><a class="header" href="#uart-连接可选">UART 连接（可选）</a></h3>
<p>如果你希望在电脑终端中查看串口输出（例如来自 Rust 的 <code>println!</code> 日志），UART 连接会非常有用。它与 SWD 连接相互独立。</p>
<p>将调试器 U 端口的线缆连接到 Pico 2 引脚：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>调试器线缆颜色</th><th>Pico 2 引脚</th><th>物理引脚编号</th></tr>
</thead>
<tbody>
<tr><td>黄色</td><td>GP0（Pico 的 TX）</td><td><strong>引脚 1</strong></td></tr>
<tr><td>橙色</td><td>GP1（Pico 的 RX）</td><td><strong>引脚 2</strong></td></tr>
<tr><td>黑色</td><td>GND</td><td><strong>引脚 3</strong></td></tr>
</tbody>
</table>
</div>
<p>虽然你可以使用任意配置为 UART 的 GPIO 引脚，但 GP0 和 GP1 是 Pico 默认的 UART0 引脚。</p>
<h3 id="为-pico-供电"><a class="header" href="#为-pico-供电">为 Pico 供电</a></h3>
<p>调试器<strong>不会</strong>为 Pico 2 供电，仅提供 SWD 和 UART 信号。要为 Pico 2 供电，请将调试器通过 USB 连接到电脑，同时通过 Pico 2 自身的 USB 接口为其单独供电。只有两个设备都通电，调试才能正常工作。</p>
<h3 id="最终设置"><a class="header" href="#最终设置">最终设置</a></h3>
<p>连接完成后：</p>
<ol>
<li>将调试器通过 USB 插入电脑</li>
<li>确保 Pico 2 已通电</li>
<li>调试器上的红色 LED 应点亮，表示已通电</li>
<li>设置完成——从此无需再按 BOOTSEL 按钮</li>
</ol>
<p>你现在可以直接通过开发环境对 Pico 2 进行烧录和调试，无需任何手动干预。</p>
<h2 id="测试连接"><a class="header" href="#测试连接">测试连接</a></h2>
<p>要验证调试器与 Pico 2 是否正确连接，可以使用快速入门项目进行测试：</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-quick
cd pico2-quick
</code></pre>
<p>你不能像之前那样直接使用 <code>cargo run</code>，除非你修改了 <code>config.toml</code> 文件。因为该项目默认使用 <code>picotool</code> 作为运行器。你可以注释掉 <code>picotool</code> 运行器并启用 <code>probe-rs</code> 运行器，之后就能使用 <code>cargo run</code> 命令。</p>
<p>或者更简单的方式（推荐）：直接使用 <code>probe-rs</code> 提供的以下命令，通过调试器烧录程序：</p>
<pre><code class="language-sh">cargo flash
# 或
cargo flash --release
</code></pre>
<h2 id="cargo-embed"><a class="header" href="#cargo-embed">cargo embed</a></h2>
<p>你可以使用 <code>cargo embed</code> 命令烧录程序并在终端中实时查看日志输出。快速入门项目已配置为通过 RTT 发送日志消息，因此无需额外配置即可直接使用。</p>
<pre><code class="language-sh">cargo embed
# 或 
cargo embed --release
</code></pre>
<p>如果你还不熟悉 RTT，我们稍后会详细解释。现在你只需运行上述命令，即可看到程序运行并打印日志。</p>
<p>如果一切正常，你应该会在系统终端中看到 “Hello, World!” 消息。</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="debugging/images/Rust cargo embed command with Raspberry Pi Pico.png" alt="cargo embed with defmt" style="max-width:100%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">cargo embed 显示 defmt 日志</div>

</div>

<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li><a href="https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.html">Raspberry Pi 调试器 — 官方文档</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="实时传输real-time-transfer-rtt"><a class="header" href="#实时传输real-time-transfer-rtt">实时传输（Real-Time Transfer, RTT）</a></h1>
<p>在开发嵌入式系统时，你需要一种方式来观察程序内部的运行情况。在普通计算机上，你可以使用 <code>println!</code> 将消息打印到终端。但在微控制器上，并没有连接屏幕或终端。实时传输（Real-Time Transfer, RTT）通过允许你将调试信息和日志从微控制器发送到电脑，解决了这一问题。</p>
<h2 id="什么是-rtt"><a class="header" href="#什么是-rtt">什么是 RTT？</a></h2>
<p>RTT 是一种通信方法，可让你的微控制器通过已用于烧录程序的调试器（debug probe）向电脑发送消息。</p>
<p>当你将 Raspberry Pi 调试器连接到 Pico 时，就建立了一个具备以下两种功能的连接：</p>
<ul>
<li>向芯片烧录新程序</li>
<li>读写芯片内存</li>
</ul>
<p>RTT 利用了这种内存访问能力。它在微控制器上创建特殊的内存缓冲区，调试器则读取这些缓冲区，并将消息显示在你的电脑上。这一切都在后台进行，不会影响程序的正常运行。</p>
<h2 id="使用-defmt-进行日志记录"><a class="header" href="#使用-defmt-进行日志记录">使用 Defmt 进行日志记录</a></h2>
<p><a href="https://github.com/knurling-rs/defmt">Defmt</a>（“deferred formatting”，即“延迟格式化”的缩写）是一个专为资源受限设备（如微控制器）设计的日志框架。在你的 Rust 嵌入式项目中，你将使用 defmt 来打印消息并调试程序。</p>
<p>Defmt 通过延迟格式化和字符串压缩实现高性能。所谓延迟格式化，是指格式化操作并非在记录日志的设备上完成，而是在另一台设备（如你的电脑）上进行。</p>
<p>你的 Pico 发送的是小型代码，而非完整的文本消息。你的电脑接收这些代码并将其还原为可读的文本。这种方式使固件体积更小，并避免了在微控制器上执行缓慢的字符串格式化操作。</p>
<p>你可以在项目中添加 defmt 依赖：</p>
<pre><code class="language-toml">defmt = "1.0.1"
</code></pre>
<p>然后像这样使用它：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use defmt::{info, warn, error};

...
info!("Starting program");
warn!("You shall not pass!");
error!("Something went wrong!");
<span class="boring">}</span></code></pre>
<h3 id="defmt-rtt"><a class="header" href="#defmt-rtt">Defmt RTT</a></h3>
<p>Defmt 本身并不知道如何将消息从 Pico 发送到电脑，它需要一个传输层。这就是 <code>defmt-rtt</code> 的作用所在。</p>
<p><code>defmt-rtt</code> crate 将 defmt 与 RTT 连接起来，使你的日志消息能通过调试器传输到电脑。</p>
<p>你可以在项目中添加 <code>defmt-rtt</code> 依赖：</p>
<pre><code class="language-toml">defmt-rtt = "1.0"
</code></pre>
<blockquote>
<p>注意：要查看 RTT 和 defmt 日志，你需要使用 <code>probe-rs</code> 工具（例如 <code>cargo embed</code> 命令）运行程序。这些工具会自动开启 RTT 会话，并在终端中显示日志。</p>
</blockquote>
<p>然后在代码中引入它：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use defmt_rtt as _;
<span class="boring">}</span></code></pre>
<p>这行代码建立了 defmt 与 RTT 之间的连接。你无需直接调用其中的任何函数，但必须导入该 crate 才能使其生效。</p>
<h3 id="使用-panic-probe-显示-panic-信息"><a class="header" href="#使用-panic-probe-显示-panic-信息">使用 Panic-Probe 显示 Panic 信息</a></h3>
<p>当程序崩溃（panic）时，你希望看到具体出错的原因。<code>panic-probe</code> crate 可以让 panic 信息通过 defmt 和 RTT 显示出来。</p>
<p>你可以在项目中添加 <code>panic-probe</code> 依赖：</p>
<pre><code class="language-toml"># print-defmt 特性：告诉 panic-probe 使用 defmt 输出信息。
panic-probe = { version = "1.0", features = ["print-defmt"] }
</code></pre>
<p>然后在代码中引入它：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panic_probe as _;
<span class="boring">}</span></code></pre>
<p>你可以手动触发一次 panic 来测试 panic 信息的显示效果。尝试在代码中加入以下内容：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>panic!("something went wrong");
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="闪烁外部-led"><a class="header" href="#闪烁外部-led">闪烁外部 LED</a></h1>
<p>从现在开始，我们将与 Pico 一起使用更多外部部件。在此之前，熟悉简单的电路以及如何将组件连接到 Pico 的引脚会有所帮助。在本章中，我们将从一个基本的东西开始：闪烁连接在电路板外的 LED。</p>
<h2 id="硬件需求"><a class="header" href="#硬件需求">硬件需求</a></h2>
<ul>
<li>LED</li>
<li>电阻</li>
<li>跳线</li>
</ul>
<h2 id="组件概述"><a class="header" href="#组件概述">组件概述</a></h2>
<ol>
<li>
<p>LED：发光二极管（LED）在电流通过时会发光。较长的引脚（阳极）连接到正极，较短的引脚（阴极）连接到地线。我们将阳极连接到 GP13（带电阻），阴极连接到 GND。</p>
</li>
<li>
<p>电阻：电阻限制电路中的电流，以保护 LED 等组件。其值以欧姆（Ω）计量。我们将使用 330 欧电阻来安全地为 LED 供电。</p>
</li>
</ol>
<table>
  
<thead>
    
<tr>
      <th>Pico 引脚</th>
      <th style="width: 250px; margin: 0 auto;">导线</th>
      <th>组件</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>GPIO 13</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire yellow" style="width: 200px; margin: 0 auto;">
          
<div class="female-left"></div>

          
<div class="female-right"></div>

        </div>

      </td>
      <td>电阻</td>
    </tr>

    
<tr>
      <td>电阻</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire orange" style="width: 200px; margin: 0 auto;">
          
<div class="female-left"></div>

          
<div class="female-right"></div>

        </div>

      </td>
      <td>LED 的阳极（长脚）</td>
    </tr>

    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="female-left"></div>

          
<div class="female-right"></div>

        </div>

      </td>
      <td>LED 的阴极（短脚）</td>
    </tr>

  </tbody>

</table>

<img style="display: block; margin: auto;" alt="pico2" src="images/pico-external-led.png" />
<p>你可以使用跳线直接将 Pico 连接到 LED，或者可以在面包板上放置所有东西。如果你对硬件设置不确定，也可以参考 <a href="https://projects.raspberrypi.org/en/projects/introduction-to-the-pico/7">Raspberry Pi 指南</a>。</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="led/images/pico-2-rp2350-with-external-led.png" alt="使用 Pico 2（RP2350）连接外部 LED" style="max-width:100%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">面包板电路</div>

</div>

<p>注意：在 Pico 上，引脚标签在电路板的背面，在插入导线时可能会感到不便。我经常需要在想要使用通用输入输出（GPIO）引脚时检查引脚分配图。使用前面的 Raspberry Pi 标志作为参考点，并将其与<a href="#raspberry-pi-pico-2-引脚图">引脚分配图</a>相匹配以找到正确的引脚。引脚位置 2 和 39 也印在前面，可以作为额外的参考指南。</p>
<h2 id="led-闪烁---模拟"><a class="header" href="#led-闪烁---模拟">LED 闪烁 - 模拟</a></h2>
<style>
.wrap{
  margin:0px auto;
  padding:18px;
  background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border-radius:10px;
  box-shadow:0 8px 24px rgba(2,6,23,0.45);
  color:var(--mm-text, #e6eef8);
  font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace;
}

.top{display:flex;gap:18px;align-items:center;flex-wrap:wrap}

/* LED visual */
.led{
  width:56px;height:56px;border-radius:50%;background:#334155;display:flex;align-items:center;justify-content:center;
  box-shadow:0 0 0 6px rgba(16,185,129,0.02), inset 0 -6px 12px rgba(0,0,0,0.5);
  transition:background 180ms,box-shadow 180ms,transform 180ms;
}
.led.on{
  background:radial-gradient(circle at 35% 30%, #bbf7d0, #10b981);
  box-shadow:0 0 18px rgba(16,185,129,0.45), 0 6px 20px rgba(0,0,0,0.45);
  transform:scale(1.06);
}
.led-label{font-size:13px;color:#94a3b8;margin-top:8px;text-align:center}

/* Code lines */
.code{
  margin-top:8px;
  background:#0b1220;
  padding:12px;
  border-radius:8px;
  font-size:14px;
  color:#cbd5e1;
  overflow:auto;
}
.line{padding:6px 8px;border-radius:6px;display:flex;align-items:center;gap:10px}
.line .num{width:28px;color:#94a3b8;text-align:right;padding-right:6px}
.line .text{white-space:pre}
.line.current{
  background:linear-gradient(90deg, rgba(255,0,0,0.35), rgba(255,150,150,0.25));
  box-shadow:inset 0 0 10px rgba(255,0,0,0.45);
}

/* progress bar */
.progress-wrap{margin-top:10px}
.progress{height:12px;background:rgba(255,255,255,0.04);border-radius:8px;overflow:hidden}
.bar{height:100%;width:0%;background:linear-gradient(90deg, rgba(16,185,129,0.95), rgba(34,197,94,0.95));transition:width 0.06s linear}
.progress-info{display:flex;justify-content:space-between;margin-top:6px;color:#94a3b8;font-size:13px}

/* controls */
.controls{margin-top:12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
button{background:#0b1826;border:1px solid rgba(255,255,255,0.03);color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer}
button:active{transform:translateY(1px)}
input[type=number]{width:110px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#071023;color:inherit}
</style>
<p>在这个模拟中，我将默认延迟设置为 5000 毫秒，以便动画更平缓，更容易跟踪。你可以将其降低到 500 毫秒左右，以看到 LED 闪烁得更快。当我们在 Pico 上运行实际代码时，我们将使用 500 毫秒的延迟。</p>
<div class="wrap">
  
<div class="top">
    
<div style="display:flex;flex-direction:column;align-items:center">
      
<div id="led" class="led" aria-hidden="true"></div>

      
<div class="led-label"><strong id="led-state">LOW</strong></div>

    </div>

    
<div style="flex:1">
      
<div class="code" id="code">
        
<div class="line" data-index="0">
<div class="num">1</div>
<div class="text">let mut led = Output::new(p.PIN_13, Level::Low);</div>
</div>

        
<div class="line" data-index="1">
<div class="num">2</div>
<div class="text">loop {</div>
</div>

        
<div class="line" data-index="2">
<div class="num">3</div>
<div class="text">    led.set_high(); // 打开 LED</div>
</div>

        
<div class="line" data-index="3">
<div class="num">4</div>
<div class="text">    Timer::after_millis(<span class="ms-val">5000</span>).await;</div>
</div>

        
<div class="line" data-index="4">
<div class="num">5</div>
<div class="text">    led.set_low(); // 关闭 LED</div>
</div>

        
<div class="line" data-index="5">
<div class="num">6</div>
<div class="text">    Timer::after_millis(<span class="ms-val">5000</span>).await;</div>
</div>

        
<div class="line" data-index="6">
<div class="num">7</div>
<div class="text">}</div>
</div>

      
<div class="progress-wrap">
        
<div class="progress" aria-hidden="true">
<div id="bar" class="bar"></div>
</div>

        
<div class="progress-info">
<div id="progress-label">空闲</div>
<div id="ms-left">0 ms</div>
</div>

      </div>

      
<div class="controls">
        <label>间隔（毫秒）：<input id="interval" type="number" value="5000" min="50" step="50"></label>
        <button id="restart">重新开始</button>
        <button id="pause">暂停</button>
        <button id="resume" style="display:none">继续</button>
      </div>

    </div>

  </div>

</div>

<script>
document.addEventListener("DOMContentLoaded", () => {

  const lines = Array.from(document.querySelectorAll('.line'));
  const ledEl = document.getElementById('led');
  const ledState = document.getElementById('led-state');
  const bar = document.getElementById('bar');
  const progressLabel = document.getElementById('progress-label');
  const msLeft = document.getElementById('ms-left');
  const intervalInput = document.getElementById('interval');
  const restartBtn = document.getElementById('restart');
  const pauseBtn = document.getElementById('pause');
  const resumeBtn = document.getElementById('resume');
  const msValSpans = Array.from(document.querySelectorAll('.ms-val'));

  let intervalMs = Number(intervalInput.value) || 5000;
  let running = true;
  let paused = false;

  function setLed(on){
    if(on){
      ledEl.classList.add('on');
      ledState.textContent = '高';
    } else {
      ledEl.classList.remove('on');
      ledState.textContent = '低';
    }
  }

  function highlight(index){
    lines.forEach(l => l.classList.toggle('current', Number(l.dataset.index) === index));
  }

  function sleep(ms){
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // update the displayed ms inside code examples
  function updateCodeMs(v){
    msValSpans.forEach(el => el.textContent = v);
  }

  // animate a timer and update progress bar and labels
  function runTimer(ms, onUpdate){
    return new Promise(resolve => {
      let start = performance.now();
      let lastNow = start;
      function step(now){
        if(paused){
          // push the start forward so elapsed stops accumulating during pause
          start += (now - lastNow);
          lastNow = now;
          requestAnimationFrame(step);
          return;
        }
        const elapsed = now - start;
        const p = Math.min(1, elapsed / ms);
        onUpdate(p, Math.max(0, ms - Math.floor(elapsed)));
        if(p >= 1){
          resolve();
        } else {
          lastNow = now;
          requestAnimationFrame(step);
        }
      }
      requestAnimationFrame(step);
    });
  }

  async function mainLoop(){
    while(running){
      intervalMs = Number(intervalInput.value) || 5000;
      updateCodeMs(intervalMs);

      // line: led.set_high();
      highlight(2);
      await sleep(300);           // 暂停以使高亮可见
      setLed(true);
      progressLabel.textContent = 'set_high() 后等待';

      // timer line
      highlight(3);
      bar.style.width = '0%';
      await runTimer(intervalMs, (p, left) => {
        bar.style.width = (p * 100) + '%';
        msLeft.textContent = left + ' ms';
      });

      // line: led.set_low();
      highlight(4);
      await sleep(300);           // 暂停以使高亮可见
      setLed(false);
      progressLabel.textContent = 'set_low() 后等待';

      // timer line
      highlight(5);
      bar.style.width = '0%';
      await runTimer(intervalMs, (p, left) => {
        bar.style.width = (p * 100) + '%';
        msLeft.textContent = left + ' ms';
      });

      // 循环结束 - 右括号短暂显示
      highlight(6);
      progressLabel.textContent = '循环中...';
      await sleep(120);

      bar.style.width = '0%';
      msLeft.textContent = '0 ms';
      progressLabel.textContent = '空闲';

      // respect pause
      while(paused){
        await sleep(100);
      }
    }
  }

  // controls
  restartBtn.addEventListener('click', () => {
    paused = false;
    running = false;
    setTimeout(() => { running = true; mainLoop(); }, 50);
  });
  pauseBtn.addEventListener('click', () => {
    paused = true;
    pauseBtn.style.display = 'none';
    resumeBtn.style.display = 'inline-block';
    progressLabel.textContent = '已暂停';
  });
  resumeBtn.addEventListener('click', () => {
    paused = false;
    resumeBtn.style.display = 'none';
    pauseBtn.style.display = 'inline-block';
    progressLabel.textContent = '继续中...';
  });

  // update interval on input and reflect in code
  intervalInput.addEventListener('input', () => {
    intervalMs = Number(intervalInput.value) || 5000;
    updateCodeMs(intervalMs);
  });

  // initialize
  updateCodeMs(intervalMs);
  highlight(0);
  setLed(false);
  mainLoop();
});
</script>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="面包板"><a class="header" href="#面包板">面包板</a></h1>
<p>面包板（Breadboard）是一种无需焊接即可搭建电路的小型板子。它有许多孔洞，你可以在其中插入导线和电子元件。在板子内部，金属条连接了其中一些孔洞。这使得连接元件和完成电路变得非常简单。</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="core-concepts/images/Breadboard.png" alt="Breadboard" style="max-width:70%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">图片来源：<a href="https://commons.wikimedia.org/wiki/File:Breadboard.png">Wikimedia Commons</a>，许可证：CC BY-SA 3.0</div>

</div>

<p>这张图片展示了面包板内部的孔洞是如何连接的。</p>
<h2 id="电源轨"><a class="header" href="#电源轨">电源轨</a></h2>
<p>两侧的长垂直线称为电源轨（Power rails）。人们通常将电源连接到标有“+“的轨道，将地线连接到标有”-“的轨道。轨道中的每个孔从上到下都是连接在一起的。</p>
<p>假设你想给多个元件供电。你只需要将电源（例如 3.3V 或 5V）连接到“+“轨道上的一个点。之后，你可以使用同一轨道上的任何其他孔来为你的元件供电。</p>
<h2 id="中间区域"><a class="header" href="#中间区域">中间区域</a></h2>
<p>面包板的中间部分是你放置大部分元件的地方。这里的孔洞以小型水平行的方式连接。每一行有五个孔，它们在板子内部连接在一起。</p>
<p>如图所示，每一行都是独立的，标记为 <code>a b c d e</code> 的组与标记为 <code>f g h i j</code> 的组是分开的。中间的间隙将这两侧分隔开，因此连接不会从一侧跨越到另一侧。</p>
<p>以下是一些简单的例子：</p>
<ul>
<li>如果你将一根导线插入 5a，另一根导线插入 5c，它们是连接的，因为它们在同一行。</li>
<li>如果你将一根导线插入 5a，另一根导线插入 5f，它们是<strong>不</strong>连接的，因为它们在间隙的不同侧。</li>
<li>如果你将一根导线插入 5a，另一根导线插入 6a，它们是<strong>不</strong>连接的，因为它们在不同的行。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用嵌入式-rust-在-raspberry-pi-pico-上闪烁外部-led"><a class="header" href="#使用嵌入式-rust-在-raspberry-pi-pico-上闪烁外部-led">使用嵌入式 Rust 在 Raspberry Pi Pico 上闪烁外部 LED</a></h1>
<p>让我们从创建项目开始。我们将使用 cargo-generate 并使用我们为本书准备的模板。</p>
<p>在你的终端中，输入：</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.3.1
</code></pre>
<p>你会被问到几个问题：</p>
<ol>
<li>
<p>对于项目名称，你可以随意命名。我们将使用 external-led。</p>
</li>
<li>
<p>接下来，它会要求我们选择硬件抽象层（HAL）。我们应该选择 “Embassy”。</p>
</li>
<li>
<p>然后，它会询问我们是否要启用 defmt 日志记录。这仅在我们使用调试探针时有效，因此你可以根据你的设置进行选择。无论如何，在本次练习中我们不会编写任何日志。</p>
</li>
</ol>
<h2 id="导入"><a class="header" href="#导入">导入</a></h2>
<p>项目模板中已经包含了大部分所需的导入。对于本次练习，我们只需要从 gpio 中添加 <code>Output</code> 结构体和 <code>Level</code> 枚举：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use embassy_rp::gpio::{Level, Output};
<span class="boring">}</span></code></pre>
<p>在编写主代码时，你的编辑器通常会建议缺失的导入。如果没有建议或者你看到了错误，请检查完整代码部分并从那里添加缺失的导入。</p>
<h2 id="主要逻辑"><a class="header" href="#主要逻辑">主要逻辑</a></h2>
<p>代码与快速开始示例几乎相同。唯一的区别是我们现在使用 GPIO 13 而不是 GPIO 25。GPIO 13 是我们连接 LED（通过电阻）的地方。</p>
<p>让我们将这些代码添加到主函数中：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut led = Output::new(p.PIN_13, Level::Low);

loop {
    led.set_high(); // 打开 LED
    Timer::after_millis(500).await;

    led.set_low(); // 关闭 LED
    Timer::after_millis(500).await;
}
<span class="boring">}</span></code></pre>
<p>我们在这里使用 Output 结构体，因为我们想从 Pico 向 LED 发送信号。我们将 GPIO 13 设置为输出引脚，并使其初始状态为低电平（关闭）。</p>
<blockquote>
<p>注意：如果你想从组件（如按钮或传感器）读取信号，则需要将 GPIO 引脚配置为输入（Input）。</p>
</blockquote>
<p>然后我们在引脚上调用 set_high 和 set_low，并在它们之间设置延迟。这会在高电平和低电平之间切换引脚，从而打开和关闭 LED。</p>
<h2 id="完整代码"><a class="header" href="#完整代码">完整代码</a></h2>
<p>这里是完整的代码供参考：</p>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use embassy_executor::Spawner;
use embassy_rp as hal;
use embassy_rp::block::ImageDef;
use embassy_rp::gpio::{Level, Output};
use embassy_time::Timer;

// Panic处理程序（Panic Handler）
use panic_probe as _;
// Defmt 日志记录
use defmt_rtt as _;

/// 告知引导 ROM（Boot ROM）关于我们的应用程序
#[unsafe(link_section = ".start_block")]
#[used]
pub static IMAGE_DEF: ImageDef = hal::block::ImageDef::secure_exe();

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let p = embassy_rp::init(Default::default());

    let mut led = Output::new(p.PIN_13, Level::Low);

    loop {
        led.set_high(); // 打开 LED
        Timer::after_millis(500).await;

        led.set_low(); // 关闭 LED
        Timer::after_millis(500).await;
    }
}

// 用于 `picotool info` 的程序元数据。
// 这不是必需的，但建议保留这些最基本的条目。
#[unsafe(link_section = ".bi_entries")]
#[used]
pub static PICOTOOL_ENTRIES: [embassy_rp::binary_info::EntryAddr; 4] = [
    embassy_rp::binary_info::rp_program_name!(c"external-led"),
    embassy_rp::binary_info::rp_program_description!(c"your program description"),
    embassy_rp::binary_info::rp_cargo_version!(),
    embassy_rp::binary_info::rp_program_build_attribute!(),
];

// 文件结束</code></pre>
<h2 id="克隆现有项目"><a class="header" href="#克隆现有项目">克隆现有项目</a></h2>
<p>你可以克隆我创建的项目并导航到 <code>external-led</code> 文件夹：</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-embassy-projects
cd pico2-embassy-projects/external-led
</code></pre>
<h2 id="如何运行-1"><a class="header" href="#如何运行-1">如何运行？</a></h2>
<p>你可以参考 <a href="#运行程序">“运行程序”</a> 章节</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用-rp-hal-的闪烁示例"><a class="header" href="#使用-rp-hal-的闪烁示例">使用 rp-hal 的闪烁示例</a></h1>
<p>在上一节中，我们使用了 Embassy。我们保持相同的电路和接线。对于这个示例，我们切换到 rp-hal 以展示这两种方法的样子。如果你想要异步支持，可以选择 Embassy；如果你更喜欢阻塞风格，可以选择 rp-hal。在本书中，我们将主要使用 Embassy。</p>
<p>我们将再次使用 cargo-generate 和相同的模板创建一个新项目。</p>
<p>在你的终端中，输入：</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.3.1
</code></pre>
<p>当它要求你选择硬件抽象层（HAL）时，这次选择 “rp-hal”。</p>
<h2 id="导入-1"><a class="header" href="#导入-1">导入</a></h2>
<p>模板已经包含了大部分导入。对于这个示例，我们需要从 embedded-hal 中添加 OutputPin 特性（trait）：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 用于输出引脚的嵌入式 HAL 特性
use embedded_hal::digital::OutputPin;
<span class="boring">}</span></code></pre>
<p>这个特性提供了我们将用来控制 LED 灯（LED）的 set_high() 和 set_low() 方法。</p>
<h2 id="主要逻辑-1"><a class="header" href="#主要逻辑-1">主要逻辑</a></h2>
<p>如果你将此与 Embassy 版本进行比较，LED 切换的方式没有太大区别。主要区别在于延迟的工作方式。Embassy 使用 async 和 await，这允许程序在不阻塞的情况下暂停，并允许其他任务在后台运行。rp-hal 使用阻塞延迟，这会停止程序直到时间过去。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut led_pin = pins.gpio13.into_push_pull_output();

loop {
    led_pin.set_high().unwrap();
    timer.delay_ms(200);

    led_pin.set_low().unwrap();
    timer.delay_ms(200);
}
<span class="boring">}</span></code></pre>
<h2 id="完整代码-1"><a class="header" href="#完整代码-1">完整代码</a></h2>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use embedded_hal::delay::DelayNs;
use hal::block::ImageDef;
use rp235x_hal as hal;

// 恐慌处理程序（Panic Handler）
use panic_probe as _;
// Defmt 日志记录
use defmt_rtt as _;

// 用于输出引脚的嵌入式 HAL 特性
use embedded_hal::digital::OutputPin;

/// 告知引导 ROM（Boot ROM）关于我们的应用程序
#[unsafe(link_section = ".start_block")]
#[used]
pub static IMAGE_DEF: ImageDef = hal::block::ImageDef::secure_exe();
/// Raspberry Pi Pico 2 开发板上的外部高速晶振为 12 MHz。
/// 如果你的开发板频率不同，请进行调整
const XTAL_FREQ_HZ: u32 = 12_000_000u32;

#[hal::entry]
fn main() -&gt; ! {
    // 获取我们的单例对象
    let mut pac = hal::pac::Peripherals::take().unwrap();

    // 设置看门狗（watchdog）驱动程序 - 时钟设置代码需要它
    let mut watchdog = hal::Watchdog::new(pac.WATCHDOG);

    // 配置时钟
    //
    // 默认是生成 125 MHz 的系统时钟
    let clocks = hal::clocks::init_clocks_and_plls(
        XTAL_FREQ_HZ,
        pac.XOSC,
        pac.CLOCKS,
        pac.PLL_SYS,
        pac.PLL_USB,
        &amp;mut pac.RESETS,
        &amp;mut watchdog,
    )
    .ok()
    .unwrap();

    // 单周期 I/O 块控制我们的通用输入输出（GPIO）引脚
    let sio = hal::Sio::new(pac.SIO);

    // 根据它们在此特定开发板上的功能设置引脚
    let pins = hal::gpio::Pins::new(
        pac.IO_BANK0,
        pac.PADS_BANK0,
        sio.gpio_bank0,
        &amp;mut pac.RESETS,
    );

    let mut timer = hal::Timer::new_timer0(pac.TIMER0, &amp;mut pac.RESETS, &amp;clocks);

    let mut led_pin = pins.gpio13.into_push_pull_output();

    loop {
        led_pin.set_high().unwrap();
        timer.delay_ms(200);

        led_pin.set_low().unwrap();
        timer.delay_ms(200);
    }
}

// 用于 `picotool info` 的程序元数据。
// 这不是必需的，但建议保留这些最基本的条目。
#[unsafe(link_section = ".bi_entries")]
#[used]
pub static PICOTOOL_ENTRIES: [hal::binary_info::EntryAddr; 5] = [
    hal::binary_info::rp_cargo_bin_name!(),
    hal::binary_info::rp_cargo_version!(),
    hal::binary_info::rp_program_description!(c"your program description"),
    hal::binary_info::rp_cargo_homepage_url!(),
    hal::binary_info::rp_program_build_attribute!(),
];</code></pre>
<h2 id="克隆现有项目-1"><a class="header" href="#克隆现有项目-1">克隆现有项目</a></h2>
<p>你可以克隆我创建的项目并导航到 <code>external-led</code> 文件夹：</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-rp-projects/external-led
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="从-std-到-no_std"><a class="header" href="#从-std-到-no_std">从 std 到 no_std</a></h1>
<p>我们已经成功烧录并运行了第一个程序，它产生了一个闪烁效果。然而，我们还没有详细探索代码或项目结构。在本节中，我们将从头开始重新创建同一个项目。我将沿途解释代码和配置的每一部分。你准备好接受挑战了吗？</p>
<blockquote>
<p>注意：如果你觉得这一章内容太多，特别是如果你只是在做一个业余项目，请随意跳过它。你可以在构建一些有趣的项目并完成练习后再回来阅读。</p>
</blockquote>
<h2 id="创建一个新项目"><a class="header" href="#创建一个新项目">创建一个新项目</a></h2>
<p>我们将从创建一个标准的 Rust 二进制项目开始。使用以下命令：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo new pico-from-scratch
<span class="boring">}</span></code></pre>
<p>在这个阶段，项目将包含预期的常规文件。</p>
<pre><code class="language-sh">├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>我们的目标是达到以下最终项目结构：</p>
<pre><code class="language-sh">├── build.rs
├── .cargo
│   └── config.toml
├── Cargo.toml
├── memory.x
├── rp235x_riscv.x
├── src
│   └── main.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="交叉编译"><a class="header" href="#交叉编译">交叉编译</a></h1>
<p>你可能已经了解交叉编译了。在本节中，我们将探讨它是如何工作的，以及处理像目标三元组（target triples）这样的东西意味着什么。简单来说，交叉编译就是为你正在使用的机器以外的机器构建程序。</p>
<p>你可以在一台计算机上编写代码，并制作在完全不同的计算机上运行的程序。例如，你可以在 Linux 上工作并为 Windows 构建 .exe 文件。你甚至可以针对像 RP2350、ESP32 或 STM32 这样的裸机微控制器（MCU）。</p>
<div class="translator-note">
如果你不了解（看到这的应该不存在这个问题吧）就继续往下看：
<p><strong>当我们开发目标是一个嵌入式设备时，便需要在PC机上编译出能在该嵌入式设备上运行的可执行文件，这里编译主机与目标运行主机不是同一个设备，那么该过程就称为交叉编译；</strong></p>
<p>如C/C++文件要经过预处理（preprocessing)、编译(compilation)、汇编（assembly)和链接(linking）等4步才能变成可执行文件</p>
<h2 id="编译编译"><a class="header" href="#编译编译">编译=?编译</a></h2>
<p>这里的“交叉编译”里的“编译”，通常是广义的 build：从源代码到目标平台可执行物/固件的整条流水线</p>
<ul>
<li>狭义“编译”（compilation）：把预处理后的 C/C++ 变成汇编（.s）或中间表示。</li>
<li>广义“编译/构建”（compile/build）：把源代码一路变成目标产物（.elf/.exe/.uf2），包含链
接。
在日常交流中通常使用“编译”来统称，所以要结合语境。</li>
</ul>
<h2 id="核心概念"><a class="header" href="#核心概念">核心概念</a></h2>
<p>“交叉编译”不是某个单独步骤，而是：在 host 上运行的一套工具链（compiler/assembler/
linker 等），产出给 target 运行的二进制。从编译原理角度看:</p>
<ul>
<li>前端（词法/语法/语义→IR）大体与平台无关；</li>
<li>后端（指令选择、寄存器分配、调用约定、目标文件格式、链接与运行时）强烈依赖 target</li>
</ul>
<p>交叉编译的“交叉”，主要发生在后端与链接/运行时这部分。</p>
<p>更多的Target Triple可以参考：
<a href="https://blog.aruoshui.fun/posts/53545.html">Target Triple不仅仅是字符串</a></p>
</div>

<blockquote>
<p><strong>简而言之（TL;DR）</strong></p>
<p>在为 Pico 2 构建二进制文件时，我们必须使用 “thumbv8m.main-none-eabihf” 或 “riscv32imac-unknown-none-elf” 作为target。</p>
<p><code>cargo build --target thumbv8m.main-none-eabihf</code></p>
<p>我们也可以在 <code>.cargo/config.toml</code> 中配置target，这样就不需要每次都输入它了。</p>
</blockquote>
<img style="display: block; margin: auto;" alt="交叉编译" src="std-to-no-std/images/cross-compilation.jpg" />
<h2 id="为你的主机系统构建"><a class="header" href="#为你的主机系统构建">为你的主机系统构建</a></h2>
<p>假设我们在 Linux 机器上。当你运行通常的构建命令时，Rust 会为你的当前主机平台编译代码，在这种情况下是 Linux：</p>
<pre><code class="language-sh">cargo build
</code></pre>
<p>你可以使用 file 命令确认它刚刚生成了什么样的二进制文件：</p>
<pre><code class="language-sh">file ./target/debug/pico-from-scratch
</code></pre>
<p>这将给出如下输出。这告诉你它是一个 64 位 ELF 二进制文件，动态链接，并且是为 Linux 构建的。</p>
<pre><code class="language-sh">./target/debug/pico-from-scratch: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, Build...
</code></pre>
<h2 id="为-windows-交叉编译"><a class="header" href="#为-windows-交叉编译">为 Windows 交叉编译</a></h2>
<p>现在假设你想在不离开 Linux 机器的情况下为 Windows 构建二进制文件。这就是交叉编译发挥作用的地方。</p>
<p>首先，你需要告诉 Rust 目标平台。你只需要做一次：</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-gnu
</code></pre>
<p>这添加了对使用 GNU 工具链（MinGW）生成 64 位 Windows 二进制文件的支持。</p>
<p>现在再次构建你的项目，这次指定目标：</p>
<pre><code class="language-sh">cargo build --target x86_64-pc-windows-gnu
</code></pre>
<p>就是这样。Rust 现在将创建一个 Windows .exe 二进制文件，即使你仍然在 Linux 上。输出的二进制文件将位于 <code>target/x86_64-pc-windows-gnu/debug/pico-from-scratch.exe</code></p>
<p>你可以像这样检查文件类型：</p>
<pre><code class="language-sh">file target/x86_64-pc-windows-gnu/debug/pico-from-scratch.exe
</code></pre>
<p>它会给你这样的输出，一个用于 Windows 的 64 位 PE32+ 文件格式文件。</p>
<pre><code class="language-shbutt">target/x86_64-pc-windows-gnu/debug/pico-from-scratch.exe: PE32+ executable (console) x86-64, for MS Windows
</code></pre>
<h2 id="什么是目标三元组"><a class="header" href="#什么是目标三元组">什么是目标三元组？</a></h2>
<p>那么 <code>x86_64-pc-windows-gnu</code> 这个字符串到底是什么？</p>
<p>这就是我们所说的目标三元组（target triple），它准确地告诉编译器你想要什么样的输出。它通常遵循这种格式：</p>
<pre><code class="language-html">`&lt;architecture&gt;-&lt;vendor&gt;-&lt;os&gt;-&lt;abi&gt;`
</code></pre>
<p>但这种模式并不总是一致的。有时 ABI 部分不会出现。在其他情况下，甚至供应商（vendor）或者供应商和 ABI 都可能缺失。结构可能会变得混乱，并且有很多例外。如果你想深入了解所有的怪癖和边缘情况，请查看参考资料中链接的文章 “What the Hell Is a Target Triple?”。</p>
<p>让我们分解一下这个目标三元组的实际含义：</p>
<ul>
<li>
<p><strong>架构（Architecture）(x86_64)</strong>：这只是意味着 64 位 x86，这是大多数现代 PC 使用的 CPU 类型。它也被称为 AMD64 或 x64。</p>
</li>
<li>
<p><strong>供应商（Vendor）(pc)</strong>：这基本上是一个占位符。在大多数情况下它不是很重要。如果是针对 mac os，供应商名称将是 “apple”。</p>
</li>
<li>
<p><strong>操作系统（OS）(windows)</strong>：这告诉 Rust 我们想要构建在 Windows 上运行的东西。</p>
</li>
<li>
<p><strong>二进制接口（ABI）(gnu)</strong>：这部分告诉 Rust 使用 GNU 工具链来构建二进制文件。</p>
</li>
</ul>
<h2 id="参考资料-1"><a class="header" href="#参考资料-1">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/beta/rustc/platform-support.html">平台支持</a></li>
<li><a href="https://rust-lang.github.io/rustup/cross-compilation.html">交叉编译</a></li>
<li><a href="https://mcyoung.xyz/2025/04/14/target-triples/">目标三元组到底是什么鬼？</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="为微控制器编译"><a class="header" href="#为微控制器编译">为微控制器编译</a></h1>
<p>现在让我们谈谈嵌入式系统。当涉及到为微控制器编译 Rust 代码时，情况与普通桌面系统略有不同。微控制器通常不运行像 Linux 或 Windows 这样的完整操作系统。相反，它们在一个最小的环境中运行，通常根本没有操作系统。这被称为裸机（bare-metal）环境。</p>
<p>Rust 通过其 <strong>no_std</strong> 模式支持这种设置。在普通的 Rust 程序中，标准库（<code>std</code>）处理文件系统、线程、堆分配和 I/O 等事务。但在裸机微控制器上，这些都不存在。因此，我们不使用 std，而是使用一个小得多的 <code>core</code> 库，它只提供基本的构建块。</p>
<h2 id="pico-2-的目标三元组"><a class="header" href="#pico-2-的目标三元组">Pico 2 的目标三元组</a></h2>
<p>Raspberry Pi Pico 2（RP2350 芯片），正如你已经知道的那样，它是独特的；它包含可选择的 ARM Cortex-M33 和 Hazard3 RISC-V 核心。你可以选择使用哪种处理器架构。</p>
<h3 id="arm-cortex-m33-目标"><a class="header" href="#arm-cortex-m33-目标">ARM Cortex-M33 目标</a></h3>
<p>对于 ARM 模式，我们必须使用目标 <code>[thumbv8m.main-none-eabi](https://doc.rust-lang.org/nightly/rustc/platform-support/thumbv8m.main-none-eabi.html)</code>：</p>
<p>让我们分解一下：</p>
<ul>
<li><strong>架构（Architecture）(thumbv8m.main)</strong>：Cortex-M33 使用用于 ARMv8-M 架构的 ARM Thumb-2 指令集。</li>
<li><strong>供应商（Vendor）(none)</strong>：没有特定的供应商指定。</li>
<li><strong>操作系统（OS）(none)</strong>：没有操作系统 - 它是裸机的。</li>
<li><strong>二进制接口（ABI）(eabi)</strong>：嵌入式应用二进制接口（Embedded Application Binary Interface），嵌入式 ARM 系统的标准调用约定。</li>
</ul>
<p>要安装并使用此目标：</p>
<pre><code class="language-bash">rustup target add thumbv8m.main-none-eabi
cargo build --target thumbv8m.main-none-eabi
</code></pre>
<h3 id="risc-v-hazard3-目标"><a class="header" href="#risc-v-hazard3-目标">RISC-V Hazard3 目标</a></h3>
<p>对于 RISC-V 模式，使用目标:
<a href="https://doc.rust-lang.org/nightly/rustc/platform-support/riscv32-unknown-none-elf.html">riscv32imac-unknown-none-elf</a></p>
<p>让我们分解一下：</p>
<ul>
<li><strong>架构（Architecture）(riscv32imac)</strong>：具有 I（整数）、M（乘法/除法）、A（原子）和 C（压缩）指令集的 32 位 RISC-V。</li>
<li><strong>供应商（Vendor）(unknown)</strong>：没有特定的供应商。</li>
<li><strong>操作系统（OS）(none)</strong>：没有操作系统 - 它是裸机的。</li>
<li><strong>格式（Format）(elf)</strong>：ELF（可执行和可链接格式），嵌入式系统中常用的对象文件格式。</li>
</ul>
<p>要安装并使用此目标：</p>
<pre><code class="language-bash">rustup target add riscv32imac-unknown-none-elf
cargo build --target riscv32imac-unknown-none-elf
</code></pre>
<p>在我们的练习中，我们将主要使用 ARM 模式。像 <code>panic-probe</code> 这样的一些 crate 在 RISC-V 模式下无法工作。</p>
<h2 id="cargo-配置"><a class="header" href="#cargo-配置">Cargo 配置</a></h2>
<p>在快速开始中，你可能已经注意到我们在运行 cargo 命令时从未手动传递 –target 标志。那么它是如何知道要为哪个目标构建的呢？这是因为目标已经在 .cargo/config.toml 文件中配置好了。</p>
<p>这个文件允许你存储与 cargo 相关的设置，包括默认使用哪个目标。要为 ARM 模式下的 Pico 2 设置它，请在你的项目根目录中创建一个 .cargo 文件夹，并添加一个包含以下内容的 config.toml 文件：</p>
<pre><code class="language-toml">[build]
target = "thumbv8m.main-none-eabihf"
</code></pre>
<p>现在你不必每次都传递 –target。Cargo 将自动使用此设置。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="no_std"><a class="header" href="#no_std">no_std</a></h1>
<p>Rust 有两个主要的 crate：<code>std</code> 和 <code>core</code>。</p>
<ul>
<li>
<p><code>std</code> crate 是标准库。它为你提供了诸如堆分配、文件系统访问、线程和 <code>println!</code> 等功能。</p>
</li>
<li>
<p><code>core</code> crate 是一个最小子集。它仅包含最基本的 Rust 功能，例如基本类型（<code>Option</code>、<code>Result</code> 等）、trait 以及少数其他操作。它不依赖于操作系统或运行时。</p>
</li>
</ul>
<p>当你尝试在这个阶段构建项目时，你会得到一堆错误。如下所示：</p>
<pre><code class="language-sh">error[E0463]: can't find crate for `std`
  |
  = note: the `thumbv8m.main-none-eabihf` target may not support the standard library
  = note: `std` is required by `pico_from_scratch` because it does not declare `#![no_std]`

error: cannot find macro `println` in this scope
 --&gt; src/main.rs:2:5
  |
2 |     println!("Hello, world!");
  |     ^^^^^^^

error: `#[panic_handler]` function required, but not found

For more information about this error, try `rustc --explain E0463`.
error: could not compile `pico-from-scratch` (bin "pico-from-scratch") due to 3 previous errors
</code></pre>
<p>这里有很多错误。让我们逐一修复。第一个错误说目标平台可能不支持标准库。这是真的。我们已经知道了。问题在于，我们没有告诉 Rust 我们不想使用 <code>std</code>。这就是 <code>no_std</code> 属性发挥作用的地方。</p>
<h2 id="no_std-1"><a class="header" href="#no_std-1">#![no_std]</a></h2>
<p><code>#![no_std]</code> 属性禁用了标准库（<code>std</code>）的使用。这对于嵌入式系统开发通常是必要的，因为这种环境通常缺乏标准库所假设可用的许多资源（如操作系统、文件系统或堆分配）。</p>
<p>在你的 <code>src/main.rs</code> 文件顶部，添加这行代码：</p>
<pre><code class="language-rs">#![no_std]
</code></pre>
<p>就是这样。现在 Rust 知道这个项目将只会使用 <code>core</code> 库，而不是 <code>std</code>。</p>
<h2 id="println"><a class="header" href="#println">Println</a></h2>
<p><code>println!</code> 宏来自 <a href="https://doc.rust-lang.org/std/macro.println.html">std crate</a>。由于我们在项目中不使用 <code>std</code>，我们也不能使用 <code>println!</code>。让我们继续并将其从代码中移除。</p>
<p>现在代码应该像这样：</p>
<pre class="playground"><code class="language-rust">#![no_std]


fn main() {
    
}</code></pre>
<p>通过这个修复，我们已经处理了两个错误并减少了错误列表。还有一个问题依然存在，我们将在下一节中修复它。</p>
<p><strong>参考资源：</strong></p>
<ul>
<li><a href="https://doc.rust-lang.org/reference/names/preludes.html#the-no_std-attribute">Rust 官方文档</a></li>
<li><a href="https://docs.rust-embedded.org/book/intro/no-std.html">嵌入式 Rust 书籍</a></li>
<li><a href="https://os.phil-opp.com/freestanding-rust-binary/#the-no-std-attribute">使用 Rust 编写操作系统</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic-处理器"><a class="header" href="#panic-处理器">Panic 处理器</a></h1>
<p>此时，当你尝试构建项目时，你会得到这个错误：</p>
<pre><code class="language-sh">error: `#[panic_handler]` function required, but not found
</code></pre>
<p>当 Rust 程序发生 panic（恐慌）时，通常由标准库提供的内置 panic 处理器来处理。但在上一步中，我们添加了 <code>#![no_std]</code>，这告诉 Rust 不要使用标准库。所以现在，默认情况下没有可用的 panic 处理器。</p>
<p>在 <code>no_std</code> 环境中，你需要定义自己的 panic 行为，因为当出错时没有操作系统或运行时来接管。</p>
<p>我们可以通过添加自己的 panic 处理器来修复这个问题。只需创建一个带有 <code>#[panic_handler]</code> 属性的函数。该函数必须接受一个 <code>PanicInfo</code> 的引用，并且其返回类型必须是 <code>!</code>，这意味着该函数永不返回。</p>
<p>将此添加到你的 <code>src/main.rs</code>：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[panic_handler]
fn panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}
<span class="boring">}</span></code></pre>
<h2 id="panic-crates"><a class="header" href="#panic-crates">Panic Crates</a></h2>
<p>有一些现成的 crate 为 <code>no_std</code> 项目提供了 panic 处理器函数。一个简单且常用的 crate 是 “panic_halt”，它在发生 panic 时只是停止执行。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panic_halt as _;
<span class="boring">}</span></code></pre>
<p>这行代码从该 crate 中引入了 panic 处理器。现在，如果发生 panic，程序就会停止并停留在无限循环中。</p>
<p>实际上，<a href="https://github.com/korken89/panic-halt/blob/master/src/lib.rs">panic_halt crate 的代码</a>实现了一个简单的 panic 处理器，如下所示：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::panic::PanicInfo;
use core::sync::atomic::{self, Ordering};

#[inline(never)]
#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {
        atomic::compiler_fence(Ordering::SeqCst);
    }
}
<span class="boring">}</span></code></pre>
<p>你可以使用像这样的外部 crate，也可以手动编写你自己的 panic 处理器函数。这取决于你。</p>
<div class="translator-note">
<h3 id="译者注panic-probe-的深度机制"><a class="header" href="#译者注panic-probe-的深度机制">译者注：panic-probe 的深度机制</a></h3>
<p>对于使用 <strong>Embassy</strong> 或 <strong>probe-rs</strong> 工具链的开发者，推荐使用 <code>panic-probe</code> 替代 <code>panic-halt</code>。
<code>panic-probe</code>的源码在：https://github.com/knurling-rs/defmt/blob/main/firmware/panic-probe/src/lib.rs</p>
<h4 id="差异"><a class="header" href="#差异">差异</a></h4>
<p><strong>panic-halt</strong> 通过无限循环停止程序：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop { atomic::compiler_fence(Ordering::SeqCst); }
<span class="boring">}</span></code></pre>
<p><strong>panic-probe</strong> 通过硬件陷阱触发调试器：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cortex_m::asm::udf();  // 执行未定义指令
<span class="boring">}</span></code></pre>
<h4 id="panic-probe的原理"><a class="header" href="#panic-probe的原理">panic-probe的原理</a></h4>
<p><code>panic-probe</code> 的执行流程：</p>
<ol>
<li><strong>禁用中断</strong>：<code>cortex_m::interrupt::disable()</code> 确保 panic 处理的原子性</li>
<li><strong>递归防护</strong>：使用 <code>AtomicBool</code> 避免嵌套 panic 时的无限递归</li>
<li><strong>可选日志输出</strong>：
<ul>
<li><code>print-defmt</code> feature：通过 defmt 输出格式化消息</li>
<li><code>print-rtt</code> feature：通过 RTT 实时传输错误信息</li>
</ul>
</li>
<li><strong>禁用 UsageFault</strong>：清除 SHCSR 寄存器的第 18 位（仅 ARMv7-M 及以上）</li>
<li><strong>触发 UDF 指令</strong>：执行 <code>0xDEFF</code>（UDF #255）指令</li>
</ol>
<h4 id="udf-指令的魔法"><a class="header" href="#udf-指令的魔法">UDF 指令的魔法</a></h4>
<pre><code class="language-assembly">udf #255  ; 未定义指令
</code></pre>
<p>当 CPU 执行 UDF 后：</p>
<ul>
<li>触发 <strong>HardFault</strong> 异常（最高优先级）</li>
<li>自动保存寄存器上下文到栈：<code>R0-R3, R12, LR, PC, xPSR</code></li>
<li><code>probe-rs</code> 识别特定的 UDF 编码，捕获断点</li>
<li>通过 DWARF 调试信息回溯完整调用栈</li>
</ul>
<h4 id="使用方式"><a class="header" href="#使用方式">使用方式</a></h4>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
panic-probe = { version = "1.0", features = ["print-defmt"] }
defmt = "1.0.1"
defmt-rtt = "1.0"
</code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/main.rs
use {defmt_rtt as _, panic_probe as _};
<span class="boring">}</span></code></pre>
<p>当程序 panic 时，<code>probe-rs</code> 会自动输出：</p>
<pre><code>ERROR panicked at src/main.rs:42:17
index out of bounds: the len is 3 but the index is 5

Stack backtrace:
  0: rust_begin_unwind (panic-probe)
  1: core::panicking::panic_fmt
  2: your_app::buggy_function
</code></pre>
</div>

<p><strong>参考资源：</strong></p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/panic-handler.html">Rust 官方文档</a></li>
<li><a href="https://docs.rust-embedded.org/book/start/panicking.html">嵌入式 Rust 书籍</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="no_main"><a class="header" href="#no_main">no_main</a></h1>
<p>当你尝试在这个阶段构建时，你会得到一个错误，说 main 函数需要标准库。那么现在怎么办？程序到底是从哪里开始的？</p>
<p>在嵌入式系统中，我们不使用依赖于标准库的常规 “fn main”。相反，只要告诉 Rust 我们会提供我们自己的入口点。为此，我们使用 <code>no_main</code> 属性。</p>
<p><code>#![no_main]</code> 属性用于指示程序将不使用标准入口点（<code>fn main</code>）。</p>
<p>在你的 <code>src/main.rs</code> 文件顶部，添加这行代码：</p>
<pre><code class="language-rs">#![no_main]
</code></pre>
<h2 id="声明入口点"><a class="header" href="#声明入口点">声明入口点</a></h2>
<p>既然我们已经选择不使用默认入口点，我们需要告诉 Rust 从哪个函数开始。嵌入式 Rust 生态系统中的每个硬件抽象层（HAL）crate 都提供了一个特殊的属性宏（proc macro），允许我们标记入口点。这个宏会初始化并设置微控制器所需的一切。</p>
<p>如果我们使用 <code>rp-hal</code>，我们可以对 RP2350 芯片使用 <code>rp235x_hal::entry</code>。但是，我们将使用 Embassy（<code>embassy-rp</code> crate）。Embassy 提供了 <code>embassy_executor::main</code> 宏，它为任务设置异步运行时并调用我们的 main 函数。</p>
<blockquote>
<p>Embassy Executor 是更为嵌入式使用设计的 async/await 执行器，并支持中断和计时器功能。你可以阅读官方的 <a href="https://embassy.dev/book">Embassy 书籍</a> 来深入了解 Embassy 的工作原理。</p>
</blockquote>
<h3 id="cortex-m-run-time"><a class="header" href="#cortex-m-run-time">Cortex-m Run Time</a></h3>
<p>如果你追踪 <a href="https://github.com/embassy-rs/embassy/blob/2c1c5232e8767887cbad5f28abf9a39ae78dd6c4/embassy-executor-macros/src/lib.rs#L69"><code>embassy_executor::main</code></a> 宏，你会看到它根据架构使用另一个宏。由于 Pico 2 是 Cortex-M 架构，它使用 <code>cortex_m_rt::entry</code>。这来自 <code>cortex_m_rt</code> crate，它为 Cortex-M 微控制器提供启动代码和最小运行时。</p>
<p><a href="std-to-no-std/images/embassy-entry-point.svg"><img style="display: block; margin: auto;" alt="pico2" src="std-to-no-std/images/embassy-entry-point.svg" /></a></p>
<p>如果你在 <code>quick-start</code> 项目中运行 <code>cargo expand</code>，你可以看到宏是如何展开的以及完整的执行流程。如果你深入研究，程序是从 <code>__cortex_m_rt_main_trampoline</code> 函数开始的。这个函数调用 <code>__cortex_m_rt_main</code>，后者设置 Embassy 执行器并运行我们的 main 函数。</p>
<div class="translator-note">
<p>注意使用 <code>cargo expand</code> 请先执行<code>cargo install cargo-expand</code></p>
<p>这个<a href="https://crates.io/crates/cargo-expand">cargo-expand</a>是用来展开 Rust 中的宏定义(<code>macro expansion</code>)和 <code>#[derive</code>] 注解的扩展效果。</p>
</div>

<p>为了使用这个功能，我们需要将 <code>cortex-m</code> 和 <code>cortex-m-rt</code> crate 添加到我们的项目中。更新 <code>Cargo.toml</code> 文件：</p>
<pre><code class="language-toml">cortex-m = { version = "0.7.6" }
cortex-m-rt = "0.7.5"
</code></pre>
<p>现在，我们可以添加 <code>embassy-executor</code> crate：</p>
<pre><code class="language-toml">embassy-executor = { version = "0.9", features = [
  "arch-cortex-m",
  "executor-thread",
] }
</code></pre>
<p>然后，在你的 <code>main.rs</code> 中，像这样设置入口点：</p>
<pre class="playground"><code class="language-rust">use embassy_executor::Spawner;

#[embassy_executor::main]
async fn main(_spawner: Spawner) {}</code></pre>
<p>我们已经更改了函数签名。该函数必须接受一个 <code>Spawner</code> 作为参数以满足 Embassy 的要求，并且该函数现在被标记为 <code>async</code>。</p>
<h2 id="我们到了吗"><a class="header" href="#我们到了吗">我们到了吗？</a></h2>
<p>万岁！现在尝试构建项目 - 它应该能成功编译。</p>
<p>你可以使用 <code>file</code> 命令检查生成的二进制文件：</p>
<pre><code class="language-sh">file target/thumbv8m.main-none-eabihf/debug/pico-from-scratch
</code></pre>
<p>它会显示类似这样的内容：</p>
<pre><code class="language-sh">target/thumbv8m.main-none-eabihf/debug/pico-from-scratch: ELF 32-bit LSB executable, ARM, EABI5 version 1 (GNU/Linux), statically linked, with debug_info, not stripped
</code></pre>
<p>如你所见，该二进制文件是为 32-bit ARM 构建的。这意味着我们 Pico 的基础设置正在工作。</p>
<p>但是我们到了吗？还没完全到。我们已经完成了这一阶段的一半工作 - 我们现在有了一个准备好在 Pico 上运行的有效二进制文件，但在我们可以在真实硬件上运行它之前，还有更多工作要做。</p>
<p><strong>参考资源：</strong></p>
<ul>
<li><a href="https://doc.rust-lang.org/reference/crates-and-source-files.html?highlight=no_main#the-no_main-attribute">Rust 官方文档</a></li>
<li><a href="https://os.phil-opp.com/freestanding-rust-binary/#overwriting-the-entry-point">使用 Rust 编写操作系统</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="适用于-raspberry-pi-pico-的-embassy"><a class="header" href="#适用于-raspberry-pi-pico-的-embassy">适用于 Raspberry Pi Pico 的 Embassy</a></h1>
<p>我们在介绍章节中已经介绍了硬件抽象层（HAL）的概念。对于 Pico，我们将使用 Embassy RP HAL。Embassy RP HAL 旨在支持 Raspberry Pi RP2040 以及 RP235x 微控制器。</p>
<p>该 HAL 支持阻塞和异步外设 API。使用异步 API 更好，因为 HAL 会自动处理在低功耗模式下等待外设完成操作的时间，并管理中断，让你能专注于核心功能。</p>
<p>让我们将 <code>embassy-rp</code> crate 添加到我们的项目中。</p>
<pre><code class="language-toml">embassy-rp = { version = "0.8.0", features = [
  "rp235xa",
] }
</code></pre>
<p>我们启用了 <code>rp235xa</code> 特性，因为我们的芯片是 RP2350。如果我们使用旧款 Pico，则应改为启用 <code>rp2040</code> 特性。</p>
<h2 id="初始化-embassy-rp-hal"><a class="header" href="#初始化-embassy-rp-hal">初始化 embassy-rp HAL</a></h2>
<p>让我们初始化 HAL。如果需要，我们可以将自定义配置传递给初始化函数。目前的配置允许我们修改时钟设置，但现在我们将坚持使用默认值：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let peripherals = embassy_rp::init(Default::default());
<span class="boring">}</span></code></pre>
<p>这会给我们提供所需的外设单例。请记住，我们应该只在启动时调用这一次；再次调用会导致 panic。</p>
<h2 id="计时器"><a class="header" href="#计时器">计时器</a></h2>
<p>我们将通过让板载 LED 闪烁来复刻快速开始示例。为了制作闪烁效果，我们需要一个计时器在 LED 开关之间添加延迟。如果没有延迟，闪烁速度会太快导致肉眼无法察觉。</p>
<p>为了处理计时，我们将使用 “embassy-time” crate，它提供了必要的计时功能：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>embassy-time = { version = "0.5.0" }
<span class="boring">}</span></code></pre>
<p>我们还需要在 <code>embassy-rp</code> crate 中启用 <code>time-driver</code> 特性。这将把 <code>TIMER</code> 外设配置为 <code>embassy-time</code> 的全局时间驱动，以 1MHz 的频率运行：</p>
<pre><code class="language-toml">embassy-rp = { version = "0.8.0", features = [
  "rp235xa",
  "time-driver",
  "critical-section-impl",
] }
</code></pre>
<p>我们几乎已经添加了所有核心 crate。现在让我们编写实现闪烁效果的代码。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="raspberry-pi-pico-2-板载-led-闪烁"><a class="header" href="#raspberry-pi-pico-2-板载-led-闪烁">Raspberry Pi Pico 2 板载 LED 闪烁</a></h1>
<p>当你开始进行嵌入式编程时，通用输入输出（GPIO）是你首先会接触的外设。“通用输入输出”顾名思义：我们可以将其用于输入和输出。作为输出，Pico 可以发送信号来控制 LED 等组件。作为输入，按钮等组件可以向 Pico 发送信号。</p>
<p>在本练习中，我们将通过向板载 LED 发送信号来控制它。如果你查看 <a href="https://datasheets.raspberrypi.com/pico/pico-2-datasheet.pdf#page=9">Pico 2 数据手册</a>的第 8 页，你会看到板载 LED 连接在 GPIO 引脚 25 上。</p>
<p>我们将 GPIO 引脚 25 配置为输出引脚，并将其初始状态设置为低电平（关闭）：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut led = Output::new(peripherals.PIN_25, Level::Low);
<span class="boring">}</span></code></pre>
<p>大多数代码编辑器（如 VS Code）都有快捷键可以自动为你添加导入。如果你的编辑器没有此功能或者你遇到了问题，可以手动添加这些导入：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use embassy_rp::gpio::{Level, Output};
<span class="boring">}</span></code></pre>
<h2 id="闪烁逻辑"><a class="header" href="#闪烁逻辑">闪烁逻辑</a></h2>
<p>现在，我们将创建一个简单的循环让 LED 闪烁。首先，我们通过在 GPIO 实例上调用 <code>set_high()</code> 函数来打开 LED。然后我们使用 <code>Timer</code> 添加一个短暂的延迟。接下来，我们使用 <code>set_low()</code> 关闭 LED。然后我们再添加一个延迟。这就产生了闪烁效果。</p>
<p>让我们将 <code>Timer</code> 导入到我们的项目中：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use embassy_time::Timer;
<span class="boring">}</span></code></pre>
<p>这是闪烁循环代码：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    led.set_high();
    Timer::after_millis(250).await;

    led.set_low();
    Timer::after_millis(250).await;
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="将-rust-固件烧录到-raspberry-pi-pico-2"><a class="header" href="#将-rust-固件烧录到-raspberry-pi-pico-2">将 Rust 固件烧录到 Raspberry Pi Pico 2</a></h1>
<p>在构建我们的程序后，我们将得到一个可以烧录的 ELF 二进制文件。</p>
<p>对于调试构建（<code>cargo build</code>），你可以在这里找到文件：</p>
<pre><code class="language-sh">./target/thumbv8m.main-none-eabihf/debug/pico-from-scratch
</code></pre>
<p>对于发布构建（<code>cargo build --release</code>），你可以在这里找到它：</p>
<pre><code class="language-sh">./target/thumbv8m.main-none-eabihf/release/pico-from-scratch
</code></pre>
<p>要将我们的程序加载到 Pico 上，我们将使用一个名为 <a href="https://github.com/raspberrypi/picotool">Picotool</a> 的工具。这是烧录我们程序的命令：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>picotool load -u -v -x -t elf ./target/thumbv8m.main-none-eabihf/debug/pico-from-scratch
<span class="boring">}</span></code></pre>
<p>以下是每个标志的作用：</p>
<ul>
<li><code>-u</code> 用于更新模式（仅写入更改的内容）</li>
<li><code>-v</code> 用于验证所有内容是否正确写入</li>
<li><code>-x</code> 用于在加载后立即运行程序</li>
<li><code>-t elf</code> 告诉 <code>picotool</code> 我们正在使用 ELF 文件</li>
</ul>
<h2 id="cargo-run-命令"><a class="header" href="#cargo-run-命令">cargo run 命令</a></h2>
<p>每次都输入那个长命令很令人厌烦。让我们通过更新 <code>.cargo/config.toml</code> 文件来简化它。我们可以将 Cargo 配置为在运行 <code>cargo run</code> 时自动使用 <code>picotool</code>：</p>
<pre><code class="language-toml">[target.thumbv8m.main-none-eabihf]
runner = "picotool load -u -v -x -t elf"
</code></pre>
<p>现在，你只需要输入：</p>
<pre><code class="language-sh">cargo run --release

#or

cargo run
</code></pre>
<p>你的程序就会被烧录并在 Pico 上执行。</p>
<p>但在此刻，它实际上还不能烧录。我们遗漏了一个重要的步骤。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="链接脚本"><a class="header" href="#链接脚本">链接脚本</a></h1>
<p>程序现在可以成功编译。然而，当你尝试将其烧录到 Pico 上时，你可能会遇到如下错误：</p>
<pre><code class="language-sh">ERROR: File to load contained an invalid memory range 0x00010000-0x000100aa
</code></pre>
<h2 id="将我们的项目与快速开始项目进行对比"><a class="header" href="#将我们的项目与快速开始项目进行对比">将我们的项目与快速开始项目进行对比</a></h2>
<p>为了理解为什么烧录会失败，让我们使用 <code>arm-none-eabi-readelf</code> 工具检查编译后的程序。这个工具展示了编译器和链接器是如何在内存中组织程序的。</p>
<p>我取出了 <code>quick-start</code> 项目的二进制文件，并将其与我们项目当前生成的二进制文件进行了比较。</p>
<div class="image-with-caption" style="text-align:center; display:inline-block;">
    <img src="std-to-no-std/images/elf-section-headers.png" alt="Quick Start vs our Project" style="max-width:100%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Quick Start 对比我们的项目</div>

</div>

<p>你不需要理解输出中的每一个细节。重要的是要注意到这两个二进制文件看起来非常不同，尽管我们的 Rust 代码几乎是一样的。</p>
<p>最大的区别在于我们的项目缺失了一些重要的段（section），如 <code>.text</code>、<code>.rodata</code>、<code>.data</code> 和 <code>.bss</code>。这些段通常由链接器创建：</p>
<ul>
<li>.text : 实际的程序指令（代码）存放于此</li>
<li>.rodata : 只读数据，例如常量值</li>
<li>.data : 已初始化的全局或静态变量</li>
<li>.bss : 未初始化的全局或静态变量</li>
</ul>
<p>你还可以通过 <a href="https://github.com/rust-embedded/cargo-binutils">cargo-binutils</a> 工具集提供的 <code>cargo size</code> 命令来比较它们。</p>
<div class="image-with-caption" style="text-align:center; display:inline-block;">
    <img src="std-to-no-std/images/cargo-size.png" alt="Cargo size on Quick Start vs our Project" style="max-width:100%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">cargo size：Quick Start 对比我们的项目</div>

</div>

<p><strong>链接器（Linker）：</strong></p>
<p>这通常由所谓的链接器来处理。链接器的作用是将我们程序的所有部分（如编译后的代码、库代码、启动代码和数据）组合成一个设备实际上可以运行的最终可执行文件。它还决定了程序的每个部分应该放置在内存中的什么位置，例如代码放在哪里，全局变量放在哪里。</p>
<p>然而，链接器不会自动知道 RP2350 的内存布局。我们必须告诉它 Flash 和 RAM 是如何排列的。这是通过链接脚本完成的。如果链接脚本缺失或不正确，链接器就不会将我们的代码放置在正确的内存区域中，从而导致我们看到的烧录错误。</p>
<h3 id="链接脚本-1"><a class="header" href="#链接脚本-1">链接脚本</a></h3>
<p>我们不打算自己编写链接脚本。<code>cortex-m-rt</code> crate 已经提供了主链接脚本（<code>link.x</code>），但它只了解 Cortex-M 核心。它对我们使用的具体微控制器一无所知。每个微控制器都有自己的 Flash 大小、RAM 大小和内存布局，<code>cortex-m-rt</code> 无法猜测这些值。</p>
<p>因此，<code>cortex-m-rt</code> 期望用户或板级支持 crate 提供一个名为 <code>memory.x</code> 的小型链接脚本。该文件描述了目标设备的内存布局。</p>
<p>在 <code>memory.x</code> 中，我们必须定义设备拥有的内存区域。至少，我们需要两个区域：一个名为 FLASH，另一个名为 RAM。程序的 <code>.text</code> 和 <code>.rodata</code> 段会被放置在 FLASH 区域。<code>.bss</code> 和 <code>.data</code> 段以及堆（heap）会被放置在 RAM 区域。</p>
<p>对于 RP2350，数据手册（第 2.2 章，Address map）通过指出 Flash 起始地址为 <code>0x10000000</code>，SRAM 起始地址为 <code>0x20000000</code>。所以我们的 <code>memory.x</code> 文件看起来会像这样：</p>
<pre><code>MEMORY {
    FLASH : ORIGIN = 0x10000000, LENGTH = 2048K
    
    RAM : ORIGIN = 0x20000000, LENGTH = 512K
    SRAM4 : ORIGIN = 0x20080000, LENGTH = 4K
    SRAM5 : ORIGIN = 0x20081000, LENGTH = 4K
    ...
    ...
}
...
...
</code></pre>
<p>RP2350 在 <code>memory.x</code> 中还需要一些额外的设置。我们不需要手动编写这些内容。相反，我们将使用 <code>embassy-rp</code> 示例仓库中提供的文件。你可以从<a href="https://github.com/embassy-rs/embassy/blob/a6d392b24c5f010a8b5b2a00326c04b05a4ab0f0/examples/rp235x/memory.x">这里</a>下载它，并将其放置在你的项目根目录下。</p>
<h2 id="链接器的代码生成选项"><a class="header" href="#链接器的代码生成选项">链接器的代码生成选项</a></h2>
<p>仅仅将 <code>memory.x</code> 文件放在项目文件夹中是不够的。我们还需要确保链接器实际上使用了 <code>cortex-m-rt</code> 提供的链接脚本。</p>
<p>为了解决这个问题，我们要告诉 Cargo 将链接脚本（<code>link.x</code>）传递给链接器。我们可以通过多种方式将参数传递给 Rust。我们可以使用 <code>.cargo/config.toml</code> 或构建脚本（<code>build.rs</code>）文件等方法。在快速开始中，我们使用的是 <code>build.rs</code>。所以这里我们将使用 <code>.cargo/config.toml</code> 方式。在该文件中，使用以下内容更新目标（target）部分：</p>
<pre><code class="language-toml">[target.thumbv8m.main-none-eabihf]
runner = "picotool load -u -v -x -t elf" # 我们已经添加了这个
rustflags = ["-C", "link-arg=-Tlink.x"]  # 这是新增的一行 
</code></pre>
<h2 id="运行-pico"><a class="header" href="#运行-pico">运行 Pico</a></h2>
<p>一切设置就绪后，你现在可以将程序烧录到 Pico 上了：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo run --release
<span class="boring">}</span></code></pre>
<p>呼……我们将一个普通的 Rust 项目变成了一个用于 Pico 的 <code>no_std</code> 固件。终于，我们可以看到 LED 闪烁了。</p>
<h2 id="参考资源"><a class="header" href="#参考资源">参考资源</a></h2>
<ul>
<li><a href="https://mcyoung.xyz/2021/06/01/linker-script/">关于链接脚本你从未想知道的一切</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pulse-width-modulation-pwm"><a class="header" href="#pulse-width-modulation-pwm">Pulse Width Modulation (PWM)</a></h1>
<p>In this section, we will explore what is PWM and why we need it.</p>
<h2 id="digital-vs-analog"><a class="header" href="#digital-vs-analog">Digital vs Analog</a></h2>
<p>To understand PWM, we first need to understand what is digital and analog signal.</p>
<h3 id="digital-signals"><a class="header" href="#digital-signals">Digital Signals</a></h3>
<p>A digital signal has only two states: HIGH or LOW. In microcontrollers, HIGH typically means the full voltage (5V or 3.3V), and LOW means 0V. There’s nothing in between. Think of it like a light switch that can only be fully ON or fully OFF.</p>
<img style="display: block; margin: auto;" alt="Digital Signals" src="core-concepts/pwm/images/digial-signal.svg" />
<p>When you use a digital pin on your microcontroller, you can only output these two values. If you write HIGH to a pin, it outputs 3.3V. If you write LOW, it outputs 0V. You cannot tell a digital pin to output 1.5V or 2.7V or any value in between.</p>
<h2 id="analog-signals"><a class="header" href="#analog-signals">Analog Signals</a></h2>
<p>An analog signal can have any voltage value within a range. Instead of just ON or OFF, it varies continuously and smoothly. Think of it like a dimmer switch that can set brightness anywhere from completely off to fully bright, with infinite positions in between.</p>
<img style="display: block; margin: auto;" alt="Analog Signals" src="core-concepts/pwm/images/analog-signal.svg" />
<p>For example, an analog signal could be 0V, 0.5V, 1.5V, 2.8V, 3.1V, or any other value within the allowed range. This smooth variation allows you to have precise control over devices.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Here’s the challenge: most microcontroller pins are digital. They can only output HIGH or LOW. But what if you want to:</p>
<p>Dim an LED to 50% brightness instead of just fully ON or fully OFF (like we did in the quick-start blinking example)? Or Control a servo motor to any position between 0° and 180°? Or Adjust the speed of a fan or control temperature gradually?</p>
<p>You need something that acts like an analog output, but you only have digital pins. This is where PWM comes in.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pulse-width-modulation-pwm-1"><a class="header" href="#pulse-width-modulation-pwm-1">Pulse Width Modulation (PWM)</a></h1>
<style>
  
  .slider-container {
    margin: 20px 0;
  }

  label {
    margin-right: 10px;
  }

  .led-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    position: relative;
  }

  .led-body {
    width: 30px;
    height: 40px;
    background: radial-gradient(circle at center, #ff5555, #cc0000);
    border-radius: 50% 50% 0 0;
    border: 2px solid #990000;
    position: relative;
    box-shadow: 0 0 10px rgba(255, 85, 85, 0.8);
  }

  .led-body::after {
    content: '';
    position: absolute;
    top: 5px;
    left: 7px;
    width: 16px;
    height: 16px;
    background: rgba(255, 255, 255, 0.4);
    border-radius: 50%;
  }

  .led-pin {
    width: 2px;
    height: 40px;
    background-color: #333;
    position: relative;
  }

  .anode {
    height: 50px; /* Longer pin for the anode */
    margin-right: 15px;
    background-color: #666;
  }

  .cathode {
    height: 40px; /* Shorter pin for the cathode */
    margin-left: 15px;
    background-color: #333;
    position: absolute;
    margin-top: 45px;
  }

  canvas {
    border: 1px solid #ccc;
    display: block;
    margin: 10px auto;
  }
  #pwmCanvas {
    background-color: #fefefe;
  } 
</style>
<p>PWM stands for Pulse Width Modulation. It’s a technique that uses a digital signal switching rapidly between HIGH and LOW to simulate an analog output.</p>
<p>Instead of providing a steady voltage like 1.5V as a true analog signal would, PWM quickly toggles between full voltage and 0V. By controlling how long the signal stays HIGH versus LOW, you can control the average power or voltage delivered to the device.</p>
<h3 id="how-pwm-works"><a class="header" href="#how-pwm-works">How PWM Works</a></h3>
<p>PWM works by sending a square wave signal that switches between HIGH and LOW at a fixed frequency. The key parameter is the “duty cycle”, which is the percentage of time the signal is HIGH during one complete cycle.</p>
<img style="display: block; margin: auto;" alt="LED PWM" src="core-concepts/images/led-pwm.jpg" />
<p>For example:</p>
<ul>
<li>A 0% duty cycle means the signal is always LOW (0V average).</li>
<li>A 50% duty cycle means the signal is HIGH and LOW for equal amounts of time (1.65V average on a 3.3 system).</li>
<li>A 75% duty cycle means the signal is HIGH for 75% of the time and LOW for 25% of the time.</li>
<li>A 100% duty cycle means the signal is always HIGH (3.3V).</li>
</ul>
<p>The switching happens extremely fast, typically hundreds or thousands of times per second. This is so fast that devices like LEDs and motors respond to the average voltage rather than seeing individual pulses.</p>
<h2 id="example-usage-dimming-an-led"><a class="header" href="#example-usage-dimming-an-led">Example Usage: Dimming an LED</a></h2>
<p>An LED flashes so quickly that your eyes can’t see individual ON and OFF pulses, so you perceive only the average brightness. A low duty cycle makes it look dim, a higher one makes it look brighter, even though the LED is always switching between full voltage and zero.</p>
<h2 id="example-usage-controlling-a-servo-motor"><a class="header" href="#example-usage-controlling-a-servo-motor">Example Usage: Controlling a Servo Motor</a></h2>
<p>A servo reads the width of a pulse to decide its angle. It expects a pulse every 20 milliseconds, and the pulse width - about 1ms for 0°, 1.5ms for 90°, and 2ms for 180° - tells the servo where to move.</p>
<h2 id="period-and-frequency"><a class="header" href="#period-and-frequency">Period and Frequency</a></h2>
<p>In PWM, period and frequency work together to determine how fast the signal switches between HIGH and LOW states, which directly affects how smooth and effective your control is.</p>
<p>Period is the total time for one on-off cycle to complete.</p>
<img style="display: block; margin: auto;" alt="Period and Frequency" src="core-concepts/pwm/images/pwm-period-frequency.svg" />
<p>The frequency is the number of cycles it completes in one second, measured in Hertz (Hz).  Frequency is the inverse of the period.  So, a higher frequency means a shorter period, resulting in faster switching between HIGH and LOW states.</p>
<p>\[
\text{Frequency (Hz)} = \frac{1}{\text{Period (s)}}
\]</p>
<p>So if the period is 1 second, then the frequency will be 1HZ.</p>
<p>\[
1 \text{Hz} = \frac{1 \text{ cycle}}{1 \text{ second}} = \frac{1}{1 \text{ s}}
\]</p>
<p>For example, if the period is 20ms(0.02s), the frequency will be 50Hz.</p>
<p>\[
\text{Frequency} = \frac{1}{20 \text{ ms}} = \frac{1}{0.02 \text{ s}} = 50 \text{ Hz}
\]</p>
<p><strong>Calculating Cycle count from Frequency per second</strong></p>
<p>The Formula to calculate cycle count:<br>\[
\text{Cycle Count} = \text{Frequency (Hz)} \times \text{Total Time (seconds)}
\]</p>
<p>If a PWM signal has a frequency of 50Hz, it means it completes 50 cycles in one second.</p>
<h2 id="simulation"><a class="header" href="#simulation">Simulation</a></h2>
<p>Here is the interactive simulation. Use the sliders to adjust the duty cycle and frequency, and watch how the pulse width and LED brightness change. The upper part of the square wave represents when the signal is high (on). The lower part represents when the signal is low (off). The width of the high portion changes with the duty cycle.</p>
<p><canvas id="pwmCanvas" width="800" height="200"></canvas></p>
<div class="led-container">
  
<div class="led-body" id="ledBody"></div>

  
<div class="led-pin anode"></div>

  
<div class="led-pin cathode"></div>

</div>

<div class="slider-container">
  <label for="dutyCycle">Duty Cycle (%): </label>
  <input type="range" id="dutyCycle" min="0" max="100" value="50">
  <span id="dutyCycleValue">50</span>%
</div>

<div class="slider-container">
  <label for="frequency">Frequency (Hz): </label>
  <input type="range" id="frequency" min="1" max="50" value="10">
  <!-- <span id="frequencyValue">x</span> Hz -->
</div>

<p>If you change the duty cycle from “low to high” and “high to low” in the simulation, you should notice the LED kind of giving a dimming effect.</p>
<script>
  const pwmCanvas = document.getElementById('pwmCanvas');
  const pwmCtx = pwmCanvas.getContext('2d');
  
  const dutyCycleSlider = document.getElementById('dutyCycle');
  const dutyCycleValue = document.getElementById('dutyCycleValue');
  const frequencySlider = document.getElementById('frequency');
  const frequencyValue = document.getElementById('frequencyValue');
  const ledBody = document.getElementById('ledBody');

  let dutyCycle = 50; // Initial duty cycle in percentage
  let frequency = 10; // Initial frequency in Hz

  function drawPWM() {
    pwmCtx.clearRect(0, 0, pwmCanvas.width, pwmCanvas.height);

    const period = 1000 / frequency; // Period in ms
    const onTime = period * (dutyCycle / 100); // On time in ms
    const offTime = period - onTime; // Off time in ms

    const totalWidth = pwmCanvas.width;
    const cycles = frequency; // Number of cycles to display
    const cycleWidth = totalWidth / cycles;

    pwmCtx.strokeStyle = 'black';
    pwmCtx.lineWidth = 2;
    pwmCtx.beginPath();

    let x = 0;

    if (dutyCycle === 100) {
      pwmCtx.moveTo(0, 50);
      pwmCtx.lineTo(pwmCanvas.width, 50);
    } else if (dutyCycle === 0) {
      pwmCtx.moveTo(0, 150);
      pwmCtx.lineTo(pwmCanvas.width, 150);
    } else {
      for (let i = 0; i < cycles; i++) {
        const highWidth = (onTime / period) * cycleWidth;
        const lowWidth = (offTime / period) * cycleWidth;

        pwmCtx.moveTo(x, 50);
        pwmCtx.lineTo(x + highWidth, 50);
        pwmCtx.lineTo(x + highWidth, 150);
        pwmCtx.lineTo(x + highWidth + lowWidth, 150);
        pwmCtx.lineTo(x + highWidth + lowWidth, 50);

        x += cycleWidth;
      }
    }
    pwmCtx.stroke();
  }

  function updateLED() {
    const brightness = dutyCycle / 100;
    
    ledBody.style.background = `radial-gradient(circle at center, rgba(255, 85, 85, ${brightness}), #cc0000)`;
  }

  function update() {
    dutyCycle = parseInt(dutyCycleSlider.value, 10);
    frequency = parseInt(frequencySlider.value, 10);

    dutyCycleValue.textContent = dutyCycle;
    // frequencyValue.textContent = frequency;

    drawPWM();
    updateLED();
  }

  dutyCycleSlider.addEventListener('input', update);
  frequencySlider.addEventListener('input', update);

  // Initial draw
  drawPWM();
  updateLED();
</script>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pwm-in-depth"><a class="header" href="#pwm-in-depth">PWM in Depth</a></h1>
<style> 
canvas {
    border: 1px solid #000;
    margin-top: 20px;
}
.controls {
    margin: 20px;
}
.control {
    margin: 10px 0;
}
#pwmCanvas {
    background-color: #fefefe;
}
#timerCanvas {
    background-color: #fefefe;
}
#simulation-div{
        background-color: #fefefe;
            text-align: center;

}   
</style>
<h2 id="timer-operation"><a class="header" href="#timer-operation">Timer Operation</a></h2>
<p>The timer plays a key role in PWM generation. It counts from zero to a specified maximum value (stored in a register), then resets and starts the cycle over. This counting process determines the duration of one complete cycle, called the period.</p>
<h2 id="compare-value"><a class="header" href="#compare-value">Compare Value</a></h2>
<p>The timer’s hardware continuously compares its current count with a compare value (stored in a register). When the count is less than the compare value, the PWM signal stays HIGH; when the count exceeds the compare value, the signal goes LOW. By changing this compare value, you directly control the duty cycle.</p>
<h2 id="pwm-resolution"><a class="header" href="#pwm-resolution">PWM Resolution</a></h2>
<p>Resolution refers to how precisely the duty cycle can be controlled. This is determined by the range of values the timer counts through in one complete cycle.</p>
<p>The timer counts from 0 to a maximum value based on the resolution. The higher the resolution, the more finely the duty cycle can be adjusted.</p>
<p>For a system with <strong>n</strong> bits of resolution, the timer counts from 0 to \(2^n - 1\), which gives \(2^n\) possible levels for the duty cycle.</p>
<p>For example:</p>
<ul>
<li>8-bit resolution allows the timer to count from 0 to 255, providing 256 possible duty cycle levels.</li>
<li>10-bit resolution allows the timer to count from 0 to 1023, providing 1024 possible duty cycle levels.</li>
</ul>
<p>Higher resolution gives more precise control over the duty cycle but requires the timer to count through more values within the same period. This creates a trade-off: to maintain the same frequency with higher resolution, you need a faster timer clock, or you must accept a lower frequency.</p>
<h2 id="simulation-1"><a class="header" href="#simulation-1">Simulation</a></h2>
<p>You can modify the PWM resolution bits and duty cycle in this simulation. Adjusting the PWM resolution bits increases the maximum count but remains within the time period (it does not affect the duty cycle). Changing the duty cycle adjusts the on and off states accordingly, but it also stays within the period.</p>
  
<div class="controls">
    
<div class="control">
      <label for="resolution">PWM Resolution (Bits): </label>
      <input type="range" id="resolution" min="4" max="20" value="8">
      <input type="number" id="resolutionNumber" min="4" max="20" value="8">
    </div>

    
<div class="control">
      <label for="dutyCycle">Duty Cycle (%): </label>
      <input type="range" id="dutyCycle-1" min="0" max="100" value="75">
      <input type="number" id="dutyCycleNumber" min="0" max="100" value="75">
    </div>

  </div>

 
<div id="simulation-div">
    <canvas id="timerCanvas" width="800" height="200"></canvas>
    <canvas id="pwmCanvas-1" width="800" height="150"></canvas>
  </div>

<h2 id="relationship-between-duty-cycle-frequency-and-resolution"><a class="header" href="#relationship-between-duty-cycle-frequency-and-resolution">Relationship Between Duty Cycle, Frequency, and Resolution</a></h2>
<p>This diagram shows how duty cycle, frequency, period, pulse width, and resolution work together in PWM generation.  While it may seem a bit complex at first glance, breaking it down helps to clarify these concepts.</p>
<p>In this example, the timer resolution is 4 bits, meaning the timer counts from 0 to 15 (16 possible values). When the timer reaches its maximum value(i.e 15), an overflow interrupt is triggered (indicated by the blue arrow), and the counter resets to 0. The time it takes for the timer to count from 0 to its maximum value is called as “period”.</p>
<img style="display: block; margin: auto;" alt="PWM" src="core-concepts/pwm/images/pwm-duty-cycle-timer.jpg" />
<p>The duty cycle is configured to 50%, meaning the signal remains high for half the period. At each step in the counting process, the timer compares its current count with the duty cycle’s compare value. When the timer count exceeds this compare value (marked by the yellow arrow), the signal transitions from high to low. This triggers the compare interrupt, signaling the state change.</p>
<p>The time during which the signal is high is referred to as the pulse width.</p>
  <script>
    const timerCanvas = document.getElementById('timerCanvas');
    const timerCtx = timerCanvas.getContext('2d');

    const pwmCanvas = document.getElementById('pwmCanvas');
    const pwmCtx = pwmCanvas.getContext('2d');

    const resolutionInput = document.getElementById('resolution');
    const resolutionNumber = document.getElementById('resolutionNumber');
    const dutyCycleInput = document.getElementById('dutyCycle');
    const dutyCycleNumber = document.getElementById('dutyCycleNumber');

    const numCountLabels = 1;

    function drawTimerAndPWM(resolution, dutyCycle) {
      const maxTicks = Math.pow(2, resolution) - 1;
      const highTicks = Math.round(maxTicks * (dutyCycle / 100));
      const periodWidth = pwmCanvas.width / 10;

      timerCtx.clearRect(0, 0, timerCanvas.width, timerCanvas.height);
      pwmCtx.clearRect(0, 0, pwmCanvas.width, pwmCanvas.height);

      timerCtx.beginPath();
      const stepsToDraw = Math.min(800, maxTicks);
      const stepIncrement = Math.ceil(maxTicks / stepsToDraw);
      for (let period = 0; period < 10; period++) {
        const startX = period * periodWidth;
        for (let tick = 0; tick <= maxTicks; tick += stepIncrement) {
          const x1 = startX + (tick / maxTicks) * periodWidth;
          const y1 = timerCanvas.height - (tick / maxTicks) * (timerCanvas.height - 100);
          const y2 = timerCanvas.height - ((tick + stepIncrement) / maxTicks) * (timerCanvas.height - 100);
          timerCtx.lineTo(x1, y1);
          if (tick + stepIncrement <= maxTicks) {
            timerCtx.lineTo(x1, y2);
          }
        }
      }
      timerCtx.strokeStyle = 'blue';
      timerCtx.lineWidth = 2;
      timerCtx.stroke();

      timerCtx.font = '12px Arial';
      timerCtx.fillStyle = 'black';
      let labelValues = [];
      if (numCountLabels == 1) {
        labelValues = [0, maxTicks];
      } else if (numCountLabels == 2) {
        labelValues = [0, Math.round(maxTicks / 2), maxTicks];
      } else {
        labelValues = [0, Math.round(maxTicks / 3), Math.round(2 * maxTicks / 3), maxTicks];
      }

      for (let i = 0; i < labelValues.length; i++) {
        const y = timerCanvas.height - (labelValues[i] / maxTicks) * (timerCanvas.height - 100);
        timerCtx.fillText(Math.round(labelValues[i]), 5, y);
      }

      const dutyCycleY = timerCanvas.height - (highTicks / maxTicks) * (timerCanvas.height - 100);
      timerCtx.beginPath();
      timerCtx.moveTo(0, dutyCycleY);
      timerCtx.lineTo(timerCanvas.width, dutyCycleY);
      timerCtx.strokeStyle = 'red';
      timerCtx.lineWidth = 1;
      timerCtx.stroke();

      const maxValueY = timerCanvas.height - (maxTicks / maxTicks) * (timerCanvas.height - 100);
      timerCtx.beginPath();
      timerCtx.moveTo(0, maxValueY);
      timerCtx.lineTo(timerCanvas.width, maxValueY);
      timerCtx.strokeStyle = 'gray';
      timerCtx.lineWidth = 1;
      timerCtx.setLineDash([5, 5]);
      timerCtx.stroke();
      timerCtx.setLineDash([]);

      pwmCtx.beginPath();
      for (let period = 0; period < 10; period++) {
        const startX = period * periodWidth;
        pwmCtx.moveTo(startX, pwmCanvas.height / 2);
        pwmCtx.lineTo(startX + (dutyCycle / 100) * periodWidth, pwmCanvas.height / 2);
        pwmCtx.lineTo(startX + (dutyCycle / 100) * periodWidth, pwmCanvas.height - 20);
        pwmCtx.lineTo(startX + periodWidth, pwmCanvas.height - 20);
        pwmCtx.lineTo(startX + periodWidth, pwmCanvas.height / 2);
      }
      pwmCtx.strokeStyle = 'green';
      pwmCtx.lineWidth = 2;
      pwmCtx.stroke();

      timerCtx.font = '16px Arial';
      timerCtx.fillStyle = 'black';
      timerCtx.fillText(`Resolution: ${resolution} bits`, 10, 20);
      timerCtx.fillText(`Max Timer Count: ${maxTicks}`, 10, 40);

      pwmCtx.font = '16px Arial';
      pwmCtx.fillStyle = 'black';
      pwmCtx.fillText(`Duty Cycle: ${dutyCycle}%`, 10, 20);
    }

    function updateSimulation() {
      const resolution = parseInt(resolutionInput.value);
      const dutyCycle = parseInt(dutyCycleInput.value);
      drawTimerAndPWM(resolution, dutyCycle);
    }

    resolutionInput.addEventListener('input', () => {
      resolutionNumber.value = resolutionInput.value;
      updateSimulation();
    });

    resolutionNumber.addEventListener('input', () => {
      resolutionInput.value = resolutionNumber.value;
      updateSimulation();
    });

    dutyCycleInput.addEventListener('input', () => {
      dutyCycleNumber.value = dutyCycleInput.value;
      updateSimulation();
    });

    dutyCycleNumber.addEventListener('input', () => {
      dutyCycleInput.value = dutyCycleNumber.value;
      updateSimulation();
    });

    updateSimulation();
  </script>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pwm-peripheral-in-rp2350"><a class="header" href="#pwm-peripheral-in-rp2350">PWM Peripheral in RP2350</a></h1>
<p>The RP2350 has a PWM peripheral with 12 PWM generators called slices. Each slice contains two output channels (A and B), giving you a total of 24 PWM output channels. For detailed specifications, see page 1076 of the <a href="https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf">RP2350 Datasheet</a>.</p>
<p>Let’s have a quick look at some of the key concepts.</p>
<h2 id="pwm-generator-slice"><a class="header" href="#pwm-generator-slice">PWM Generator (Slice)</a></h2>
<p>A slice is the hardware block that generates PWM signals. Each of the 12 slices (PWM0–PWM11) is an independent timing unit with its own 16-bit counter, compare registers, control settings, and clock divider. This independence means you can configure each slice with different frequencies and resolutions.</p>
<h2 id="channel"><a class="header" href="#channel">Channel</a></h2>
<p>Each slice contains two output channels: <strong>Channel A</strong> and <strong>Channel B</strong>. Both channels share the same counter, so they run at the same frequency and are synchronized. However, each channel has its own compare register, allowing independent duty cycle control. This lets you generate two related but distinct PWM signals from a single slice.</p>
<h2 id="mapping-of-pwm-channels-to-gpio-pins"><a class="header" href="#mapping-of-pwm-channels-to-gpio-pins">Mapping of PWM channels to GPIO Pins</a></h2>
<p>Each GPIO pin connects to a specific slice and channel. You’ll find the complete mapping table on page 1078 of the <a href="https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf">RP2350 Datasheet</a>. For example, GP25 (the onboard LED pin) maps to PWM slice 4, channel B, labeled as <strong>4B</strong>.</p>
<img style="display: block; margin: auto;" alt="pico2" src="core-concepts/images/gpio-map-pwm-channels.png" />
<p>Initialize the PWM peripheral and get access to all slices:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pwm_slices = hal::pwm::Slices::new(pac.PWM, &amp;mut pac.RESETS);
<span class="boring">}</span></code></pre>
<p>Get a reference to PWM slice 4 for configuration:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pwm = &amp;mut pwm_slices.pwm4;
<span class="boring">}</span></code></pre>
<h3 id="gpio-to-pwm"><a class="header" href="#gpio-to-pwm">GPIO to PWM</a></h3>
<p>I have created a small form that helps you figure out which GPIO pin maps to which PWM channel and also generates sample code.</p>
<div class="pwm-mapper">
    <label for="gpio-select"><strong>Select GPIO Pin:</strong></label>
    <select id="gpio-select">
        <option value="">-- Select GPIO --</option>
    </select>
    
<div id="result-container" style="display: none;">
        
<div class="pwm-info">
            <strong>GPIO:</strong> <span id="gpio-value"></span> | 
            <strong>PWM Slice:</strong> <span id="slice-value"></span> | 
            <strong>Channel:</strong> <span id="channel-value"></span>
        </div>

        
<div class="code-header">Embassy</div>

        
<pre><code class="rust" id="embassy-code"></code></pre>

        
<div class="code-header">rp-hal</div>

        
<pre><code class="rust" id="rp-hal-code"></code></pre>

    </div>

    
<div id="placeholder" class="placeholder">
        Select a GPIO pin to see PWM mapping and generated code.
    </div>

</div>

<h2 id="phase-correct-mode"><a class="header" href="#phase-correct-mode">Phase-Correct Mode</a></h2>
<p>In standard PWM (fast PWM), the counter counts up from 0 to TOP, then immediately resets to 0. This creates asymmetric edges where the output changes at different points in the cycle.</p>
<p>Phase-correct PWM counts up to TOP, then counts back down to 0, creating a triangular waveform. The output switches symmetrically - once going up and once coming down. This produces centered pulses with edges that mirror each other, reducing electromagnetic interference and creating smoother transitions. The trade-off is that phase-correct mode runs at half the frequency of standard PWM for the same TOP value.</p>
<p>Configure PWM4 to operate in phase-correct mode for smoother output transitions.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pwm.set_ph_correct();
<span class="boring">}</span></code></pre>
<p>Get a mutable reference to channel B of PWM4 and direct its output to GPIO pin 25.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let channel = &amp;mut pwm.channel_b;
channel.output_to(pins.gpio25);
<span class="boring">}</span></code></pre>
<style>
.pwm-mapper {
    margin: 20px 0;
    background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 20px;
}

.pwm-mapper label {
    display: block;
    font-weight: 600;
    margin-bottom: 8px;
}

.pwm-mapper select {
    padding: 10px 14px;
    border: 2px solid #ddd;
    border-radius: 6px;
    font-size: 14px;
    margin-bottom: 20px;
    min-width: 200px;
    transition: border-color 0.2s;
}

.pwm-mapper select:focus {
    outline: none;
    border-color: #667eea;
}

.pwm-info {
    background: linear-gradient(to right, #667eea, #764ba2);
    color: white;
    padding: 14px 16px;
    border-radius: 6px;
    margin-bottom: 20px;
    font-size: 14px;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
}

.pwm-info strong {
    color: white;
    font-weight: 600;
}

.code-header {
    font-weight: 600;
    margin-bottom: 8px;
    margin-top: 15px;
    /* color: #667eea; */
    font-size: 14px;
}

.code-header:first-of-type {
    margin-top: 0;
}

.placeholder {
    font-style: italic;
    padding: 30px 0;
    text-align: center;
    border-radius: 6px;
    border: 2px dashed #ddd;
}
</style>
<script>
const pwmMapping = {
    0: { slice: 0, channel: 'A' }, 1: { slice: 0, channel: 'B' },
    2: { slice: 1, channel: 'A' }, 3: { slice: 1, channel: 'B' },
    4: { slice: 2, channel: 'A' }, 5: { slice: 2, channel: 'B' },
    6: { slice: 3, channel: 'A' }, 7: { slice: 3, channel: 'B' },
    8: { slice: 4, channel: 'A' }, 9: { slice: 4, channel: 'B' },
    10: { slice: 5, channel: 'A' }, 11: { slice: 5, channel: 'B' },
    12: { slice: 6, channel: 'A' }, 13: { slice: 6, channel: 'B' },
    14: { slice: 7, channel: 'A' }, 15: { slice: 7, channel: 'B' },
    16: { slice: 0, channel: 'A' }, 17: { slice: 0, channel: 'B' },
    18: { slice: 1, channel: 'A' }, 19: { slice: 1, channel: 'B' },
    20: { slice: 2, channel: 'A' }, 21: { slice: 2, channel: 'B' },
    22: { slice: 3, channel: 'A' }, 23: { slice: 3, channel: 'B' },
    24: { slice: 4, channel: 'A' }, 25: { slice: 4, channel: 'B' },
    26: { slice: 5, channel: 'A' }, 27: { slice: 5, channel: 'B' },
    28: { slice: 6, channel: 'A' }, 29: { slice: 6, channel: 'B' },
    30: { slice: 7, channel: 'A' }, 31: { slice: 7, channel: 'B' },
    32: { slice: 8, channel: 'A' }, 33: { slice: 8, channel: 'B' },
    34: { slice: 9, channel: 'A' }, 35: { slice: 9, channel: 'B' },
    36: { slice: 10, channel: 'A' }, 37: { slice: 10, channel: 'B' },
    38: { slice: 11, channel: 'A' }, 39: { slice: 11, channel: 'B' },
    40: { slice: 8, channel: 'A' }, 41: { slice: 8, channel: 'B' },
    42: { slice: 9, channel: 'A' }, 43: { slice: 9, channel: 'B' },
    44: { slice: 10, channel: 'A' }, 45: { slice: 10, channel: 'B' },
    46: { slice: 11, channel: 'A' }, 47: { slice: 11, channel: 'B' }
};

const gpioSelect = document.getElementById('gpio-select');
for (let i = 0; i <= 47; i++) {
    const option = document.createElement('option');
    option.value = i;
    option.textContent = `GPIO ${i}`;
    if (i === 25) {
        option.selected = true;
    }
    gpioSelect.appendChild(option);
}

function generateEmbassyCode(gpio, slice, channel) {
    const ch = channel.toLowerCase();
    return `let mut pwm_pin = Pwm::new_output_${ch}(p.PWM_SLICE${slice}, p.PIN_${gpio}, Default::default());`;
}

function generateRpHalCode(gpio, slice, channel) {
    const ch = channel.toLowerCase();
    return `let pwm = &mut pwm_slices.pwm${slice};
pwm.set_ph_correct();
pwm.enable();
let pwm_pin = &mut pwm.channel_${ch};
pwm_pin.output_to(pins.gpio${gpio});`;
}

gpioSelect.addEventListener('change', function() {
    const gpio = this.value;
    if (!gpio) {
        document.getElementById('result-container').style.display = 'none';
        document.getElementById('placeholder').style.display = 'block';
        return;
    }

    const { slice, channel } = pwmMapping[gpio];

    document.getElementById('gpio-value').textContent = gpio;
    document.getElementById('slice-value').textContent = slice;
    document.getElementById('channel-value').textContent = channel;

    document.getElementById('embassy-code').textContent = generateEmbassyCode(gpio, slice, channel);
    document.getElementById('rp-hal-code').textContent = generateRpHalCode(gpio, slice, channel);

    document.getElementById('result-container').style.display = 'block';
    document.getElementById('placeholder').style.display = 'none';
});

// Trigger change event on page load to show GPIO 25 by default
gpioSelect.dispatchEvent(new Event('change'));
</script>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dimming-led"><a class="header" href="#dimming-led">Dimming LED</a></h1>
<p>In this section, we will learn how to create a dimming effect(i.e. reducing and increasing the brightness gradually) for an LED using the Raspberry Pi Pico 2. First, we will dim the onboard LED, which is connected to GPIO pin 25 (based on the datasheet).</p>
<p>To make it dim, we use a technique called PWM (Pulse Width Modulation). You can refer to the intro to the PWM section <a href="#pulse-width-modulation-pwm">here</a>.</p>
<p>We will gradually increment the PWM’s duty cycle to increase the brightness, then we gradually decrement the PWM duty cycle to  reduce the brightness of the LED. This effectively creates the dimming LED effect.</p>
<h2 id="the-eye"><a class="header" href="#the-eye">The Eye</a></h2>
<p>“
Come in close… Closer…</p>
<p>Because the more you think you see… The easier it’ll be to fool you…</p>
<p>Because, what is seeing?…. You’re looking but what you’re really doing is filtering, interpreting, searching for meaning…
“</p>
<p>Here’s the magic: when this switching happens super quickly, our eyes can’t keep up. Instead of seeing the blinking, it just looks like the brightness changes! The longer the LED stays ON, the brighter it seems, and the shorter it’s ON, the dimmer it looks. It’s like tricking your brain into thinking the LED is smoothly dimming or brightening.</p>
<h2 id="core-logic"><a class="header" href="#core-logic">Core Logic</a></h2>
<p>What we will do in our program is gradually increase the duty cycle from a low value to a high value in the first loop, with a small delay between each change. This creates the fade-in effect. After that, we run another loop that decreases the duty cycle from high to low, again with a small delay. This creates the fade-out effect.</p>
<p>You can use the onboard LED, or if you want to see the dimming more clearly, use an external LED. Just remember to update the PWM slice and channel to match the GPIO pin you are using.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="simulation---led-dimming-with-pwm"><a class="header" href="#simulation---led-dimming-with-pwm">Simulation - LED Dimming with PWM</a></h1>
<p>Here is a simulation to show the dimming effect on an LED based on the duty cycle and the High and Low parts of the square wave. I set the default speed very slow so it is clear and not annoying to watch. To start it, click the “Start animation” button. You can increase the speed by reducing the delay time and watching the changes.</p>
<style>
.pwm-container {
    text-align: center;
    padding: 20px;
    max-width: 900px;
    margin: 0 auto;
}

.pwm-title {
    margin-bottom: 5px;
    font-size: 24px;
    font-weight: 500;
}

.pwm-subtitle {
    color: #888;
    margin-bottom: 20px;
    font-size: 14px;
}

.pwm-led-section {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 15px;
    padding: 30px;
    margin-bottom: 20px;
    border: 1px solid rgba(255, 255, 255, 0.05);
}

.pwm-led-container {
    position: relative;
    margin: 20px auto;
    width: 180px;
    height: 180px;
}

.pwm-led {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #ff5555, #dd0000);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 3px solid #440000;
}

.pwm-led-glow {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 160px;
    height: 160px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255, 68, 68, 0.5), transparent 70%);
    filter: blur(30px);
}

.pwm-duty-info {
    margin-top: 20px;
}

.pwm-duty-cycle {
    font-size: 48px;
    font-weight: 600;
    color: #ff5555;
    margin: 10px 0;
    text-shadow: 0 0 15px rgba(255, 85, 85, 0.4);
}

.pwm-duty-label {
    color: #999;
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.pwm-phase {
    color: #888;
    font-size: 15px;
    margin-top: 10px;
}

.pwm-waveform-section {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 20px;
    border: 1px solid rgba(255, 255, 255, 0.05);
}

.pwm-waveform-title {
    font-size: 15px;
    margin-bottom: 15px;
    color: #aaa;
    font-weight: 500;
}

#pwm-waveform {
    background: #0a0a15;
    border-radius: 8px;
    display: block;
    margin: 0 auto;
    border: 1px solid #222;
    max-width: 100%;
}

.pwm-controls-section {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 15px;
    padding: 20px;
    border: 1px solid rgba(255, 255, 255, 0.05);
}

.pwm-speed-control {
    margin-bottom: 20px;
}

.pwm-speed-label {
    color: #aaa;
    font-size: 14px;
    margin-bottom: 8px;
}

.pwm-speed-value {
    color: #ff5555;
    font-weight: 600;
    font-size: 16px;
    margin-bottom: 10px;
}

#pwm-speedSlider {
    width: 100%;
    max-width: 300px;
    height: 6px;
    border-radius: 3px;
    background: #333;
    outline: none;
    -webkit-appearance: none;
}

#pwm-speedSlider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #ff5555;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(255, 85, 85, 0.5);
}

#pwm-speedSlider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #ff5555;
    cursor: pointer;
    border: none;
    box-shadow: 0 0 10px rgba(255, 85, 85, 0.5);
}

.pwm-buttons {
    margin-top: 15px;
}

.pwm-buttons button {
    background: linear-gradient(135deg, #ff5555 0%, #cc0000 100%);
    color: white;
    border: none;
    padding: 12px 35px;
    font-size: 15px;
    border-radius: 8px;
    cursor: pointer;
    margin: 0 8px;
    font-weight: 500;
    transition: all 0.2s;
    box-shadow: 0 3px 12px rgba(255, 85, 85, 0.25);
}

.pwm-buttons button:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 5px 15px rgba(255, 85, 85, 0.35);
}

.pwm-buttons button:active:not(:disabled) {
    transform: translateY(0);
}

.pwm-buttons button:disabled {
    background: #333;
    cursor: not-allowed;
    box-shadow: none;
    opacity: 0.5;
}
</style>
<div class="pwm-container">
    
<div class="pwm-led-section">
        
<div class="pwm-led-container">
            
<div class="pwm-led-glow" id="pwm-glow"></div>

            
<div class="pwm-led" id="pwm-led"></div>

        </div>

        
<div class="pwm-duty-info">
            
<div class="pwm-duty-label">Duty Cycle</div>

            
<div class="pwm-duty-cycle" id="pwm-dutyCycle">0%</div>

            
<div class="pwm-phase" id="pwm-phase">Ready to start</div>

        </div>

    </div>

    
<div class="pwm-waveform-section">
        
<div class="pwm-waveform-title">PWM Square Wave Signal</div>

        <canvas id="pwm-waveform" width="800" height="150"></canvas>
    </div>

    
<div class="pwm-controls-section">
        
<div class="pwm-speed-control">
            
<div class="pwm-speed-label">Animation Speed</div>

            
<div class="pwm-speed-value" id="pwm-speedValue">Medium (50ms)</div>

            <input type="range" id="pwm-speedSlider" min="20" max="200" value="200" step="10">
        </div>

        
<div class="pwm-buttons">
            <button id="pwm-startBtn">Start Animation</button>
            <button id="pwm-stopBtn" disabled="">Stop</button>
        </div>

    </div>

</div>

<script>
    (function() {
    const led = document.getElementById('pwm-led');
    const glow = document.getElementById('pwm-glow');
    const dutyCycleDisplay = document.getElementById('pwm-dutyCycle');
    const phaseDisplay = document.getElementById('pwm-phase');
    const startBtn = document.getElementById('pwm-startBtn');
    const stopBtn = document.getElementById('pwm-stopBtn');
    const speedSlider = document.getElementById('pwm-speedSlider');
    const speedValue = document.getElementById('pwm-speedValue');
    const canvas = document.getElementById('pwm-waveform');
    const ctx = canvas.getContext('2d');
    
    let animationRunning = false;
    let currentDutyCycle = 0;
    let waveformOffset = 0;
    let animationSpeed = 50;

    function updateSpeedDisplay() {
        const speed = parseInt(speedSlider.value);
        let label;
        if (speed <= 40) label = 'Very Fast';
        else if (speed <= 70) label = 'Fast';
        else if (speed <= 100) label = 'Medium';
        else if (speed <= 150) label = 'Slow';
        else label = 'Very Slow';
        speedValue.textContent = `${label} (${speed}ms)`;
        animationSpeed = speed;
    }

    speedSlider.addEventListener('input', updateSpeedDisplay);

    function setDutyCycle(percent) {
        currentDutyCycle = percent;
        const brightness = percent / 100;
        led.style.opacity = brightness;
        glow.style.opacity = brightness;
        dutyCycleDisplay.textContent = `${percent}%`;
    }

    function drawWaveform() {
        const width = canvas.width;
        const height = canvas.height;
        const period = 160;
        const highVoltage = 30;
        const lowVoltage = height - 30;
        
        ctx.fillStyle = '#0a0a15';
        ctx.fillRect(0, 0, width, height);
        
        // Draw subtle grid
        ctx.strokeStyle = '#1a1a2a';
        ctx.lineWidth = 1;
        for (let x = 0; x < width; x += 40) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }
        for (let y = 0; y < height; y += 30) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
        
        // Draw voltage labels
        ctx.fillStyle = '#555';
        ctx.font = '11px monospace';
        ctx.fillText('HIGH', 8, highVoltage + 15);
        ctx.fillText('LOW', 8, lowVoltage + 5);
        
        // Draw duty cycle percentage on waveform
        ctx.fillStyle = '#ff5555';
        ctx.font = 'bold 14px sans-serif';
        ctx.fillText(`${currentDutyCycle}%`, width - 60, 25);
        
        // Draw PWM waveform
        ctx.strokeStyle = '#ff5555';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        
        const onTime = (currentDutyCycle / 100) * period;
        let x = -waveformOffset;
        let isHigh = true;
        
        while (x < width) {
            if (isHigh) {
                ctx.lineTo(x, lowVoltage);
                ctx.lineTo(x, highVoltage);
                ctx.lineTo(x + onTime, highVoltage);
                ctx.lineTo(x + onTime, lowVoltage);
                x += onTime;
                isHigh = false;
            } else {
                const offTime = period - onTime;
                ctx.lineTo(x + offTime, lowVoltage);
                x += offTime;
                isHigh = true;
            }
        }
        
        ctx.stroke();
        
        waveformOffset = (waveformOffset + 1) % period;
    }

    function animate() {
        if (animationRunning) {
            drawWaveform();
            requestAnimationFrame(animate);
        }
    }

    async function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function pwmLoop() {
        while (animationRunning) {
            phaseDisplay.textContent = 'Fading In...';
            for (let i = 0; i <= 100 && animationRunning; i++) {
                setDutyCycle(i);
                await sleep(animationSpeed);
            }
            
            if (!animationRunning) break;
            
            phaseDisplay.textContent = 'Fading Out...';
            for (let i = 100; i >= 0 && animationRunning; i--) {
                setDutyCycle(i);
                await sleep(animationSpeed);
            }
            
            if (!animationRunning) break;
            
            phaseDisplay.textContent = 'Paused (1500ms)';
            await sleep(1500);
        }
    }

    startBtn.addEventListener('click', () => {
        if (!animationRunning) {
            animationRunning = true;
            startBtn.disabled = true;
            stopBtn.disabled = false;
            speedSlider.disabled = true;
            animate();
            pwmLoop();
        }
    });

    stopBtn.addEventListener('click', () => {
        animationRunning = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        speedSlider.disabled = false;
        phaseDisplay.textContent = 'Stopped';
    });

    updateSpeedDisplay();
    setDutyCycle(0);
    drawWaveform();
})();
</script>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="led-dimming-on-raspberry-pi-pico-with-embassy"><a class="header" href="#led-dimming-on-raspberry-pi-pico-with-embassy">LED Dimming on Raspberry Pi Pico with Embassy</a></h1>
<p>Let’s create a dimming LED effect using PWM on the Raspberry Pi Pico with Embassy.</p>
<h2 id="generate-project-using-cargo-generate"><a class="header" href="#generate-project-using-cargo-generate">Generate project using cargo-generate</a></h2>
<p>By now you should be familiar with the steps. We use the cargo-generate command with our custom template, and when prompted, select Embassy as the HAL.</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.3.1
</code></pre>
<h2 id="update-imports"><a class="header" href="#update-imports">Update Imports</a></h2>
<p>Add the import below to bring the PWM types into scope:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use embassy_rp::pwm::{Pwm, SetDutyCycle};
<span class="boring">}</span></code></pre>
<h2 id="initialize-pwm"><a class="header" href="#initialize-pwm">Initialize PWM</a></h2>
<p>Let’s set up the PWM for the LED. Use the first line for the onboard LED, or uncomment the second one if you want to use an external LED on GPIO 16.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For Onboard LED
let mut pwm = Pwm::new_output_b(p.PWM_SLICE4, p.PIN_25, Default::default());

// For external LED connected on GPIO 16
// let mut pwm = Pwm::new_output_a(p.PWM_SLICE0, p.PIN_16, Default::default());
<span class="boring">}</span></code></pre>
<h2 id="main-logic"><a class="header" href="#main-logic">Main logic</a></h2>
<p>In the main loop, we create the fade effect by increasing the duty cycle from 0 to 100 percent and then bringing it back down. The small delay between each step makes the dimming smooth. You can adjust the delay and observe how the fade speed changes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    for i in 0..=100 {
        Timer::after_millis(8).await;
        let _ = pwm.set_duty_cycle_percent(i);
    }
    
    for i in (0..=100).rev() {
        Timer::after_millis(8).await;
        let _ = pwm.set_duty_cycle_percent(i);
    }

    Timer::after_millis(500).await;
}
<span class="boring">}</span></code></pre>
<h2 id="the-full-code"><a class="header" href="#the-full-code">The full code</a></h2>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use embassy_executor::Spawner;
use embassy_rp as hal;
use embassy_rp::block::ImageDef;
use embassy_rp::pwm::{Pwm, SetDutyCycle};
use embassy_time::Timer;

//Panic Handler
use panic_probe as _;
// Defmt Logging
use defmt_rtt as _;

/// Tell the Boot ROM about our application
#[unsafe(link_section = ".start_block")]
#[used]
pub static IMAGE_DEF: ImageDef = hal::block::ImageDef::secure_exe();

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let p = embassy_rp::init(Default::default());

    // For Onboard LED
    let mut pwm = Pwm::new_output_b(p.PWM_SLICE4, p.PIN_25, Default::default());

    // For external LED connected on GPIO 16
    // let mut pwm = Pwm::new_output_a(p.PWM_SLICE0, p.PIN_16, Default::default());

    loop {
        for i in 0..=100 {
            Timer::after_millis(8).await;
            let _ = pwm.set_duty_cycle_percent(i);
        }
        for i in (0..=100).rev() {
            Timer::after_millis(8).await;
            let _ = pwm.set_duty_cycle_percent(i);
        }
        Timer::after_millis(500).await;
    }
}

// Program metadata for `picotool info`.
// This isn't needed, but it's recomended to have these minimal entries.
#[unsafe(link_section = ".bi_entries")]
#[used]
pub static PICOTOOL_ENTRIES: [embassy_rp::binary_info::EntryAddr; 4] = [
    embassy_rp::binary_info::rp_program_name!(c"led-dimming"),
    embassy_rp::binary_info::rp_program_description!(c"your program description"),
    embassy_rp::binary_info::rp_cargo_version!(),
    embassy_rp::binary_info::rp_program_build_attribute!(),
];

// End of file</code></pre>
<h2 id="clone-the-existing-project"><a class="header" href="#clone-the-existing-project">Clone the existing project</a></h2>
<p>You can clone the project I created and navigate to the <code>external-led</code> folder:</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-embassy-projects
cd pico2-embassy-projects/led-dimming
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dimming-led-program-with-rp-hal"><a class="header" href="#dimming-led-program-with-rp-hal">Dimming LED Program with RP HAL</a></h1>
<p>rp-hal is an Embedded-HAL for RP series microcontrollers, and can be used as an alternative to the Embassy framework for pico.</p>
<p>This example code is taken from rp235x-hal repo (It also includes additional examples beyond just the blink examples):</p>
<p><a href="https://github.com/rp-rs/rp-hal/tree/main/rp235x-hal-examples">“https://github.com/rp-rs/rp-hal/tree/main/rp235x-hal-examples”</a></p>
<h2 id="the-main-code"><a class="header" href="#the-main-code">The main code</a></h2>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use embedded_hal::delay::DelayNs;
use hal::block::ImageDef;
use rp235x_hal as hal;

// Traig for PWM
use embedded_hal::pwm::SetDutyCycle;

//Panic Handler
use panic_probe as _;
// Defmt Logging
use defmt_rtt as _;

/// Tell the Boot ROM about our application
#[unsafe(link_section = ".start_block")]
#[used]
pub static IMAGE_DEF: ImageDef = hal::block::ImageDef::secure_exe();
/// External high-speed crystal on the Raspberry Pi Pico 2 board is 12 MHz.
/// Adjust if your board has a different frequency
const XTAL_FREQ_HZ: u32 = 12_000_000u32;

/// The minimum PWM value (i.e. LED brightness) we want
const LOW: u16 = 0;

/// The maximum PWM value (i.e. LED brightness) we want
const HIGH: u16 = 25000;

#[hal::entry]
fn main() -&gt; ! {
    // Grab our singleton objects
    let mut pac = hal::pac::Peripherals::take().unwrap();

    // Set up the watchdog driver - needed by the clock setup code
    let mut watchdog = hal::Watchdog::new(pac.WATCHDOG);

    // Configure the clocks
    //
    // The default is to generate a 125 MHz system clock
    let clocks = hal::clocks::init_clocks_and_plls(
        XTAL_FREQ_HZ,
        pac.XOSC,
        pac.CLOCKS,
        pac.PLL_SYS,
        pac.PLL_USB,
        &amp;mut pac.RESETS,
        &amp;mut watchdog,
    )
    .ok()
    .unwrap();

    // The single-cycle I/O block controls our GPIO pins
    let sio = hal::Sio::new(pac.SIO);

    // Set the pins up according to their function on this particular board
    let pins = hal::gpio::Pins::new(
        pac.IO_BANK0,
        pac.PADS_BANK0,
        sio.gpio_bank0,
        &amp;mut pac.RESETS,
    );

    // Init PWMs
    let mut pwm_slices = hal::pwm::Slices::new(pac.PWM, &amp;mut pac.RESETS);

    // Configure PWM4
    let pwm = &amp;mut pwm_slices.pwm4;
    pwm.set_ph_correct();
    pwm.enable();

    // Output channel B on PWM4 to GPIO 25
    let channel = &amp;mut pwm.channel_b;
    channel.output_to(pins.gpio25);

    let mut timer = hal::Timer::new_timer0(pac.TIMER0, &amp;mut pac.RESETS, &amp;clocks);

    loop {
        for i in LOW..=HIGH {
            timer.delay_us(8);
            let _ = channel.set_duty_cycle(i);
        }

        for i in (LOW..=HIGH).rev() {
            timer.delay_us(8);
            let _ = channel.set_duty_cycle(i);
        }

        timer.delay_ms(500);
    }
}
// Program metadata for `picotool info`.
// This isn't needed, but it's recomended to have these minimal entries.
#[unsafe(link_section = ".bi_entries")]
#[used]
pub static PICOTOOL_ENTRIES: [hal::binary_info::EntryAddr; 5] = [
    hal::binary_info::rp_cargo_bin_name!(),
    hal::binary_info::rp_cargo_version!(),
    hal::binary_info::rp_program_description!(c"your program description"),
    hal::binary_info::rp_cargo_homepage_url!(),
    hal::binary_info::rp_program_build_attribute!(),
];

// End of file</code></pre>
<h2 id="clone-the-existing-project-1"><a class="header" href="#clone-the-existing-project-1">Clone the existing project</a></h2>
<p>You can clone the blinky project I created and navigate to the <code>led-dimming</code> folder to run this version of the blink program:</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/led-dimming
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="creating-a-rust-project-for-raspberry-pi-pico-in-vs-code-with-extension"><a class="header" href="#creating-a-rust-project-for-raspberry-pi-pico-in-vs-code-with-extension">Creating a Rust Project for Raspberry Pi Pico in VS Code (with extension)</a></h1>
<p>We’ve already created the Rust project for the Pico manually and through the template. Now we are going to try another approach: using the Raspberry Pi Pico extension for VS Code.</p>
<h2 id="using-the-pico-extension"><a class="header" href="#using-the-pico-extension">Using the Pico Extension</a></h2>
<p>In Visual Studio Code, search for the extension “Raspberry Pi Pico” and ensure you’re installing the official one; it should have a verified publisher badge with the official Raspberry Pi website. Install that extension.</p>
<div class="image-with-caption" style="text-align:center; display:inline-block;">
    <img src="pico-in-vscode/images/Raspberry Pi Pico Vscode extension.png" alt="VSCode Extension for Raspberry Pi Pico" style="max-width:100%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">VSCode Extension for Raspberry Pi Pico</div>

</div>

<p>Just installing the extension might not be enough though, depending on what’s already on your machine. On Linux, you’ll likely need some basic dependencies:</p>
<pre><code class="language-sh">sudo apt install build-essential libudev-dev
</code></pre>
<h2 id="create-project"><a class="header" href="#create-project">Create Project</a></h2>
<p>Let’s create the Rust project with the Pico extension in VS Code. Open the Activity Bar on the left and click the Pico icon. Then choose “New Rust Project.”</p>
<div class="image-with-caption" style="text-align:center; display:inline-block;">
    <img src="pico-in-vscode/images/Create Project Raspberry Pi Pico Vscode extension.png" alt="Create Project Raspberry Pi Pico Vscode extension" style="max-width:100%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Create Project</div>

</div>

<p>Since this is the first time setting up, the extension will download and install the necessary tools, including the Pico SDK, picotool, OpenOCD, and the ARM and RISC-V toolchains for debugging.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>If the project was created successfully, you should see folders and files like this:</p>
<div class="image-with-caption" style="text-align:center; display:inline-block;">
    <img src="pico-in-vscode/images/Raspberry Pi Pico Rust Project Created With VS Code Extension.png" alt="Raspberry Pi Pico Rust Project Created With VS Code Extension" style="max-width:100%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Project Folder</div>

</div>

<h2 id="running-the-program"><a class="header" href="#running-the-program">Running the Program</a></h2>
<p>Now you can simply click “Run Project (USB)” to flash the program onto your Pico and run it. Don’t forget to press the BOOTSEL button when connecting your Pico to your computer. Otherwise, this option will be in disabled state.</p>
<div class="image-with-caption" style="text-align:center; display:inline-block;">
    <img src="pico-in-vscode/images/Running Rust Project with Vscode for Raspberry Pi Pico 2 (RP2350).png" alt="Running Rust Project with Vscode for Raspberry Pi Pico 2 (RP2350)" style="max-width:100%; height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Flashing Rust Firmware into Raspberry Pi Pico</div>

</div>

<p>Once flashing is complete, the program will start running immediately on your Pico. You should see the onboard LED blinking.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="按钮"><a class="header" href="#按钮">按钮</a></h1>
<p>既然我们已经知道如何闪烁 LED，让我们来学习如何读取按钮输入。这将使我们能够与 Raspberry Pi Pico 交互，并让我们的程序对我们的操作做出响应。</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="core-concepts/basics/images/Tactile Switch Buttons.jpg" alt="轻触开关按钮" style="height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">轻触开关按钮</div>

</div>

<p>按钮是一个小的轻触开关。你会在大多数初学者电子套件中找到这些。当你按下它时，内部的两个引脚接触，电路闭合。当你松开它时，引脚分离，电路再次断开。你的程序可以读取这种开或关的状态，并据此执行某些操作。</p>
<h2 id="轻触按钮如何工作"><a class="header" href="#轻触按钮如何工作">轻触按钮如何工作</a></h2>
<p>轻触按钮有四个引脚，成对排列。从上方看按钮，引脚形成一个矩形。按钮每侧的两个引脚在内部是电气连接的。</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="core-concepts/basics/images/button.png" alt="按钮内部" style="height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">按钮内部</div>

</div>

<p>我稍后会更新这一部分，提供更清晰的图表，更明确地显示内部连接。目前，这个插图足以理解这个概念。浅色线表示左侧的引脚彼此连接，右侧的引脚也是如此。当按下按钮时，左侧和右侧连接在一起。</p>
<h2 id="将按钮连接到-pico"><a class="header" href="#将按钮连接到-pico">将按钮连接到 Pico</a></h2>
<p>将按钮的一侧连接到接地（Ground），另一侧连接到通用输入输出（GPIO）引脚（例如 GPIO 15）。当按下按钮时，两侧在内部连接，GPIO 15 引脚被拉低。我们可以在代码中检查引脚是否被拉低，并据此触发动作。</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="core-concepts/basics/images/button-with-raspberry-pi-pico.png" alt="带有 Raspberry Pi Pico 2 的按钮" style="height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">带有 Raspberry Pi Pico 2 的按钮</div>

</div>

<p>等等。当按钮<em>未</em>被按下时会发生什么？GPIO 引脚现在读取的是什么电压或电平？为了在逻辑上讲得通，引脚应该处于高电平（High）状态，这样我们才能将低电平（Low）状态检测为按钮按下。但是，如果电路中没有其他东西，GPIO 引脚将处于所谓的<em>浮动状态（floating state）</em>。这是不可靠的，即使没有按下按钮，引脚也可能随机地在高电平及低电平之间切换。我们该如何解决这个问题？让我们在下一节中看看。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pull-up-and-pull-down-resistors"><a class="header" href="#pull-up-and-pull-down-resistors">Pull-up and Pull-down Resistors</a></h1>
<p>When working with buttons, switches, and other digital inputs on your Raspberry Pi Pico, you’ll quickly encounter a curious problem: what happens when nothing is connected to an input pin? The answer might surprise you; the pin becomes “floating,” picking up electrical noise and giving you random, unpredictable readings. This is where pull-up and pull-down resistors come to the rescue.</p>
<h2 id="the-floating-pin-problem"><a class="header" href="#the-floating-pin-problem">The Floating Pin Problem</a></h2>
<p>Imagine you connect a button directly to a GPIO pin on your Pico. When the button is pressed, it connects the pin to ground (0V). When released, you might expect the pin to read as HIGH, but it doesn’t work that way. Instead, the pin is disconnected from everything.  It’s floating in an undefined state, acting like an antenna that picks up electrical noise from nearby circuits, your hand, or even radio waves in the air.</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="core-concepts/basics/images/button-floating-ground.svg" alt="Floating Button" style="height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Floating Input - One side connected to Ground</div>

</div>

<p>This floating state will cause your code to read random values, making your button appear to press itself or behave erratically. We need a way to give the pin a default, predictable state.</p>
<p>By the way, you can also connect the button the other way around; connecting one side to 3.3V instead of ground (though I wouldn’t recommend this for the RP2350, and I’ll explain why shortly). However, you’ll face the same issue. When the button is pressed, it connects to the High state. When released, you might expect it to go Low, but instead it’s in a floating state again.</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="core-concepts/basics/images/button-floating-3_3.svg" alt="Floating Button" style="height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Floating Input - One side connected to 3.3V</div>

</div>

<h2 id="what-are-pull-up-and-pull-down-resistors"><a class="header" href="#what-are-pull-up-and-pull-down-resistors">What Are Pull-up and Pull-down Resistors?</a></h2>
<p>Pull-up and pull-down resistors are simple solutions that ensure a pin always has a known voltage level, even when nothing else is driving it.</p>
<p>Pull-up resistor: Connects the pin to the positive voltage (3.3V on the Pico) through a resistor. This “pulls” the pin HIGH by default. When you press a button that connects the pin to ground, the pin reads LOW.</p>
<p>Pull-down resistor: Connects the pin to ground (0V) through a resistor. This “pulls” the pin LOW by default. When you press a button that connects the pin to 3.3V, the pin reads HIGH.</p>
<h3 id="how-pull-up-resistors-work"><a class="header" href="#how-pull-up-resistors-work">How Pull-up Resistors Work</a></h3>
<p>Let’s look at a typical button circuit with a pull-up resistor:</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="core-concepts/basics/images/pull-up-resistor.svg" alt="Pull-Up Resistor" style="height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Pull-Up Resistor</div>

</div>

<p>When the button is not pressed, current flows through the resistor to the GPIO pin, holding it at 3.3V (HIGH). When you press the button, you create a direct path to ground. Since electricity follows the path of least resistance, current flows through the button to ground instead of to the pin, and the pin reads LOW.</p>
<h2 id="how-pull-down-resistors-work"><a class="header" href="#how-pull-down-resistors-work">How Pull-down Resistors Work</a></h2>
<p>A pull-down resistor works in the opposite direction:W</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="core-concepts/basics/images/pull-down-resistor.svg" alt="Pull-Down Resistor" style="height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Pull-Down Resistor</div>

</div>

<p>When the button is not pressed, the GPIO pin is connected to ground through the resistor, reading LOW. When pressed, the button connects the pin directly to 3.3V, and the pin reads HIGH.</p>
<h2 id="internal-pull-resistors"><a class="header" href="#internal-pull-resistors">Internal Pull Resistors</a></h2>
<p>The Raspberry Pi Pico has built-in pull-up and pull-down resistors on every GPIO pin. You don’t need to add external resistors for basic button inputs. You can enable them in software.</p>
<h3 id="using-pull-resistors-in-embedded-rust"><a class="header" href="#using-pull-resistors-in-embedded-rust">Using Pull Resistors in Embedded Rust</a></h3>
<p>Let’s see how to configure internal pull resistors when setting up a button input on the Pico.</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="core-concepts/basics/images/raspberry-pi-pico-pull-up-resistor.svg" alt="Internal Pull-Up Resistor" style="height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Internal Pull-Up Resistor</div>

</div>

<p>As you can see in the diagram, when we enable the internal pull-up resistor, the GPIO pin is pulled to 3.3V by default. The resistor sits inside the Pico chip itself, so we don’t need any external components; just the button connected between the GPIO pin and ground.</p>
<p>Here’s how to set it up in code:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let button = Input::new(p.PIN_16, Pull::Up);

// Read the button state
if button.is_low() {
    // Button is pressed (connected to ground)
    // Do something
}
<span class="boring">}</span></code></pre>
<p>With a pull-up resistor enabled, the GPIO pin gets pulled to HIGH voltage by default. When you press the button, it connects the pin to ground, and brings the pin LOW. So the logic is: button not pressed = HIGH, button pressed = LOW.</p>
<p><strong>Setting up a Button with a Pull-down Resistor</strong></p>
<p>Here’s similar code, but this time we use the internal pull-down resistor. With pull-down, the pin is pulled LOW by default. When the button is pressed, connecting the pin to 3.3V, it reads HIGH.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let button = Input::new(p.PIN_16, Pull::Down);

// Read the button state
if button.is_high() {
    // Button is pressed (connected to 3.3V)
    // Do something
}
<span class="boring">}</span></code></pre>
<blockquote>
<p><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M349.4 44.6c5.9-13.7 1.5-29.7-10.6-38.5s-28.6-8-39.9 1.8l-256 224c-10 8.8-13.6 22.9-8.9 35.3S50.7 288 64 288H175.5L98.6 467.4c-5.9 13.7-1.5 29.7 10.6 38.5s28.6 8 39.9-1.8l256-224c10-8.8 13.6-22.9 8.9-35.3s-16.6-20.7-30-20.7H272.5L349.4 44.6z"/></svg></span> <strong>Note:</strong> There’s a hardware bug (E9) in the initial RP2350 chip released in 2024 that affects internal pull-down resistors.</p>
<p>The bug causes the GPIO pin to read HIGH even when the button isn’t pressed, which is the opposite of what should happen. You can read more about this issue in <a href="https://www.doctormonk.com/2024/09/are-pico-2-rp2350-gpio-pins-broken.html">this blog post</a>.</p>
<p>The bug was fixed in the newer RP2350 A4 chip revision. If you’re using an older chip, avoid using <code>Pull::Down</code> in your code. Instead, you can use an external pull-down resistor and set <code>Pull::None</code> in the code.</p>
</blockquote>
<p>With a pull-down resistor enabled, the button should connect to 3.3V when pressed. The pin reads LOW when not pressed, and HIGH when pressed.</p>
<h2 id="using-a-floating-input"><a class="header" href="#using-a-floating-input">Using a Floating Input</a></h2>
<p>You can also configure a pin without any internal pull resistor:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let button = Input::new(p.PIN_16, Pull::None);
<span class="boring">}</span></code></pre>
<p>However, as we discussed earlier, floating inputs are unreliable for buttons because they pick up electrical noise and read random values. This option is only useful when you have an external pull-up or pull-down resistor in your circuit, or when connecting to devices that actively drive the pin HIGH or LOW (like some sensors).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="led-on-button-press"><a class="header" href="#led-on-button-press">LED on Button Press</a></h1>
<p>Let’s build a simple project that turns on an LED whenever the button is pressed. You can use an external LED or the built in LED. Just change the LED pin number in the code to match the one you are using.</p>
<div class="image-with-caption" style="text-align:center; ">
    <img src="core-concepts/basics/images/button-with-raspberry-pi-pico.png" alt="Button with Raspberry Pi Pico 2" style="height:auto; display:block; margin:0 auto;" />
    
<div class="caption" style="font-size:0.9em; color:#555; margin-top:6px;">Button with Raspberry Pi Pico 2</div>

</div>

<p>We will start by creating a new project with cargo generate and our template.</p>
<p>In your terminal, type:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.3.1
</code></pre>
<h2 id="button-as-input"><a class="header" href="#button-as-input">Button as Input</a></h2>
<p>So far, we’ve been using the <code>Output</code> struct because our Pico was sending signals to the LED. This time, the Pico will receive a signal from the button, so we’ll configure it as an <code>Input</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let button = Input::new(p.PIN_15, Pull::Up);
<span class="boring">}</span></code></pre>
<p>We’ve connected one side of the button to GPIO 15. The other side is connected to Ground. This means when we press the button, the pin gets pulled to the LOW state. As we discussed earlier, without a pull resistor, the input would be left in a floating state and read unreliable values. So we enable the internal pull-up resistor to keep the pin HIGH by default.</p>
<h2 id="led-as-output"><a class="header" href="#led-as-output">Led as Output</a></h2>
<p>We configure the LED pin as an output, starting in the LOW state (off). If you’re using an external LED, uncomment the first line for GPIO 16. If you’re using the Pico’s built-in LED, use GPIO 25 as shown. Just make sure your circuit matches whichever pin you choose.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// let mut led = Output::new(p.PIN_16, Level::Low);
let mut led = Output::new(p.PIN_25, Level::Low);
<span class="boring">}</span></code></pre>
<h2 id="main-loop"><a class="header" href="#main-loop">Main loop</a></h2>
<p>Now in a loop, we constantly check if the button is pressed by testing whether it’s in the LOW state. We add a small 5-millisecond delay between checks to avoid overwhelming the system. When the button reads LOW (pressed), we set the LED pin HIGH to turn it on, then wait for 3 seconds so we can visually observe it. You can adjust this delay to your preference.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {

    if button.is_low() {
        defmt::info!("Button pressed");
        led.set_high();
        Timer::after_secs(3).await;
    } else {
        led.set_low();
    }

    Timer::after_millis(5).await;
}
<span class="boring">}</span></code></pre>
<blockquote>
<p><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M349.4 44.6c5.9-13.7 1.5-29.7-10.6-38.5s-28.6-8-39.9 1.8l-256 224c-10 8.8-13.6 22.9-8.9 35.3S50.7 288 64 288H175.5L98.6 467.4c-5.9 13.7-1.5 29.7 10.6 38.5s28.6 8 39.9-1.8l256-224c10-8.8 13.6-22.9 8.9-35.3s-16.6-20.7-30-20.7H272.5L349.4 44.6z"/></svg></span> <strong>Debounce:</strong> If you reduce the delay, you might notice that sometimes a single button press triggers multiple detections. This is called “button bounce”. When you press a physical button, the metal contacts inside briefly bounce against each other, creating multiple electrical signals in just a few milliseconds. In this example, the 3-second LED delay effectively masks any bounce issues, but in applications where you need to count individual button presses accurately, you’ll need debouncing logic.</p>
</blockquote>
<p>We also log “Button pressed” using defmt. If you’re using a debug probe, use the <code>cargo embed --release</code> command to see these logs in your terminal.</p>
<h2 id="the-full-code-1"><a class="header" href="#the-full-code-1">The Full code</a></h2>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use embassy_executor::Spawner;
use embassy_rp::block::ImageDef;
use embassy_rp::gpio::Pull;
use embassy_rp::{
    self as hal,
    gpio::{Input, Level, Output},
};
use embassy_time::Timer;

//Panic Handler
use panic_probe as _;
// Defmt Logging
use defmt_rtt as _;

/// Tell the Boot ROM about our application
#[unsafe(link_section = ".start_block")]
#[used]
pub static IMAGE_DEF: ImageDef = hal::block::ImageDef::secure_exe();

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let p = embassy_rp::init(Default::default());

    let button = Input::new(p.PIN_15, Pull::Up);
    // let mut led = Output::new(p.PIN_16, Level::Low);
    let mut led = Output::new(p.PIN_25, Level::Low);

    loop {
        if button.is_low() {
            defmt::info!("Button pressed");
            led.set_high();
            Timer::after_secs(3).await;
        } else {
            led.set_low();
        }
        Timer::after_millis(5).await;
    }
}

// Program metadata for `picotool info`.
// This isn't needed, but it's recomended to have these minimal entries.
#[unsafe(link_section = ".bi_entries")]
#[used]
pub static PICOTOOL_ENTRIES: [embassy_rp::binary_info::EntryAddr; 4] = [
    embassy_rp::binary_info::rp_program_name!(c"button"),
    embassy_rp::binary_info::rp_program_description!(c"your program description"),
    embassy_rp::binary_info::rp_cargo_version!(),
    embassy_rp::binary_info::rp_program_build_attribute!(),
];

// End of file</code></pre>
<h2 id="clone-the-existing-project-2"><a class="header" href="#clone-the-existing-project-2">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>button</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-embassy-projects
cd pico2-embassy-projects/button
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="voltage-divider"><a class="header" href="#voltage-divider">Voltage Divider</a></h1>
<p>A voltage divider is a simple circuit that reduces a higher input voltage to a lower output voltage using two resistors connected in series. You might need a voltage divider from time to time when working with sensors or modules that output higher voltages than your microcontroller can safely handle.</p>
<p>The resistor connected to the input voltage is called \( R_{1} \), and the resistor connected to ground is called \( R_{2} \). The output voltage \( V_{out} \) is measured at the point between \( R_{1} \) and \( R_{2} \), and it will be a fraction of the input voltage \( V_{in} \).</p>
<h2 id="circuit"><a class="header" href="#circuit">Circuit</a></h2>
<img style="display: block; margin: auto;" alt="Voltage Divider" src="core-concepts/images/voltage-divider.png" />
<p>The output voltage (V<sub>out</sub>) is calculated using this formula:</p>
<p>\[
V_{out} = V_{in} \times \frac{R_2}{R_1 + R_2}
\]</p>
<h3 id="example-calculation-for--v_out-"><a class="header" href="#example-calculation-for--v_out-">Example Calculation for \( V_{out} \)</a></h3>
<p>Given:</p>
<ul>
<li>\( V_{in} = 3.3V \)</li>
<li>\( R_1 = 10 k\Omega \)</li>
<li>\( R_2 = 10 k\Omega \)</li>
</ul>
<p>Substitute the values:</p>
<p>\[
V_{out} = 3.3V \times \frac{10 k\Omega}{10 k\Omega + 10 k\Omega} = 3.3V \times \frac{10}{20} = 3.3V \times 0.5 = 1.65V
\]</p>
<p>The output voltage \( V_{out} \) is 1.65V.</p>
<pre class="playground"><code class="language-rust editable">fn main() {
    // You can edit the code
    // You can modify values and run the code 
    let vin: f64 = 3.3;
    let r1: f64 = 10000.0;
    let r2: f64 = 10000.0;

    let vout = vin * (r2 / (r1 + r2));

    println!("The output voltage Vout is: {:.2} V", vout);
}</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h2>
<p>Voltage dividers are used in applications like potentiometers, where the resistance changes as the knob is rotated, adjusting the output voltage. They are also used to measure resistive sensors such as light sensors and thermistors, where a known voltage is applied, and the microcontroller reads the voltage at the center node to determine sensor values like temperature.</p>
<h2 id="voltage-divider-simulation"><a class="header" href="#voltage-divider-simulation">Voltage Divider Simulation</a></h2>
<style>
canvas {
    border: 1px solid #ccc;
    margin-top: 20px;
    background:white;
}
</style>
<p><label for="vin">Input Voltage (V<sub>in</sub>):</label>
<input type="number" id="vin" step="0.01" value="3.3" oninput="updateAndCalculate()"><br><br></p>
<p><label for="r1">Resistor R1 (Ω):</label>
<input type="number" id="r1" step="1" value="10000" oninput="updateAndCalculate()"><br><br></p>
<p><label for="r2">Resistor R2 (Ω):</label>
<input type="number" id="r2" step="1" value="10000" oninput="updateAndCalculate()"><br><br></p>
<p class="formula" id="formula">
    Formula: V<sub>out</sub> = V<sub>in</sub> × (R<sub>2</sub> / (R<sub>1</sub> + R<sub>2</sub>))
</p>

<p class="formula" id="filledFormula">
    Filled Formula: V<sub>out</sub> = 3.3 × (10000 / (10000 + 10000))
</p>

<p id="result">Output Voltage (Vout): 1.65 V</p>

<p><canvas id="circuitCanvas" width="600" height="400"></canvas></p>
<h2 id="simulator-in-falstad-website"><a class="header" href="#simulator-in-falstad-website">Simulator in Falstad website</a></h2>
<p>I used the website <a href="https://www.falstad.com/circuit/">https://www.falstad.com/circuit/</a> to create the diagram. It’s a great tool for drawing circuits. You can download the file I created, <a href="core-concepts/voltage-divider.circuitjs.txt"><code>voltage-divider.circuitjs.txt</code></a>, and import it to experiment with the circuit.</p>
<script>
    function updateAndCalculate() {
        updateFormula();
        calculateVoltage();
        drawCircuit();
    }

    function updateFormula() {
        const vin = parseFloat(document.getElementById('vin').value) || 0;
        const r1 = parseFloat(document.getElementById('r1').value) || 0;
        const r2 = parseFloat(document.getElementById('r2').value) || 0;

        document.getElementById('filledFormula').textContent = 
            `Filled Formula: Vout = ${vin} × (${r2} / (${r1} + ${r2}))`;
    }

    function calculateVoltage() {
        const vin = parseFloat(document.getElementById('vin').value);
        const r1 = parseFloat(document.getElementById('r1').value);
        const r2 = parseFloat(document.getElementById('r2').value);

        if (isNaN(vin) || isNaN(r1) || isNaN(r2) || r1 <= 0 || r2 <= 0) {
            document.getElementById('result').textContent = 
                "Please enter valid positive numbers for all fields.";
            return;
        }

        const vout = vin * (r2 / (r1 + r2));
        document.getElementById('result').textContent = 
            `Output Voltage (Vout): ${vout.toFixed(2)} V`;
    }

    function drawZigZagResistor(ctx, x, y, width, height) {
        const segments = 6;
        const step = height / segments;
        const segmentWidth = width / 2;

        ctx.beginPath();
        ctx.moveTo(x, y);

        for (let i = 0; i < segments; i++) {
            const offset = (i % 2 === 0) ? segmentWidth : -segmentWidth;
            ctx.lineTo(x + offset, y + step * (i + 1));
        }

        const finalOffset = (segments % 2 === 0) ? segmentWidth : -segmentWidth;
        ctx.lineTo(x + 1, y + height + 4);
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function drawGroundSymbol(ctx, x, y) {
        const lineSpacing = 5;
        const topLineWidth = 20;

        ctx.beginPath();
        ctx.moveTo(x - topLineWidth / 2, y);
        ctx.lineTo(x + topLineWidth / 2, y);
        ctx.stroke();

        const middleLineWidth = topLineWidth * 0.6;
        ctx.beginPath();
        ctx.moveTo(x - middleLineWidth / 2, y + lineSpacing);
        ctx.lineTo(x + middleLineWidth / 2, y + lineSpacing);
        ctx.stroke();

        const bottomLineWidth = middleLineWidth * 0.6;
        ctx.beginPath();
        ctx.moveTo(x - bottomLineWidth / 2, y + 2 * lineSpacing);
        ctx.lineTo(x + bottomLineWidth / 2, y + 2 * lineSpacing);
        ctx.stroke();
    }

    function drawCircuit() {
        const canvas = document.getElementById('circuitCanvas');
        const ctx = canvas.getContext('2d');
        const vin = parseFloat(document.getElementById('vin').value) || 0;
        const r1 = parseFloat(document.getElementById('r1').value) || 0;
        const r2 = parseFloat(document.getElementById('r2').value) || 0;
        const vout = vin * (r2 / (r1 + r2)) || 0;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        ctx.fillText(`V_in: ${vin.toFixed(2)} V`, 35, 94);
        ctx.beginPath();
        ctx.moveTo(100, 100);
        ctx.lineTo(150, 100);
        ctx.stroke();

        ctx.moveTo(130, 100);
        ctx.lineTo(170, 100);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(170, 100);
        ctx.lineTo(170, 130);
        ctx.stroke();

        ctx.fillText(`R1: ${r1} Ω`, 200, 155);
        drawZigZagResistor(ctx, 170, 130, 23, 40);

        ctx.beginPath();
        ctx.moveTo(170, 175);
        ctx.lineTo(170, 230);
        ctx.stroke();

        ctx.fillText(`R2: ${r2} Ω`, 200, 256);
        drawZigZagResistor(ctx, 170, 230, 20, 40);

        ctx.beginPath();
        ctx.moveTo(170, 275);
        ctx.lineTo(170, 300);
        ctx.stroke();
        ctx.fillText('Ground', 160, 330);

        drawGroundSymbol(ctx, 170, 300);

        ctx.beginPath();
        ctx.moveTo(170, 200);
        ctx.lineTo(270, 200);
        ctx.stroke();
        ctx.fillText(`V_out: ${vout.toFixed(2)} V`, 280, 203);
    }

    updateAndCalculate();
</script>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bat-beacon-distance-sensor-project-"><a class="header" href="#bat-beacon-distance-sensor-project-">Bat Beacon: Distance Sensor Project 🦇</a></h1>
<p>If you’ve seen the Batman Begins movie, you’ll remember the scene where Batman uses a device that emits ultrasonic signals to summon a swarm of bats. It’s one of the coolest gadgets in his arsenal! While we won’t be building a bat-summoning beacon today, we will be working with the similar ultrasonic technology.</p>
<h2 id="ultrasonic"><a class="header" href="#ultrasonic">Ultrasonic</a></h2>
<p>Ultrasonic waves are sound waves with frequencies above 20,000 Hz, beyond what human ears can detect. But many animals can. Bats use ultrasonic waves to fly in the dark and avoid obstacles. Dolphins use them to communicate and to sense objects underwater.</p>
<h3 id="ultrasonic-technology-around-you"><a class="header" href="#ultrasonic-technology-around-you">Ultrasonic Technology Around You</a></h3>
<p>Humans have borrowed this natural sonar principle for everyday inventions:</p>
<ul>
<li><strong>Car parking sensors</strong> use ultrasonic sensors to detect obstacles when you reverse. As you get closer to an object, the beeping gets faster.</li>
<li><strong>Submarines</strong> use sonar to navigate and detect underwater objects</li>
<li><strong>Medical ultrasound</strong> allows doctors to see inside the human body</li>
<li><strong>Automatic doors and robot navigation</strong> rely on ultrasonic distance sensing</li>
</ul>
<p>Today, you’ll build your own distance sensor using an ultrasonic module; sending out sound waves, measuring how long they take to bounce back, and calculating distance.</p>
<h2 id="meet-the-hardware"><a class="header" href="#meet-the-hardware">Meet the Hardware</a></h2>
<p>The HC-SR04+ is a simple and low cost ultrasonic distance sensor. It can measure distances from about 2 cm up to 400 cm. It works by sending out a short burst of ultrasonic sound and then listening for the echo. By measuring how long the echo takes to return, the sensor can calculate how far the object is.</p>
<blockquote>
<p><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M349.4 44.6c5.9-13.7 1.5-29.7-10.6-38.5s-28.6-8-39.9 1.8l-256 224c-10 8.8-13.6 22.9-8.9 35.3S50.7 288 64 288H175.5L98.6 467.4c-5.9 13.7-1.5 29.7 10.6 38.5s28.6 8 39.9-1.8l256-224c10-8.8 13.6-22.9 8.9-35.3s-16.6-20.7-30-20.7H272.5L349.4 44.6z"/></svg></span> <strong>Important Note about Variants:</strong></p>
<p>The HC-SR04 normally operates at 5V, which can be problematic for the Raspberry Pi Pico. If possible, purchase the <strong>HC-SR04+</strong> version, which works with both 3.3V and 5V, making it more suitable for the Pico.</p>
<p><strong>Why This Matters:</strong>
The HC-SR04’s Echo pin outputs a 5V signal, but the Pico’s GPIO pins can only safely handle 3.3V. Connecting 5V directly to the Pico could damage it.</p>
<p><strong>Your Options:</strong></p>
<ol>
<li><strong>Buy the HC-SR04+ variant</strong> (recommended and easiest solution)</li>
<li><strong>Use a voltage divider</strong> on the Echo pin to reduce the 5V signal to 3.3V</li>
<li><strong>Use a logic level converter</strong> to safely step down the voltage</li>
<li><strong>Power the HC-SR04 with 3.3V</strong> (not recommended, as it may work unreliably or not at all)</li>
</ol>
</blockquote>
<p>In this project, we’ll build a proximity detector that gradually brightens an LED as objects get closer. When the sensor detects something within 30 cm, the LED will glow brighter using PWM. You can change the distance value if you want to try different ideas.</p>
<img style="display: block; margin: auto;width:500px" alt="ultrasonic" src="ultrasonic/images/hc-sr04-ultrasonic.jpg" />
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before starting, get familiar with yourself on these topics</p>
<ul>
<li><a href="#pulse-width-modulation-pwm">PWM</a></li>
<li><a href="#voltage-divider">Voltage Divider</a></li>
</ul>
<h2 id="hardware-requirements"><a class="header" href="#hardware-requirements">Hardware Requirements</a></h2>
<p>To complete this project, you will need:</p>
<ul>
<li>HC-SR04+ or HC-SR04 Ultrasonic Sensor</li>
<li>Breadboard</li>
<li>Jumper wires</li>
<li>External LED (You can also use the onboard LED, but you’ll need to modify the code accordingly)</li>
<li>If you are using the standard HC-SR04 module that operates at 5V, you will need two resistors (1kΩ and 2kΩ or 2.2kΩ) to form a voltage divider.</li>
</ul>
<p>The HC-SR04 Sensor module has a transmitter and receiver. The module has Trigger and Echo pins which can be connected to the GPIO pins of a pico. When the receiver detects the returning sound wave, the Echo pin goes HIGH for a duration equal to the time it takes for the wave to return to the sensor.</p>
<h2 id="datasheet"><a class="header" href="#datasheet">Datasheet</a></h2>
<p>Most electronic components come with a datasheet. It’s a technical document that tells you everything you need to know about how the component works, its electrical characteristics, and how to use it properly.</p>
<p>For the HC-SR04 ultrasonic sensor, you can find the datasheet here:
<a href="https://cdn.sparkfun.com/datasheets/Sensors/Proximity/HCSR04.pdf">https://cdn.sparkfun.com/datasheets/Sensors/Proximity/HCSR04.pdf</a></p>
<p>Datasheets can look intimidating at first with all their technical specifications and diagrams, but you don’t need to understand everything in them.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="how-does-an-ultrasonic-sensor-work"><a class="header" href="#how-does-an-ultrasonic-sensor-work">How Does an Ultrasonic Sensor Work?</a></h1>
<p>Ultrasonic sensors work by emitting sound waves at a frequency too high (40kHz) for humans to hear. These sound waves travel through the air and bounce back when they hit an object. The sensor calculates the distance by measuring how long it takes for the sound waves to return.</p>
<img style="display: block; margin: auto;width:500px" alt="ultrasonic" src="ultrasonic/images/ultrasonic.jpg" />
<ul>
<li><strong>Transmitter:</strong> Sends out ultrasonic sound waves.</li>
<li><strong>Receiver:</strong> Detects the sound waves that bounce back from an object.</li>
</ul>
<p><strong>Formula to calculate distance</strong>:</p>
<pre><code>Distance = (Time x Speed of Sound) / 2
</code></pre>
<p>The speed of sound is approximately 0.0343 cm/µs (or 343 m/s) at normal air pressure and a temperature of 20°C.</p>
<h2 id="example-calculation"><a class="header" href="#example-calculation">Example Calculation:</a></h2>
<p>Let’s say the ultrasonic sensor detects that the sound wave took 2000 µs to return after hitting an object.</p>
<p>Step 1: Calculate the total distance traveled by the sound wave:</p>
<pre><code>Total distance = Time x Speed of Sound
Total distance = 2000 µs x 0.0343 cm/µs = 68.6 cm
</code></pre>
<p>Step 2: Since the sound wave traveled to the object and back, the distance to the object is half of the total distance:</p>
<pre><code>Distance to object = 68.6 cm / 2 = 34.3 cm
</code></pre>
<p>Thus, the object is 34.3 cm away from the sensor.</p>
<h2 id="hc-sr04-pinout"><a class="header" href="#hc-sr04-pinout">HC-SR04 Pinout</a></h2>
<p>The module has four pins: VCC, Trig, Echo, and GND.</p>
<table style="width:300px;height:200px;">
<tr>
    <th>Pin</th>
    <th>Function</th>
</tr>

<tr>
    <td style="vertical-align: middle;text-align: center;" class="slanted-text st-red">VCC</td>
    <td>Power Supply</td>
</tr>

<tr>
    <td style="vertical-align: middle;text-align: center;" class="slanted-text st-yellow">Trig</td>
    <td>Trigger Signal</td>
</tr>

<tr>
    <td style="vertical-align: middle;text-align: center;" class="slanted-text st-teal">Echo</td>
    <td>Echo Signal</td>
</tr>

<tr>
    <td style="vertical-align: middle;text-align: center;" class="slanted-text st-blue">GND</td>
    <td>Ground</td>
</tr>

</table>

<h2 id="measuring-distance-with-the-hc-sr04-module"><a class="header" href="#measuring-distance-with-the-hc-sr04-module">Measuring Distance with the HC-SR04 module</a></h2>
<p>The HC-SR04 module has a transmitter and receiver, responsible for sending ultrasonic waves and detecting the reflected waves.  We will use the Trig pin to send sound waves. And read from the Echo pin to measure the distance.</p>
<img style="display: block; margin: auto;" alt="ultrasonic" src="ultrasonic/images/ultrasonic-trigger-echo-wave.png" />
<p>As you can see in the diagram, we connect the Trig and Echo pins to the GPIO pins of the microcontroller (we also connect VCC and GND but left them out to keep the illustration simple). We send ultrasonic waves by setting the Trig pin HIGH for 10 microseconds and then setting it back to LOW. This triggers the module to send 8 consecutive ultrasonic waves at a frequency of 40 kHz.  It is recommended to have a minimum gap of 50ms between each trigger.</p>
<p>When the sensor’s waves hit an object, they bounce back to the module. As you can see in the diagram, the Echo pin changes the signal sent to the microcontroller, with the length of time the signal stays HIGH (pulse width) corresponding to the distance. In the microcontroller, we measure how long the Echo pin stays HIGH; Then, we can use this time duration to calculate the distance to the object.</p>
<p><strong>Pulse width and the distance:</strong></p>
<p>The pulse width (amount of time it stays high) produced by the Echo pin will range from about 150µs to 25,000µs(25ms); this is only if it hits an object. If there is no object, it will produce a pulse width of around 38ms.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wiring-the-hc-sr04-to-the-pico-2-using-a-voltage-divider"><a class="header" href="#wiring-the-hc-sr04-to-the-pico-2-using-a-voltage-divider">Wiring the HC-SR04 to the Pico 2 Using a Voltage Divider</a></h1>
<p>If you are using the regular HC-SR04 like I am, you will need to create a voltage divider for the Echo pin. In this section we will look at how to set up the circuit. However, if you are lucky and you bought the HC-SR04 Plus, you can skip to the next page. The circuit becomes much simpler because you can power the sensor with 3.3 V instead of 5 V.</p>
<h2 id="common-resistor-combination"><a class="header" href="#common-resistor-combination">Common resistor combination</a></h2>
<p>Below are some resistor pairs you can use to bring the HC-SR04 Echo signal down to about 3.3 V. R1 is the resistor connected to the Echo pin, and R2 is the resistor connected to ground.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>R1 (With Echo)</th><th>R2 (With Gnd)</th><th>Output Voltage</th></tr>
</thead>
<tbody>
<tr><td>330 Ω</td><td>470 Ω</td><td>2.94 V</td></tr>
<tr><td>330 Ω</td><td>680 Ω</td><td>3.37 V</td></tr>
<tr><td>470 Ω</td><td>680 Ω</td><td>2.96 V</td></tr>
<tr><td>680 Ω</td><td>1 kΩ</td><td>2.98 V</td></tr>
<tr><td>1 kΩ</td><td>1.8 kΩ</td><td>3.21 V</td></tr>
<tr><td>1 kΩ</td><td>2 kΩ</td><td>3.33 V</td></tr>
<tr><td>1 kΩ</td><td>2.2 kΩ</td><td>3.44 V</td></tr>
<tr><td>1.5 kΩ</td><td>2.2 kΩ</td><td>2.97 V</td></tr>
<tr><td>2.2 kΩ</td><td>3.3 kΩ</td><td>3.00 V</td></tr>
<tr><td>3.3 kΩ</td><td>4.7 kΩ</td><td>2.94 V</td></tr>
<tr><td>4.7 kΩ</td><td>6.8 kΩ</td><td>2.96 V</td></tr>
<tr><td>6.8 kΩ</td><td>10 kΩ</td><td>2.98 V</td></tr>
<tr><td>22 kΩ</td><td>33 kΩ</td><td>3.00 V</td></tr>
<tr><td>33 kΩ</td><td>47 kΩ</td><td>2.94 V</td></tr>
<tr><td>47 kΩ</td><td>68 kΩ</td><td>2.96 V</td></tr>
</tbody>
</table>
</div>
<p>You can choose any resistor pair from the table because all of them bring the 5 V Echo signal down to a safe level near 3.3 V. In practice it is best to use the values you already have in your kit.</p>
<h2 id="connection-for-the-raspberry-pi-pico-2-and-ultrasonic-sensor"><a class="header" href="#connection-for-the-raspberry-pi-pico-2-and-ultrasonic-sensor">Connection for the Raspberry Pi Pico 2 and Ultrasonic Sensor</a></h2>
<table>
  
<thead>
    
<tr>
      <th>Pico 2 Pin</th>
      <th style="height: 4px; width: 250px; margin: 0 auto;">Wire</th>
      <th>HC-SR04 Pin</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>VBUS (Pin 40)</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire red" style="height: 4px; width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>VCC</td>
    </tr>

    
<tr>
      <td>GPIO 17</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire green" style="height: 4px; width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>Trig</td>
    </tr>

    
<tr>
      <td>GPIO 16 (via Voltage Divider)</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire purple" style="height: 4px; width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>Echo (through 1kΩ/2.2kΩ divider)</td>
    </tr>

    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="height: 4px; width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GND</td>
    </tr>

  </tbody>

</table>

<ul>
<li><strong>VCC</strong>: Connect the VCC pin on the HC-SR04 to VBUS (Pin 40) on the Pico 2. The HC-SR04 requires 5V power, and VBUS provides 5V from the USB connection.</li>
<li><strong>Trig</strong>: Connect to GPIO 17 on the Pico 2 to trigger the ultrasonic sound pulses.</li>
<li><strong>Echo</strong>: Connect to GPIO 16 on the Pico 2 through a voltage divider (1kΩ resistor from Echo pin, 2kΩ or 2.2kΩ resistor to ground). The junction between the resistors connects to GPIO 16. This divider steps down the 5V Echo signal to ~3.4V, protecting the Pico’s 3.3V GPIO pins.</li>
<li><strong>GND</strong>: Connect to any ground pin on the Pico 2.</li>
</ul>
<p><a href="ultrasonic/images/HC-SR04-pico2-rp2350-voltage-divider-circuit.png"><img style="display: block; margin: auto;" alt="pico2" src="ultrasonic/images/HC-SR04-pico2-rp2350-voltage-divider-circuit.png" /></a></p>
<h2 id="connection-for-the-pico-2-and-led"><a class="header" href="#connection-for-the-pico-2-and-led">Connection for the Pico 2 and LED</a></h2>
<table>
  
<thead>
    
<tr>
      <th>Pico 2 Pin</th>
      <th style="width: 250px; margin: 0 auto;">Wire</th>
      <th>Component</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>GPIO 3</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire yellow" style="width: 200px; margin: 0 auto;">
          
<div class="female-left"></div>

          
<div class="female-right"></div>

        </div>

      </td>
      <td>Resistor (220Ω-330Ω)</td>
    </tr>

    
<tr>
      <td>Resistor</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire yellow" style="width: 200px; margin: 0 auto;">
          
<div class="female-left"></div>

          
<div class="female-right"></div>

        </div>

      </td>
      <td>Anode (long leg) of LED</td>
    </tr>

    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="female-left"></div>

          
<div class="female-right"></div>

        </div>

      </td>
      <td>Cathode (short leg) of LED</td>
    </tr>

  </tbody>

</table>

<div style="break-before: page; page-break-before: always;"></div>
<h1 id="circuit-for-hc-sr04"><a class="header" href="#circuit-for-hc-sr04">Circuit for HC-SR04+</a></h1>
<p>Skip this step if you are using the 5V-only variant of the HC-SR04.</p>
<p>Connection for the Pico and Ultrasonic:</p>
<table>
  
<thead>
    
<tr>
      <th>Pico Pin</th>
      <th style="height: 4px; width: 250px; margin: 0 auto;">Wire</th>
      <th>HC-SR04+ Pin</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>3.3V</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire red" style="height: 4px; width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>VCC</td>
    </tr>

    
<tr>
      <td>GPIO 17</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire green" style="height: 4px; width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>Trig</td>
    </tr>

    
<tr>
      <td>GPIO 16</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire yellow" style="height: 4px; width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>Echo</td>
    </tr>

    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="height: 4px; width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GND</td>
    </tr>

  </tbody>

</table>

<ul>
<li><strong>VCC</strong>: Connect the VCC pin on the HC-SR04+ to the 3.3V pin on the Pico.</li>
<li><strong>Trig</strong>: Connect to GPIO 17 on the Pico to start the ultrasonic sound pulses.</li>
<li><strong>Echo</strong>: Connect to GPIO 16 on the Pico; this pin sends a pulse when it detects the reflected signal, and the pulse length shows how long the signal took to return.</li>
<li><strong>GND</strong>: Connect to the ground pin on the Pico.</li>
<li><strong>LED</strong>: Connect the anode (long leg) of the LED to GPIO 3.</li>
</ul>
<p>Connection for the Pico and LED:</p>
<table>
  
<thead>
    
<tr>
      <th>Pico Pin</th>
      <th style="width: 250px; margin: 0 auto;">Wire</th>
      <th>Component</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>GPIO 3</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire orange" style="width: 200px; margin: 0 auto;">
          
<div class="female-left"></div>

          
<div class="female-right"></div>

        </div>

      </td>
      <td>Resistor</td>
    </tr>

    
<tr>
      <td>Resistor</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire orange" style="width: 200px; margin: 0 auto;">
          
<div class="female-left"></div>

          
<div class="female-right"></div>

        </div>

      </td>
      <td>Anode (long leg) of LED</td>
    </tr>

    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="female-left"></div>

          
<div class="female-right"></div>

        </div>

      </td>
      <td>Cathode (short leg) of LED</td>
    </tr>

  </tbody>

</table>

<p><a href="ultrasonic/images/pico-ultrasonic-led.jpg"><img style="display: block; margin: auto;" alt="pico2" src="ultrasonic/images/pico-ultrasonic-led.jpg" /></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-tutorial-using-the-hc-sr04-sensor-with-the-pico-2"><a class="header" href="#rust-tutorial-using-the-hc-sr04-sensor-with-the-pico-2">Rust Tutorial: Using the HC-SR04 Sensor with the Pico 2</a></h1>
<p>We will start by creating a new project using the Embassy framework. After that, we wll build the same project again using rp-hal. As usual, generate the project from the template with cargo-generate:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.3.1
</code></pre>
<p>When prompted, give your project a name like “bat-beacon” and choose “embassy” as the HAL. Enable defmt logging, if you have a debug probe so you can view logs also.</p>
<h2 id="additional-imports"><a class="header" href="#additional-imports">Additional Imports</a></h2>
<p>In addition to the usual boilerplate imports, you’ll need to add these specific imports to your project.  Your code editor should provide auto-import suggestions for most of these, with the exception of the SetDutyCycle trait which you’ll need to add manually.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For GPIO
use embassy_rp::gpio::{Input, Level, Output, Pull};

// For PWM
use embassy_rp::pwm::{Pwm, SetDutyCycle};

// For time calculation
use embassy_time::Instant;
<span class="boring">}</span></code></pre>
<p>We need GPIO types to control our trigger and echo pins, PWM to control the LED brightness, and timing utilities to measure the ultrasonic pulse duration.</p>
<h2 id="mapping-gpio-pins"><a class="header" href="#mapping-gpio-pins">Mapping GPIO Pins</a></h2>
<p>By now, you should be familiar with PWM from the Dimming LED section. We will create a similar dimming effect here. But there’s a key difference.  In the Dimming LED chapter, we made the LED fade in and out repeatedly using conditions. Here, we will increase the LED brightness only when an object gets closer to the sensor.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For Onboard LED
// let mut led = Pwm::new_output_b(p.PWM_SLICE4, p.PIN_25, Default::default());

// For external LED connected on GPIO 3
let mut led = Pwm::new_output_b(p.PWM_SLICE1, p.PIN_3, Default::default());
<span class="boring">}</span></code></pre>
<p>You can use either the onboard LED or an external LED. I prefer using the external LED. You can see the gradual brightness changes much better.</p>
<p>Next, let’s initialize the LED to be off and get its maximum duty cycle value:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>led.set_duty_cycle(0)
    .expect("duty cycle is within valid range");

let max_duty = led.max_duty_cycle();
// defmt::info!("Max duty cycle {}", max_duty);
<span class="boring">}</span></code></pre>
<p>The duty cycle determines LED brightness; 0 is completely off, and max_duty is fully on.</p>
<h2 id="configuring-trigger-and-echo-pins"><a class="header" href="#configuring-trigger-and-echo-pins">Configuring Trigger and Echo Pins</a></h2>
<p>As you know, we have to send a signal to the trigger pin from the Pico, so we’ll configure GPIO pin 17 (connected to the trigger pin) as an Output with an initial Low state. The sensor indicates distance through pulses on the echo pin, meaning it sends signals to the Pico (input to the Pico). So we’ll configure GPIO pin 16 (connected to the echo pin) as an Input.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut trigger = Output::new(p.PIN_17, Level::Low);
let echo = Input::new(p.PIN_16, Pull::Down);
<span class="boring">}</span></code></pre>
<h2 id="converting-distance-to-led-brightness"><a class="header" href="#converting-distance-to-led-brightness">Converting Distance to LED Brightness</a></h2>
<p>We need a function that converts distance measurements into appropriate duty cycle values. The closer an object is, the higher the duty cycle (brighter the LED):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_DISTANCE_CM: f64 = 30.0;

fn calculate_duty_cycle(distance: f64, max_duty: u16) -&gt; u16 {
    if distance &lt; MAX_DISTANCE_CM &amp;&amp; distance &gt;= 2.0 {
        let normalized = (MAX_DISTANCE_CM - distance) / MAX_DISTANCE_CM;
        // defmt::info!("duty cycle :{}", (normalized * max_duty as f64) as u16);
        (normalized * max_duty as f64) as u16
    } else {
        0
    }
}
<span class="boring">}</span></code></pre>
<p>This function takes the measured distance and the maximum duty cycle value. If the distance is between 2cm (the sensor’s minimum range) and 30cm, we normalize it to a 0-1 range and multiply by the maximum duty cycle. Objects closer than 2cm or farther than 30cm result in the LED turning off (duty cycle of 0).</p>
<h2 id="measuring-distance-with-the-sensor"><a class="header" href="#measuring-distance-with-the-sensor">Measuring Distance with the Sensor</a></h2>
<p>We’ll measure distance by sending an ultrasonic pulse and timing how long it takes to return:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const ECHO_TIMEOUT: Duration = Duration::from_millis(100);

async fn measure_distance(trigger: &amp;mut Output&lt;'_&gt;, echo: &amp;Input&lt;'_&gt;) -&gt; Option&lt;f64&gt; {
    // Send trigger pulse
    trigger.set_low();
    Timer::after_micros(2).await;
    trigger.set_high();
    Timer::after_micros(10).await;
    trigger.set_low();

    // Wait for echo HIGH (sensor responding)
    let timeout = Instant::now();
    while echo.is_low() {
        if timeout.elapsed() &gt; ECHO_TIMEOUT {
            defmt::warn!("Timeout waiting for HIGH");
            return None; // Return early on timeout
        }
    }

    let start = Instant::now();

    // Wait for echo LOW (pulse complete)
    let timeout = Instant::now();
    while echo.is_high() {
        if timeout.elapsed() &gt; ECHO_TIMEOUT {
            defmt::warn!("Timeout waiting for LOW");
            return None; // Return early on timeout
        }
    }

    let end = Instant::now();

    // Calculate distance
    let time_elapsed = end.checked_duration_since(start)?.as_micros();
    let distance = time_elapsed as f64 * 0.0343 / 2.0;

    Some(distance)
}
<span class="boring">}</span></code></pre>
<p>We begin by setting the trigger pin low for a brief moment, then raising it high for 10 microseconds. This creates the trigger pulse that instructs the sensor to emit an ultrasonic burst. After that, we wait for the Echo pin to rise. The time the Echo pin stays high represents the round-trip travel time of the sound wave. Using this duration, we compute the final distance value and return it.</p>
<p>We have also added a timeout while waiting for the echo pin to change state so the code does not get stuck indefinitely. When the pin fails to respond within the allowed time, we treat the attempt as a failed reading and return None, which lets the rest of the program continue running normally.</p>
<h2 id="the-main-loop"><a class="header" href="#the-main-loop">The main loop</a></h2>
<p>Finally, let’s create our main loop that continuously reads the sensor and updates the LED:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    Timer::after_millis(10).await;

    let distance = match measure_distance(&amp;mut trigger, &amp;echo).await {
        Some(d) =&gt; d,
        None =&gt; {
            Timer::after_secs(5).await;
            continue; // Skip to next iteration
        }
    };

    let duty_cycle = calculate_duty_cycle(distance, max_duty);
    led.set_duty_cycle(duty_cycle)
        .expect("duty cycle is within valid range");
}
<span class="boring">}</span></code></pre>
<p>Every 10 milliseconds, we measure the distance. If the measurement succeeds, we calculate the appropriate LED brightness and apply it. If it fails (due to timeout or sensor issues), we wait 5 seconds before trying again.</p>
<h2 id="the-full-code-2"><a class="header" href="#the-full-code-2">The Full code</a></h2>
<p>Here’s everything put together:</p>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use embassy_executor::Spawner;
use embassy_rp as hal;
use embassy_rp::block::ImageDef;
use embassy_time::{Duration, Timer};

//Panic Handler
use panic_probe as _;
// Defmt Logging
use defmt_rtt as _;

// For GPIO
use embassy_rp::gpio::{Input, Level, Output, Pull};

// For PWM
use embassy_rp::pwm::{Pwm, SetDutyCycle};

// For time calculation
use embassy_time::Instant;

/// Tell the Boot ROM about our application
#[unsafe(link_section = ".start_block")]
#[used]
pub static IMAGE_DEF: ImageDef = hal::block::ImageDef::secure_exe();

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let p = embassy_rp::init(Default::default());

    // For Onboard LED
    // let mut led = Pwm::new_output_b(p.PWM_SLICE4, p.PIN_25, Default::default());

    // For external LED connected on GPIO 3
    let mut led = Pwm::new_output_b(p.PWM_SLICE1, p.PIN_3, Default::default());

    let mut trigger = Output::new(p.PIN_17, Level::Low);
    let echo = Input::new(p.PIN_16, Pull::None);

    led.set_duty_cycle(0)
        .expect("duty cycle is within valid range");

    let max_duty = led.max_duty_cycle();
    // defmt::info!("Max duty cycle {}", max_duty);

    loop {
        Timer::after_millis(10).await;

        let distance = match measure_distance(&amp;mut trigger, &amp;echo).await {
            Some(d) =&gt; d,
            None =&gt; {
                Timer::after_secs(5).await;
                continue; // Skip to next iteration
            }
        };

        let duty_cycle = calculate_duty_cycle(distance, max_duty);
        led.set_duty_cycle(duty_cycle)
            .expect("duty cycle is within valid range");
    }
}

const ECHO_TIMEOUT: Duration = Duration::from_millis(100);

async fn measure_distance(trigger: &amp;mut Output&lt;'_&gt;, echo: &amp;Input&lt;'_&gt;) -&gt; Option&lt;f64&gt; {
    // Send trigger pulse
    trigger.set_low();
    Timer::after_micros(2).await;
    trigger.set_high();
    Timer::after_micros(10).await;
    trigger.set_low();

    // Wait for echo HIGH (sensor responding)
    let timeout = Instant::now();
    while echo.is_low() {
        if timeout.elapsed() &gt; ECHO_TIMEOUT {
            defmt::warn!("Timeout waiting for HIGH");
            return None; // Return early on timeout
        }
    }

    let start = Instant::now();

    // Wait for echo LOW (pulse complete)
    let timeout = Instant::now();
    while echo.is_high() {
        if timeout.elapsed() &gt; ECHO_TIMEOUT {
            defmt::warn!("Timeout waiting for LOW");
            return None; // Return early on timeout
        }
    }

    let end = Instant::now();

    // Calculate distance
    let time_elapsed = end.checked_duration_since(start)?.as_micros();
    let distance = time_elapsed as f64 * 0.0343 / 2.0;

    Some(distance)
}

const MAX_DISTANCE_CM: f64 = 30.0;

fn calculate_duty_cycle(distance: f64, max_duty: u16) -&gt; u16 {
    if distance &lt; MAX_DISTANCE_CM &amp;&amp; distance &gt;= 2.0 {
        let normalized = (MAX_DISTANCE_CM - distance) / MAX_DISTANCE_CM;
        // defmt::info!("duty cycle :{}", (normalized * max_duty as f64) as u16);
        (normalized * max_duty as f64) as u16
    } else {
        0
    }
}

// Program metadata for `picotool info`.
// This isn't needed, but it's recomended to have these minimal entries.
#[unsafe(link_section = ".bi_entries")]
#[used]
pub static PICOTOOL_ENTRIES: [embassy_rp::binary_info::EntryAddr; 4] = [
    embassy_rp::binary_info::rp_program_name!(c"ultrasonic"),
    embassy_rp::binary_info::rp_program_description!(c"your program description"),
    embassy_rp::binary_info::rp_cargo_version!(),
    embassy_rp::binary_info::rp_program_build_attribute!(),
];

// End of file</code></pre>
<h2 id="clone-the-existing-project-3"><a class="header" href="#clone-the-existing-project-3">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>ultrasonic</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-embassy-projects
cd pico2-embassy-projects/ultrasonic
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="writing-rust-code-use-hc-sr04-ultrasonic-sensor-with-pico-2"><a class="header" href="#writing-rust-code-use-hc-sr04-ultrasonic-sensor-with-pico-2">Writing Rust Code Use HC-SR04 Ultrasonic Sensor with Pico 2</a></h1>
<p>We’ll start by generating the project using the template, then modify the code to fit the current project’s requirements.</p>
<h2 id="generating-from-template"><a class="header" href="#generating-from-template">Generating From template</a></h2>
<p>Refer to the <a href="#项目模板---使用-cargo-generate">Template section</a> for details and instructions.</p>
<p>To generate the project, run:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.3.1
</code></pre>
<p>When prompted, choose a name for your project-let’s go with “bat-beacon”. Don’t forget to select <code>rp-hal</code> as the HAL.</p>
<p>Then, navigate into the project folder:</p>
<pre><code class="language-sh">cd PROJECT_NAME
# For example, if you named your project "bat-beacon":
# cd bat-beacon
</code></pre>
<h2 id="setup-the-led-pin"><a class="header" href="#setup-the-led-pin">Setup the LED Pin</a></h2>
<p>You should understand this code by now. If not, please complete the Blink LED section first.</p>
<p>Quick recap: Here, we’re configuring the PWM for the LED, which allows us to control the brightness by adjusting the duty cycle.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pwm = &amp;mut pwm_slices.pwm1;  // Access PWM slice 1
pwm.set_ph_correct();            // Set phase-correct mode for smoother transitions
pwm.enable();                    // Enable the PWM slice
let led = &amp;mut pwm.channel_b; // Select PWM channel B
led.output_to(pins.gpio3);   // Set GPIO 3 as the PWM output pin
<span class="boring">}</span></code></pre>
<h2 id="setup-the-trigger-pin"><a class="header" href="#setup-the-trigger-pin">Setup the Trigger Pin</a></h2>
<p>The Trigger pin on the ultrasonic sensor is used to start the ultrasonic pulse. It needs to be set as an output so we can control it to send the pulse.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut trigger = pins.gpio17.into_push_pull_output();
<span class="boring">}</span></code></pre>
<h2 id="setup-the-echo-pin"><a class="header" href="#setup-the-echo-pin">Setup the Echo Pin</a></h2>
<p>The Echo pin on the ultrasonic sensor receives the returning signal, which allows us to measure the time it took for the pulse to travel to an object and back. It’s set as an input to detect the returning pulse.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut echo = pins.gpio16.into_pull_down_input();
<span class="boring">}</span></code></pre>
<h2 id="-light-it-up"><a class="header" href="#-light-it-up">🦇 Light it Up</a></h2>
<h3 id="step-1-send-the-trigger-pulse"><a class="header" href="#step-1-send-the-trigger-pulse">Step 1: Send the Trigger Pulse</a></h3>
<p>First, we need to send a short pulse to the trigger pin to start the ultrasonic measurement.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ensure the Trigger pin is low before starting
trigger.set_low().ok().unwrap();
timer.delay_us(2);

// Send a 10-microsecond high pulse
trigger.set_high().ok().unwrap();
timer.delay_us(10);
trigger.set_low().ok().unwrap();
<span class="boring">}</span></code></pre>
<h3 id="step-2-measure-the-echo-time"><a class="header" href="#step-2-measure-the-echo-time">Step 2: Measure the Echo Time</a></h3>
<p>Next, we will use two loops. The first loop will run as long as the echo pin state is LOW. Once it goes HIGH, we will record the current time in a variable. Then, we start the second loop, which will continue as long as the echo pin remains HIGH. When it returns to LOW, we will record the current time in another variable. The difference between these two times gives us the pulse width.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut time_low = 0;
let mut time_high = 0;

// Wait for the Echo pin to go high and note down the time
while echo.is_low().ok().unwrap() {
    time_low = timer.get_counter().ticks();
}

// Wait for the Echo pin to go low and note down the time
while echo.is_high().ok().unwrap() {
    time_high = timer.get_counter().ticks();
}

// Calculate the time taken for the signal to return
let time_passed = time_high - time_low;

<span class="boring">}</span></code></pre>
<h3 id="step-3-calculate-distance"><a class="header" href="#step-3-calculate-distance">Step 3: Calculate Distance</a></h3>
<p>To calculate the distance, we need to use the pulse width. The pulse width tells us how long it took for the ultrasonic waves to travel to an obstacle and return. Since the pulse represents the round-trip time, we divide it by 2 to account for the journey to the obstacle and back.</p>
<p>The speed of sound in air is approximately 0.0343 cm per microsecond. By multiplying the time (in microseconds) by this value and dividing by 2, we obtain the distance to the obstacle in centimeters.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let distance = time_passed as f64 * 0.0343 / 2.0;
<span class="boring">}</span></code></pre>
<h3 id="step-4-pwm-duty-cycle-for-led"><a class="header" href="#step-4-pwm-duty-cycle-for-led">Step 4: PWM Duty cycle for LED</a></h3>
<p>Finally, we adjust the LED brightness based on the measured distance.</p>
<p>The duty cycle percentage is calculated using our own logic, you can modify it to suit your needs. When the object is closer than 30 cm, the LED brightness will increase. The closer the object is to the ultrasonic module, the higher the calculated ratio will be, which in turn adjusts the duty cycle. This results in the LED brightness gradually increasing as the object approaches the sensor.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let duty_cycle = if distance &lt; 30.0 {
    let step = 30.0 - distance;
    (step * 1500.) as u16 + 1000
} else {
    0
};

// Change the LED brightness
led.set_duty_cycle(duty_cycle).unwrap();
<span class="boring">}</span></code></pre>
<h3 id="complete-logic-of-the-loop"><a class="header" href="#complete-logic-of-the-loop">Complete Logic of the loop</a></h3>
<p>Note: This code snippet highlights the loop section and does not include the entire code.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    timer.delay_ms(5);

    trigger.set_low().ok().unwrap();
    timer.delay_us(2);
    trigger.set_high().ok().unwrap();
    timer.delay_us(10);
    trigger.set_low().ok().unwrap();

    let mut time_low = 0;
    let mut time_high = 0;
    while echo.is_low().ok().unwrap() {
        time_low = timer.get_counter().ticks();
    }
    while echo.is_high().ok().unwrap() {
        time_high = timer.get_counter().ticks();
    }
    let time_passed = time_high - time_low;

    let distance = time_passed as f64 * 0.0343 / 2.0;

    let duty_cycle = if distance &lt; 30.0 {
        let step = 30.0 - distance;
        (step * 1500.) as u16 + 1000
    } else {
        0
    };
    led.set_duty_cycle(duty_cycle).unwrap();
}
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-4"><a class="header" href="#clone-the-existing-project-4">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>ultrasonic</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-rp-projects/ultrasonic
</code></pre>
<h2 id="your-challenge"><a class="header" href="#your-challenge">Your Challenge</a></h2>
<ol>
<li>Use Embassy framework instead of rp-hal</li>
<li>Use the onboard LED instead</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="inter-integrated-circuit-i2c"><a class="header" href="#inter-integrated-circuit-i2c">Inter-Integrated Circuit (I2C)</a></h1>
<p>So far, we’ve been toggling output pins between High and Low states to control an LED and reading the same two levels from a button. But working with interesting devices like display modules, RFID readers, and SD card readers requires something more. Simple pin toggling won’t work here. We need a proper communication mechanism, and that’s where communication protocols come in. The most common ones are I2C, SPI, and UART. Each one has its own advantages and disadvantages.</p>
<p>Since we will be using an OLED display in the next chapter, and it communicates over I2C, this is the first protocol we are going to explore. OLED displays are one of the modules I enjoy the most. I’ve used them to make small games and a bunch of fun personal projects.</p>
<h2 id="what-is-i2c"><a class="header" href="#what-is-i2c">What Is I2C?</a></h2>
<p>I2C stands for Inter-Integrated Circuit, also written as I²C. It’s one of the popular communication methods used by microcontrollers to talk to sensors, displays (like OLEDs), and other chips. It is a serial, half-duplex, and synchronous interface. Let’s break down what that means.</p>
<ul>
<li>
<p>Serial means data is transferred one bit at a time over a single data line. Think of it like a one-lane bridge where cars (bits of data) pass through one after another in a straight line.</p>
</li>
<li>
<p>Half-duplex means data travels in only one direction at a time. Imagine using a walkie-talkie - only one person can talk while the other listens, and then they switch roles.</p>
</li>
<li>
<p>Synchronous means both devices rely on a shared clock signal to coordinate communication. Picture two people throwing a ball to each other, but only when a referee blows a whistle. That whistle acts like a clock signal, ensuring timing stays in sync.</p>
</li>
</ul>
<h2 id="controller-and-target"><a class="header" href="#controller-and-target">Controller and Target</a></h2>
<p>I2C uses a controller-target model. The controller (formerly known as master) is the device that initiates communication and provides the clock signal. The target (formerly known as slave) responds to the controller’s commands.</p>
<img style="display: block; margin: auto;" alt="I2C Single Controller and Single Target" src="i2c/images/i2c-bus.svg" />
<p align="center"><em>Figure: Single Controller and Single Target</em></p>

<p>In typical embedded projects, the microcontroller(e.g: Pico) acts as the controller, and connected devices like displays(eg: OLED) or sensors act as targets.</p>
<p>I2C makes it easy to connect many devices on the same two wires. You can connect multiple targets to a single controller, which is the most common setup. I2C also supports multiple controllers on the same bus, so more than one controller can talk to one or more targets.</p>
<h2 id="i2c-bus"><a class="header" href="#i2c-bus">I2C Bus</a></h2>
<p>The I2C bus uses just two lines, which are shared by all connected devices:</p>
<ul>
<li>
<p>SCL (Serial Clock Line): Carries the clock signal from the controller. Sometimes devices label them as SCK.</p>
</li>
<li>
<p>SDA (Serial Data Line): Transfers the data in both directions. Sometimes devices label them as SDI.</p>
</li>
</ul>
<img style="display: block; margin: auto;" alt="I2C Single Controller and Multiple Target" src="i2c/images/ic2-multi-target-single-controller.svg" />
<p align="center"><em>Figure: Single Controller and Multiple Target</em></p>

<p>All connected devices share the same two wires. The controller selects which target to communicate with by sending that device’s unique address.</p>
<h2 id="i2c-addresses"><a class="header" href="#i2c-addresses">I2C Addresses</a></h2>
<p>Each I2C target device has a 7-bit or 10-bit address. The most common is 7-bit, which allows for up to 128 possible addresses.</p>
<p>Many devices have a fixed address defined by the manufacturer, but others allow configuring the lower bits of the address using pins or jumpers. For example, a sensor might use pins labeled A0 and A1 to change its address, allowing you to use multiple copies of the same chip on the same bus.</p>
<p>When the controller wants to talk to a target, it starts by sending a START condition, followed by the device address and a read/write bit. The matching device responds with an ACK (acknowledge) signal, and communication continues.</p>
<h2 id="speed-modes"><a class="header" href="#speed-modes">Speed Modes</a></h2>
<p>I2C supports different speed modes depending on how fast data needs to be transferred. Standard mode goes up to 100 kbps, fast mode reaches 400 kbps, and Fast Mode Plus allows up to 1 Mbps. For even faster communication, High-Speed mode supports up to 3.4 Mbps. There is also an Ultra-Fast mode (5 Mbps).  The speed you can use depends on what speed modes are supported by both the microcontroller’s I2C interface and the connected target devices.</p>
<h2 id="why-i2c"><a class="header" href="#why-i2c">Why I2C?</a></h2>
<p>I2C is ideal when you want to connect several devices using just two wires. It is well-suited for applications where speed is not critical but wiring simplicity is important.</p>
<p>The good news is that in Embedded Rust, you don’t need to implement the I2C protocol yourself. The embedded-hal crate defines common I2C traits, and the HAL for your chip takes care of the low-level details. In the next section, we will see more on it.</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://www.circuitbasics.com/basics-of-the-i2c-communication-protocol/">Basics of the I2C Communication Protocol</a>: Refer this if you want in-depth understanding how the controller communincates with target.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="using-i2c-with-the-embedded-rust-ecosystem"><a class="header" href="#using-i2c-with-the-embedded-rust-ecosystem">Using I2C with the Embedded Rust Ecosystem</a></h1>
<p>In the previous section, we learned the basics of I2C communication and how the controller-target (master-slave) model works. Now, let’s see how these concepts apply in the Embedded Rust ecosystem, where modular and reusable design is a key principle.</p>
<h2 id="the-role-of-embedded-hal"><a class="header" href="#the-role-of-embedded-hal">The Role of embedded-hal</a></h2>
<p>The embedded-hal crate defines a standard set of traits for embedded hardware abstraction, including I2C. These traits allow driver code (like for displays or sensors) to be written generically so that it can run on many different microcontrollers without needing platform-specific changes.</p>
<p>The core I2C trait looks like this:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait I2c&lt;A: AddressMode = SevenBitAddress&gt;: ErrorType {
    // This method must be implemented by HAL authors
    fn transaction(...);
    // These are default methods built on top of `transaction`
    fn read(...);
    fn write(...);
    fn write_read(...);
}
<span class="boring">}</span></code></pre>
<p>The only method that the HAL is required to implement is transaction. The trait provides default implementations of read, write, and write_read using this method.</p>
<p>The generic type parameter A specifies the address mode and has a default type parameter of <code>SevenBitAddress</code>. So, in most cases you don’t need to specify it manually. For 10-bit addressing, you can use TenBitAddress instead.</p>
<p>Microcontroller-specific HAL crates (like esp-hal, stm32-hal, or nrf-hal) implement this trait for their I2C peripherals. For example, the esp-hal crate implements I2C. If you are curious, you can look at the implementation <a href="https://github.com/esp-rs/esp-hal/blob/de67c3101346cdbe030ffa1bb95b13943ee8d790/esp-hal/src/i2c/master/mod.rs#L671">here</a>.</p>
<blockquote>
<p>In addition to the regular embedded-hal crate, there is an async version called embedded-hal-async. It defines similar traits, but they are designed to work with async code, which is useful when writing non-blocking drivers or tasks in embedded systems.</p>
</blockquote>
<h2 id="platform-independent-drivers"><a class="header" href="#platform-independent-drivers">Platform-Independent Drivers</a></h2>
<p>Imagine you are writing a driver for a sensor or a display that communicates over I2C. You don’t want to tie your code to a specific microcontroller like the Raspberry Pi Pico or ESP32. Instead, you can write the driver in a generic way using the embedded-hal trait.</p>
<p>As long as your driver only depends on the I2C trait, it can run on any platform that provides an implementation of this trait-such as STM32, nRF, or ESP32.</p>
<h2 id="sharing-the-i2c-bus"><a class="header" href="#sharing-the-i2c-bus">Sharing the I2C Bus</a></h2>
<p>Many embedded projects connect multiple I2C devices (like an OLED display, an LCD, and various sensors) to the same SDA and SCL lines. However, only one device can control the bus at a time.</p>
<img style="display: block; margin: auto;" alt="I2C Single Controller and Multiple Target" src="i2c/images/ic2-mcu-multi-device.svg" />
<p align="center"><em>Figure: Microcontroller(Pico) and Multiple Devices</em></p>

<p>If you give exclusive access to one driver, other devices cannot communicate. This is where the embedded-hal-bus crate helps.</p>
<p>It provides wrapper types like AtomicDevice, CriticalSectionDevice, and RefCellDevice that allow multiple drivers to safely share access to the same I2C bus. These wrappers themselves implement the I2c trait, so drivers can use them as if they were the original bus.</p>
<p>You can use I2C in two ways:</p>
<img style="display: block; margin: auto;" alt="I2C Single Controller Multiple Devices" src="i2c/images/i2c-embedded-hal-rust-ecosystem.svg" />
<ul>
<li>
<p>Without sharing: If your application only talks to one I2C device, you can pass the I2C bus instance provided by the HAL (which implements the I2c trait) directly to the driver.</p>
</li>
<li>
<p>With sharing: If your application needs to communicate with multiple I2C devices on the same bus, you can wrap the I2C bus instance (provided by the HAL) using one of the sharing types from the embedded-hal-bus crate, such as AtomicDevice or CriticalSectionDevice. This allows safe, coordinated access across multiple drivers.</p>
</li>
</ul>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<ul>
<li><a href="https://docs.rs/embedded-hal/latest/embedded_hal/i2c/index.html">embedded-hal docs on I2C</a>: This documentation provides in-depth details on how I2C traits are structured and how they are intended to be used across different platforms.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="raspberry-pi-pico-2rp2350s-i2c"><a class="header" href="#raspberry-pi-pico-2rp2350s-i2c">Raspberry Pi Pico 2(RP2350)’s I2C</a></h1>
<p>Now that you understand the basics of the I2C protocol, let us look at how it works on the Raspberry Pi Pico 2. The RP2350 has two separate I2C controllers, named I2C0 and I2C1. Think of these as two independent communication channels that can operate simultaneously. This helps when two devices share the same I2C address, because you can place them on separate controllers.</p>
<h2 id="available-i2c-pins"><a class="header" href="#available-i2c-pins">Available I2C Pins</a></h2>
<p>Both I2C controllers support multiple pin options for SDA and SCL. You only choose one pair for each controller.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>I2C Controller</th><th>GPIO Pins</th></tr>
</thead>
<tbody>
<tr><td>I2C0 – SDA</td><td>GP0, GP4, GP8, GP12, GP16, GP20</td></tr>
<tr><td>I2C0 – SCL</td><td>GP1, GP5, GP9, GP13, GP17, GP21</td></tr>
<tr><td>I2C1 – SDA</td><td>GP2, GP6, GP10, GP14, GP18, GP26</td></tr>
<tr><td>I2C1 – SCL</td><td>GP3, GP7, GP11, GP15, GP19, GP27</td></tr>
</tbody>
</table>
</div>
<br />
<p><a href="images/pico2-board.png"><img style="display: block; margin: auto;" alt="pico2" src="images/pico2-board.png" /></a></p>
<p>On the Pico 2 board layout, pins that support I2C functionality are labeled with SDA and SCL, and are also highlighted in blue to make them easy to identify.</p>
<h2 id="speed-options"><a class="header" href="#speed-options">Speed Options</a></h2>
<p>The RP2350’s I2C controllers support three different speed modes, allowing you to match the capabilities of whatever devices you’re connecting:</p>
<ul>
<li>Standard mode: Up to 100 kb/s (kilobits per second) - the slowest but most universally compatible</li>
<li>Fast mode: Up to 400 kb/s - a good balance for most sensors and displays</li>
<li>Fast mode plus: Up to 1000 kb/s - for when you need quicker data transfer</li>
</ul>
<p>It’s worth noting that the RP2350 doesn’t support the ultra-high-speed modes (High-speed at 3.4 Mb/s or Ultra-Fast at 5 Mb/s) that some specialized devices use. However, most common sensors, displays, and peripherals work perfectly fine within the supported speed ranges.</p>
<h2 id="controller-or-target-mode"><a class="header" href="#controller-or-target-mode">Controller or Target mode</a></h2>
<p>The RP2350 can only be a Controller (master) or a Target (slave) at any given time—not both simultaneously on the same controller. For typical projects where the Pico 2 is controlling sensors and displays, you’ll always use controller mode.</p>
<hr>
<p>For the complete technical specifications, you can refer to <a href="https://pip-assets.raspberrypi.com/categories/1214-rp2350/documents/RP-008373-DS-2-rp2350-datasheet.pdf?disposition=inline#page=984">page 983</a> of the RP2350 Datasheet.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oled-显示屏"><a href="#oled-显示屏" class="header">OLED 显示屏</a></h1>
<h2 id="oled-display"><a class="header" href="#oled-display">OLED Display</a></h2>
<p>In this section, we’ll learn how to connect an OLED display module to the Raspberry Pi Pico 2.</p>
<p>We’ll create simple projects like displaying text and an image (display Ferris 🦀 image) on the OLED. We’ll use the I2C protocol to connect the OLED display to the Pico.</p>
<img style="display: block; margin: auto;width:500px" alt="pico2" src="images/oled-ssd1306.jpg" />
<!-- TODO: more info on the intro and in-depth technical info for the OLED -->
<h3 id="hardware-requirements-1"><a class="header" href="#hardware-requirements-1">Hardware Requirements</a></h3>
<p>For this project, you’ll need:</p>
<ul>
<li>An OLED display (0.96 Inch I2C/IIC 4-Pin, 128x64 resolution, SSD1306 chip)</li>
<li>A breadboard</li>
<li>Jumper wires</li>
</ul>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<table>
  
<thead>
    
<tr>
      <th>Pico Pin</th>
      <th style="width: 250px; margin: 0 auto;">Wire</th>
      <th>OLED Pin</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>GPIO 18</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire green" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>SDA</td>
    </tr>

    
<tr>
      <td>GPIO 19</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire yellow" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>SCL</td>
    </tr>

    
<tr>
      <td>3.3V</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire red" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>VCC</td>
    </tr>

    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GND</td>
    </tr>

  </tbody>

</table>

<p>We will connect the SDA to GPIO 18 and the SCL to GPIO 19. Attach VCC to 3.3V for power, and GND to GND. This setup allows the OLED display to communicate with the microcontroller using I2C.</p>
<p><a href="oled/assets/pico-oled-circuit.jpg"><img style="display: block;  margin: auto;" alt="pico2" src="oled/assets/pico-oled-circuit.jpg" /></a></p>
<h2 id="new-crates"><a class="header" href="#new-crates">New crates</a></h2>
<p>In addition to the usual crate like <code>rp-hal</code>, we will be using these new crates necessary for the project.</p>
<ul>
<li><a href="https://github.com/rust-embedded-community/ssd1306"><code>ssd1306</code></a>: a driver for the SSD1306 OLED display, supporting both I2C and 4-wire SPI.</li>
<li><a href="https://github.com/embedded-graphics/embedded-graphics"><code>embedded-graphics</code></a>: a 2D graphics library tailored for memory-constrained embedded devices, enabling text and graphic rendering.</li>
<li><a href="https://github.com/embedded-graphics/tinybmp"><code>tinybmp</code></a>: a lightweight BMP parser for embedded, no-std environments. We’ll use this to directly load <code>.bmp</code> images with the <code>embedded-graphics</code> crate, avoiding the need for raw image data.</li>
</ul>
<h2 id="prerequisite"><a class="header" href="#prerequisite">Prerequisite</a></h2>
<ul>
<li><a href="#inter-integrated-circuit-i2c">I2C protocol</a></li>
</ul>
<h2 id="resources-2"><a class="header" href="#resources-2">Resources</a></h2>
<ul>
<li><a href="https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf">SSD1306 Datasheet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hello-rust-on-oled"><a class="header" href="#hello-rust-on-oled">Hello Rust on OLED</a></h1>
<p>We will create a simple program to display “Hello, Rust” in the OLED display.</p>
<h2 id="generating-from-template-1"><a class="header" href="#generating-from-template-1">Generating From template</a></h2>
<p>Refer to the <a href="#项目模板---使用-cargo-generate">Template section</a> for details and instructions.</p>
<p>To generate the project, run:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.1.0
</code></pre>
<p>When prompted, choose a name for your project-let’s go with “oh-led”. Don’t forget to select <code>rp-hal</code> as the HAL.</p>
<p>Then, navigate into the project folder:</p>
<pre><code class="language-sh">cd PROJECT_NAME
# For example, if you named your project "oh-led":
# cd oh-led
</code></pre>
<h3 id="add-additional-dependencies"><a class="header" href="#add-additional-dependencies">Add Additional Dependencies</a></h3>
<p>Since we are using the SSD1306 OLED display, we need to include the SSD1306 driver. To add this dependency, use the following Cargo command:</p>
<pre><code class="language-sh">cargo add ssd1306@0.9.0
</code></pre>
<p>We will use the embedded_graphics crate to handle graphical rendering on the OLED display, to draw images, shapes, and text.</p>
<pre><code class="language-sh">cargo add embedded-graphics@0.8.1
</code></pre>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<h3 id="additional-imports-1"><a class="header" href="#additional-imports-1">Additional imports</a></h3>
<p>In addition to the imports from the template, you’ll need the following additional dependencies for this task.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hal::fugit::RateExtU32;
use hal::gpio::{FunctionI2C, Pin};
use ssd1306::{prelude::*, I2CDisplayInterface, Ssd1306};
use embedded_graphics::prelude::*;
use embedded_graphics::mono_font::ascii::FONT_6X10;
use embedded_graphics::mono_font::MonoTextStyleBuilder;
use embedded_graphics::pixelcolor::BinaryColor;
use embedded_graphics::text::{Baseline, Text};
<span class="boring">}</span></code></pre>
<h3 id="pin-configuration"><a class="header" href="#pin-configuration">Pin Configuration</a></h3>
<p>We start by configuring the GPIO pins for the I2C communication. In this case, GPIO18 is set as the SDA pin, and GPIO19 is set as the SCL pin. We then configure the I2C peripheral to work in master mode.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure two pins as being I²C, not GPIO
let sda_pin: Pin&lt;_, FunctionI2C, _&gt; = pins.gpio18.reconfigure();
let scl_pin: Pin&lt;_, FunctionI2C, _&gt; = pins.gpio19.reconfigure();

let i2c = hal::I2C::i2c1(
    pac.I2C1,
    sda_pin,i2c1
    scl_pin, 
    400.kHz(),
    &amp;mut pac.RESETS,
    &amp;clocks.system_clock,
);
<span class="boring">}</span></code></pre>
<h3 id="prepare-display"><a class="header" href="#prepare-display">Prepare Display</a></h3>
<p>We create an interface for the OLED display using the I2C.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//helper struct is provided by the ssd1306 crate
let interface = I2CDisplayInterface::new(i2c);
// initialize the display
let mut display = Ssd1306::new(interface, DisplaySize128x64, DisplayRotation::Rotate0)
    .into_buffered_graphics_mode();
display.init().unwrap();
<span class="boring">}</span></code></pre>
<h3 id="set-text-style-and-draw"><a class="header" href="#set-text-style-and-draw">Set Text Style and Draw</a></h3>
<p>Next, we define the text style and use it to display “Hello Rust” on the screen:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Embedded graphics 
let text_style = MonoTextStyleBuilder::new()
    .font(&amp;FONT_6X10)
    .text_color(BinaryColor::On)
    .build();

Text::with_baseline("Hello, Rust!", Point::new(0, 16), text_style, Baseline::Top)
    .draw(&amp;mut display)
    .unwrap();
<span class="boring">}</span></code></pre>
<p>Here, we are writing the message at coordinates (x=0, y=16).</p>
<h3 id="write-out-data-to-a-display"><a class="header" href="#write-out-data-to-a-display">Write out data to a display</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>display.flush().unwrap();
<span class="boring">}</span></code></pre>
<h2 id="full-logic"><a class="header" href="#full-logic">Full logic</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sda_pin: Pin&lt;_, FunctionI2C, _&gt; = pins.gpio18.reconfigure();
let scl_pin: Pin&lt;_, FunctionI2C, _&gt; = pins.gpio19.reconfigure();

let i2c = hal::I2C::i2c1(
    pac.I2C1,
    sda_pin,
    scl_pin,
    400.kHz(),
    &amp;mut pac.RESETS,
    &amp;clocks.system_clock,
);

let interface = I2CDisplayInterface::new(i2c);

let mut display = Ssd1306::new(interface, DisplaySize128x64, DisplayRotation::Rotate0)
    .into_buffered_graphics_mode();

display.init().unwrap();
let text_style = MonoTextStyleBuilder::new()
    .font(&amp;FONT_6X10)
    .text_color(BinaryColor::On)
    .build();

Text::with_baseline("Hello, Rust!", Point::new(0, 16), text_style, Baseline::Top)
    .draw(&amp;mut display)
    .unwrap();

display.flush().unwrap();
loop {
    timer.delay_ms(500);
}
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-5"><a class="header" href="#clone-the-existing-project-5">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>hello-oled</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/hello-oled
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ferris-on-oled"><a class="header" href="#ferris-on-oled">Ferris on OLED</a></h1>
<p>In this task, we will display the <code>ferris.bmp</code>(<a href="oled/assets/ferris.bmp">Download</a> and put it in the project folder) file on the OLED screen.</p>
<img style="display: block; margin: auto;" alt="pico2" src="oled/assets/ferris.bmp" />
<p>Follow the same instructions as in the “Hello Rust” program, with just a few modifications.</p>
<p>First, we need to add the tinybmp crate to handle BMP file loading. Use the following Cargo command to include it in your project:</p>
<pre><code class="language-sh">cargo add tinybmp@0.6.0
</code></pre>
<h2 id="additional-imports-2"><a class="header" href="#additional-imports-2">Additional imports</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use embedded_graphics::image::Image;
use tinybmp::Bmp;
<span class="boring">}</span></code></pre>
<h2 id="difference"><a class="header" href="#difference">Difference</a></h2>
<p>After initializing the display, we will load the ferris.bmp file using the tinybmp crate, and then we will draw the image.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bmp = Bmp::from_slice(include_bytes!("../ferris.bmp")).unwrap();
let im = Image::new(&amp;bmp, Point::new(32, 0));
im.draw(&amp;mut display).unwrap();
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-6"><a class="header" href="#clone-the-existing-project-6">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>ferris-oled</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/ferris-oled
</code></pre>
<h2 id="useful-tools"><a class="header" href="#useful-tools">Useful tools</a></h2>
<ul>
<li>Bitmap to Rust array Converter: <a href="https://implferris.github.io/image2bytes/">Image2Bytes Generator</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="servo-motor-and-pwm"><a class="header" href="#servo-motor-and-pwm">Servo Motor and PWM</a></h1>
<p>In this section, we’ll connect an SG90 Micro Servo Motor to the Pico 2 and control its rotation using PWM. The servo will move in a loop, rotating from 0 degrees to 90 degrees, and then to 180 degrees.</p>
<p>Before moving forward, make sure you’ve read the <a href="#pulse-width-modulation-pwm">PWM introduction</a> in the Blink LED section.</p>
<h2 id="hardware-requirements-2"><a class="header" href="#hardware-requirements-2">Hardware Requirements</a></h2>
<ul>
<li><strong>SG90 Micro Servo Motor</strong></li>
<li><strong>Jumper Wires</strong>:
<ul>
<li><strong>Female-to-Male</strong>(or Male to Male depending on how you are connecting) jumper wires for connecting the Pico 2 to the servo motor pins (Ground, Power, and Signal).</li>
</ul>
</li>
</ul>
<h2 id="connection-overview"><a class="header" href="#connection-overview">Connection Overview</a></h2>
<ol>
<li><strong>Ground (GND)</strong>: Connect the servo’s GND pin (typically the <strong>brown</strong> wire, though it may vary) to any ground pin on the Pico 2.</li>
<li><strong>Power (VCC)</strong>: Connect the servo’s VCC pin (usually the <strong>red</strong> wire) to the Pico 2’s 5V (or 3.3V if required by your setup) power pin.</li>
<li><strong>Signal (PWM)</strong>: Connect the servo’s control (signal) pin to <strong>GPIO9</strong> on the Pico 2, configured for PWM. This is commonly the <strong>orange</strong> wire (may vary).</li>
</ol>
<table style="margin-bottom:20px">
  
<thead>
    
<tr>
      <th>Pico Pin</th>
      <th style="width: 250px; margin: 0 auto;">Wire</th>
      <th>Servo Motor</th>
      <th>Notes</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>VBUS</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire red" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>Power (Red Wire)</td>
      <td>Supplies 5V power to the servo.</td>
    </tr>

    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire brown" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>Ground (Brown Wire)</td>
      <td>Connects to ground.</td>
    </tr>

    
<tr>
      <td>GPIO 9</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire orange" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>Signal (Orange Wire)</td>
      <td>Receives PWM signal to control the servo's position.</td>
    </tr>

  </tbody>

</table>

<img style="display: block; margin: auto;" alt="pico2" src="servo/images/pico-servo-circuit.png" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="简介"><a href="#简介" class="header">简介</a></h1>
<h2 id="introduction-to-servo-motors"><a class="header" href="#introduction-to-servo-motors">Introduction to Servo Motors</a></h2>
<p>A servo motor controls movement by adjusting its position using a feedback system. It is guided by a signal, usually Pulse Width Modulation (PWM), to reach and maintain the desired position.</p>
<p>They are widely used in applications requiring precise motion, such as robotics, RC vehicles, and camera systems, as well as in various projects.  Hobby servos, which are often used in RC toys like cars, airplanes, are also popular for building robots.</p>
<p>In our exercise, we’ll be using the hobby server (Micro Servo SG90)</p>
<img style="display: block; margin: auto;" alt="pico2" src="servo/images/sg90-servo-motor.jpg" />
<h3 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h3>
<p>A servo motor is controlled by sending a series of pulses through its signal line. The signal has a frequency of 50Hz, with a pulse every 20 milliseconds. The width of the pulse determines the servo’s position. Typically, a servo can rotate 180 degrees.</p>
<h3 id="controlling-the-position"><a class="header" href="#controlling-the-position">Controlling the position</a></h3>
<p>The position of a servo motor is controlled by sending a pulse with a specific duration. The length of the pulse determines the angle of the motor. For most servos, a 1ms pulse moves the motor to 0 degrees, a 1.5ms pulse moves it to 90 degrees (neutral position), and a 2ms pulse moves it to 180 degrees.</p>
<img style="display: block; margin: auto;" alt="pico2" src="servo/images/servo-pwm.png" />
<p>However, from my experiment, I found that not all servos follow these exact timings. For example, with my servo, the pulse duration for 0 degrees was 0.5ms, 1.5ms for 90 degrees, and approximately 2.4ms for 180 degrees. I had to experiment and adjust to get it right. If you’re unsure, you can use tools like an oscilloscope to fine-tune it, or simply test different values to find what works best for your specific servo.</p>
<p>The example I’ll provide in this exercise is based on my servo’s configuration, you might need to adjust the values depending on the servo you’re using.</p>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<ul>
<li><a href="https://blog.wokwi.com/learn-servo-motor-using-wokwi-logic-analyzer/">Learn to Control Servo motor using PWM - Wokwi Style</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="更多-pwm-细节"><a href="#更多-pwm-细节" class="header">更多 PWM 细节</a></h1>
<h2 id="more-on-pwm"><a class="header" href="#more-on-pwm">More on PWM</a></h2>
<p>The servo motor we’re using operates at a 50Hz frequency, which means that a pulse is sent every 20 milliseconds (ms).</p>
<p>Let’s break this down further:</p>
<ul>
<li><strong>50Hz Frequency:</strong> Frequency refers to how many times an event happens in a given time period. A 50Hz frequency means that the servo expects a pulse to occur 50 times per second. In other words, the servo receives a pulse every 1/50th of a second, which is 20 milliseconds.</li>
<li><strong>20ms Time Interval:</strong> This 20ms is the time between each pulse. It means that every 20 milliseconds, the servo expects a new pulse to adjust its position. Within this 20ms period, the width of the pulse (how long it stays “high”) determines the angle at which the servo will move.</li>
</ul>
<p>So, when we say the servo operates at 50Hz, it means that the motor is constantly receiving pulses every 20ms to keep it in motion or adjust its position based on the width of each pulse.</p>
<h3 id="pulse-width-and-duty-cycle"><a class="header" href="#pulse-width-and-duty-cycle">Pulse Width and Duty Cycle</a></h3>
<p>Let’s dive deeper into how different pulse widths like 0.5ms, 1.5ms, and 2.4ms affect the servo’s position.</p>
<img style="display: block; margin: auto;" alt="pico2" src="servo/images/servo-position-pwm.jpg" />
<h4 id="1-05ms-pulse-position-0-degrees"><a class="header" href="#1-05ms-pulse-position-0-degrees">1. <strong>0.5ms Pulse (Position: 0 degrees)</strong></a></h4>
<ul>
<li>
<p><strong>What Happens</strong>: A 0.5ms pulse means the signal is “high” for 0.5 milliseconds within each 20ms cycle. The servo interprets this as a command to move to the 0-degree position.</p>
</li>
<li>
<p><strong>Duty Cycle</strong>: The duty cycle refers to the percentage of time the signal is “high” in one complete cycle. For a 0.5ms pulse:
\[
\text{Duty Cycle (%)} = \frac{0.5 \text{ms}}{20 \text{ms}} \times 100 = 2.5\%
\]</p>
<p>This means that for just 2.5% of each 20ms cycle, the signal stays “high” causing the servo to rotate to the 0-degree position.</p>
</li>
</ul>
<h4 id="2-15ms-pulse-position-90-degrees"><a class="header" href="#2-15ms-pulse-position-90-degrees">2. <strong>1.5ms Pulse (Position: 90 degrees)</strong></a></h4>
<ul>
<li><strong>What Happens</strong>: A 1.5ms pulse means the signal is “high” for 1.5 milliseconds in the 20ms cycle. The servo moves to its neutral position, around 90 degrees (middle position).</li>
<li><strong>Duty Cycle</strong>: For a 1.5ms pulse:
\[
\text{Duty Cycle (%)} = \frac{1.5 \text{ms}}{20 \text{ms}} \times 100 = 7.5\%
\]
Here, the signal stays “high” for 7.5% of the cycle, which positions the servo at 90 degrees (neutral).</li>
</ul>
<h4 id="3-24ms-pulse-position-180-degrees"><a class="header" href="#3-24ms-pulse-position-180-degrees">3. <strong>2.4ms Pulse (Position: 180 degrees)</strong></a></h4>
<ul>
<li><strong>What Happens</strong>: A 2.4ms pulse means the signal is “high” for 2.4 milliseconds in the 20ms cycle. The servo will move to its maximum position, typically 180 degrees (full rotation to one side).</li>
<li><strong>Duty Cycle</strong>: For a 2.4ms pulse:
\[
\text{Duty Cycle (%)} = \frac{2.4 \text{ms}}{20 \text{ms}} \times 100 = 12\%
\]
In this case, the signal is “high” for 12% of the cycle, which causes the servo to rotate to 180 degrees.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="舵机与-pico"><a href="#舵机与-pico" class="header">舵机与 Pico</a></h1>
<h2 id="servo-and-pico"><a class="header" href="#servo-and-pico">Servo and Pico</a></h2>
<p>To control a servo with the Raspberry Pi Pico, we need to set a 50Hz PWM frequency. Currently, RP-HAL doesn’t allow directly setting the frequency, so we achieve this by adjusting the <code>top</code> and <code>div_int</code> values.</p>
<p>Refer the 1073th page of the <a href="https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf">RP2350</a> Datasheet to understand how <code>top</code> and <code>div_int</code> works.</p>
<h3 id="formula-from-datasheet"><a class="header" href="#formula-from-datasheet">Formula from datasheet</a></h3>
<p>The following formula from the datasheet is used to calculate the period and determine the output frequency based on the system clock frequency.</p>
<ol>
<li>
<p><strong>Period calculation:</strong>
\[
\text{period} = (\text{TOP} + 1) \times (\text{CSR_PH_CORRECT} + 1) \times \left( \text{DIV_INT} + \frac{\text{DIV_FRAC}}{16} \right)
\]</p>
</li>
<li>
<p><strong>PWM output frequency calculation:</strong></p>
</li>
</ol>
<p>\[
f_{PWM} = \frac{f_{sys}}{\text{period}} = \frac{f_{sys}}{(\text{TOP} + 1) \times (\text{CSR_PH_CORRECT} + 1) \times \left( \text{DIV_INT} + \frac{\text{DIV_FRAC}}{16} \right)}
\]</p>
<p>Where:</p>
<ul>
<li>\( f_{PWM} \) is the PWM output frequency.</li>
<li>\( f_{sys} \) is the system clock frequency. For the pico2, it is is 150MHZ.</li>
</ul>
<h3 id="lets-calculate-top"><a class="header" href="#lets-calculate-top">Let’s calculate <code>top</code></a></h3>
<p>We want the PWM frequency (f_pwm) to be 50 Hz. In order to achieve that, we are going to adjust the <code>top</code> and <code>div_int</code> values.</p>
<p>The top value must be within the range of 0 to 65535 (since it’s a 16-bit unsigned integer). To make sure the top value fits within this range, I chose values for the divisor (div_int) in powers of 2 (such as 8, 16, 32, 64), though this isn’t strictly necessary (it’s just a preference). In this case, we chose <code>div_int = 64</code> to calculate a top value that fits within the u16 range.</p>
<p>With the chosen div_int and system parameters, we can calculate the top using the following formula:
\[
\text{top} = \frac{150,000,000}{50 \times 64} - 1
\]</p>
<p>\[
\text{top} = \frac{150,000,000}{3,200} - 1
\]</p>
<p>\[
\text{top} = 46,875 - 1
\]</p>
<p>\[
\text{top} = 46,874
\]</p>
<p>After performing the calculation, we find that the top value is <code>46,874</code>.</p>
<p>You can experiment with different div_int and corresponding top values. Just ensure that div_int stays within the u8 range, top fits within the u16 range, and the formula yields a 50Hz frequency.</p>
<p>Note:</p>
<ul>
<li>In case you are wondering, we are not setting the <code>div_frac</code> which is 0 by default. That’s why it is not included in the calculation.</li>
<li>We are not going to enable the phase correct for this exercise, so it also can be excluded from the calculation (since it is just multiplying by 1); if you enable phase correct, then the calculation will differ since you have to multiply by 2 (1+1)</li>
</ul>
<h3 id="position-calculation-based-on-top"><a class="header" href="#position-calculation-based-on-top">Position calculation based on top</a></h3>
<p>To calculate the duty cycle that corresponds to specific positions (0, 90, and 180 degrees), we use the following formula based on the top value:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PWM_DIV_INT: u8 = 64;
const PWM_TOP: u16 = 46_874;

const TOP: u16 = PWM_TOP + 1;
// 0.5ms is 2.5% of 20ms; 0 degrees in servo
const MIN_DUTY: u16 = (TOP as f64 * (2.5 / 100.)) as u16; 
// 1.5ms is 7.5% of 20ms; 90 degrees in servo
const HALF_DUTY: u16 = (TOP as f64 * (7.5 / 100.)) as u16; 
// 2.4ms is 12% of 20ms; 180 degree in servo
const MAX_DUTY: u16 = (TOP as f64 * (12. / 100.)) as u16;
<span class="boring">}</span></code></pre>
<p>We multiply the TOP value by a duty cycle percentage to determine the appropriate pulse width for each position of the servo. You might need to adjust the percentage based on your servo.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="实操"><a href="#实操" class="header">实操</a></h1>
<h2 id="action"><a class="header" href="#action">Action</a></h2>
<p>Setting Up the PWM and Servo Control</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PWM_DIV_INT: u8 = 64;
const PWM_TOP: u16 = 46_874;

const TOP: u16 = PWM_TOP + 1;
const MIN_DUTY: u16 = (TOP as f64 * (2.5 / 100.)) as u16;
const HALF_DUTY: u16 = (TOP as f64 * (7.5 / 100.)) as u16;
const MAX_DUTY: u16 = (TOP as f64 * (12. / 100.)) as u16;
<span class="boring">}</span></code></pre>
<h4 id="1-set-up-the-pwm-slice-and-channel"><a class="header" href="#1-set-up-the-pwm-slice-and-channel">1. Set Up the PWM Slice and Channel</a></h4>
<p>First, initialize the PWM slice and channel. You should have already done similar in the previous blinky section.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pwm_slices = hal::pwm::Slices::new(pac.PWM, &amp;mut pac.RESETS);
let pwm = &amp;mut pwm_slices.pwm4;
<span class="boring">}</span></code></pre>
<h3 id="2-adjust-for-50hz-frequency"><a class="header" href="#2-adjust-for-50hz-frequency">2. Adjust for 50HZ frequency</a></h3>
<p>Now, set the divisor and the top value to achieve a PWM frequency of 50Hz.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pwm.set_div_int(PWM_DIV_INT);
pwm.set_div_frac(0);

pwm.set_top(PWM_TOP);
pwm.enable();
<span class="boring">}</span></code></pre>
<h3 id="3-set-output-pin"><a class="header" href="#3-set-output-pin">3. Set Output Pin</a></h3>
<p>Next, specify the GPIO pin where the PWM signal will be sent. We will use GPIO pin 9.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let servo = &amp;mut pwm.channel_b;
    servo.output_to(pins.gpio9);

<span class="boring">}</span></code></pre>
<h3 id="4-set-servo-position-in-a-loop"><a class="header" href="#4-set-servo-position-in-a-loop">4. Set Servo Position in a Loop</a></h3>
<p>Finally, in the loop, we adjust the duty cycle which will control the servo’s position. We will move the servo to different positions (0°, 90°, and 180°) using the MIN_DUTY, HALF_DUTY, and MAX_DUTY values calculated earlier.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    servo.set_duty_cycle(MIN_DUTY).unwrap(); // 0 degrees
    timer.delay_ms(1000);

    servo.set_duty_cycle(HALF_DUTY).unwrap(); // 90 degrees
    timer.delay_ms(1000);

    servo.set_duty_cycle(MAX_DUTY).unwrap(); // 180 degrees
    timer.delay_ms(1000);
}

<span class="boring">}</span></code></pre>
<h3 id="full-code-snippet"><a class="header" href="#full-code-snippet">Full Code snippet</a></h3>
<pre class="playground"><code class="language-rust">const PWM_DIV_INT: u8 = 64;
const PWM_TOP: u16 = 46_874;

const TOP: u16 = PWM_TOP + 1;
const MIN_DUTY: u16 = (TOP as f64 * (2.5 / 100.)) as u16;
const HALF_DUTY: u16 = (TOP as f64 * (7.5 / 100.)) as u16;
const MAX_DUTY: u16 = (TOP as f64 * (12. / 100.)) as u16;

#[hal::entry]
fn main() -&gt; ! {
    // Grab our singleton objects
    let mut pac = hal::pac::Peripherals::take().unwrap();

    // Set up the watchdog driver - needed by the clock setup code
    let mut watchdog = hal::Watchdog::new(pac.WATCHDOG);

    // Configure the clocks
    // The default is to generate a 125 MHz system clock
    let clocks = hal::clocks::init_clocks_and_plls(
        XTAL_FREQ_HZ,
        pac.XOSC,
        pac.CLOCKS,
        pac.PLL_SYS,
        pac.PLL_USB,
        &amp;mut pac.RESETS,
        &amp;mut watchdog,
    )
    .ok()
    .unwrap();

    // The single-cycle I/O block controls our GPIO pins
    let sio = hal::Sio::new(pac.SIO);

    // Set the pins up according to their function on this particular board
    let pins = hal::gpio::Pins::new(
        pac.IO_BANK0,
        pac.PADS_BANK0,
        sio.gpio_bank0,
        &amp;mut pac.RESETS,
    );

    // The delay object lets us wait for specified amounts of time (in
    // milliseconds)
    let mut timer = hal::Timer::new_timer0(pac.TIMER0, &amp;mut pac.RESETS, &amp;clocks);

    // Init PWMs
    let mut pwm_slices = hal::pwm::Slices::new(pac.PWM, &amp;mut pac.RESETS);

    // Configure PWM4
    let pwm = &amp;mut pwm_slices.pwm4;

    pwm.set_div_int(PWM_DIV_INT);
    pwm.set_div_frac(0);

    pwm.set_top(PWM_TOP);
    pwm.enable();

    let servo = &amp;mut pwm.channel_b;
    servo.output_to(pins.gpio9);

    loop {
        servo.set_duty_cycle(MIN_DUTY).unwrap();
        timer.delay_ms(1000);
        servo.set_duty_cycle(HALF_DUTY).unwrap();
        timer.delay_ms(1000);
        servo.set_duty_cycle(MAX_DUTY).unwrap();
        timer.delay_ms(1000);
    }
}</code></pre>
<h2 id="clone-the-existing-project-7"><a class="header" href="#clone-the-existing-project-7">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>servo</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/servo
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="watchdog"><a class="header" href="#watchdog">Watchdog</a></h1>
<p>In January 1994, the Clementine spacecraft successfully mapped the moon. While traveling toward the asteroid Geographos, a floating point exception occurred on May 7, 1994, in the Honeywell 1750 processor, which was responsible for telemetry and various spacecraft functions.</p>
<img style="display: block; margin: auto;" width="400" alt="pico2" src="images/homer-panic.jpg" />
<p>The 1750 had a built-in watchdog timer but it was not utilized. The software team later regretted this decision and noted that a standard watchdog might not have been robust enough to detect the failure mode.</p>
<p>So, What exactly is a watchdog?</p>
<p>You might have already figured out its purpose.</p>
<h2 id="what-is-watchdog"><a class="header" href="#what-is-watchdog">What is watchdog?</a></h2>
<p>A watchdog timer (WDT) is a hardware component used in embedded systems, its primary purpose is to detect software anomalies and automatically reset the processor if a malfunction occurs, ensuring that the system can recover without human intervention.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works?</a></h2>
<p>The watchdog timer functions like a counter that counts down from a preset value to zero. The embedded software is responsible for periodically “feeding the dog” (also known as “kicking the dog,” a term I don’t like) by resetting the counter before it reaches zero. If the software fails to reset the counter (perhaps due to an infinite loop or a system hang), the watchdog timer assumes there’s a problem and triggers a reset of the processor. This allows the system to restart and return to normal operation.</p>
<p><strong>Feeding the dog:</strong></p>
<p>Think of a watchdog timer like a dog that needs regular feeding to stay healthy and active. Just as you must feed your dog at scheduled intervals, the watchdog timer requires periodic resets to ensure that the embedded system is operating correctly. Imagine the dog’s energy levels decreasing over time. If it runs out of energy, it will bark to alert you (just like the watchdog timer triggers an alert if it reaches zero). To keep the dog happy and active, you need to feed it regularly (or reset the timer) before it runs out of energy!</p>
<img style="display: block; margin: auto;" width="400" alt="pico2" src="images/watchdog.jpg" />
<p>By implementing a watchdog timer, embedded systems can be made self-reliant, essential for devices that may be unreachable by human operators, such as space probes or other remote applications.</p>
<h2 id="code-2"><a class="header" href="#code-2">Code</a></h2>
<p>In this code snippet, we were setting up the watchdog driver, which is essential for the clock setup process.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set up the watchdog driver - needed by the clock setup code
let mut watchdog = hal::Watchdog::new(pac.WATCHDOG);
<span class="boring">}</span></code></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://www.ganssle.com/watchdogs.pdf">Great Watchdog Timers For Embedded Systems, by Jack Ganssle</a></li>
<li><a href="https://www.embedded.com/born-to-fail/">Born to fail</a></li>
<li><a href="https://interrupt.memfault.com/blog/firmware-watchdog-best-practices">A Guide to Watchdog Timers for Embedded Systems</a></li>
<li><a href="https://betterembsw.blogspot.com/2014/05/proper-watchdog-timer-use.html">Proper Watchdog Timer Use</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="buzzinga"><a class="header" href="#buzzinga">Buzzinga</a></h1>
<p>In this section, we’ll explore some fun activities using the <code>buzzer</code>. I chose the title “Buzzinga” just for fun (a nod to Sheldon’s “Bazinga” in <em>The Big Bang Theory</em>); it’s not a technical term.</p>
<ul>
<li><strong>Passive Buzzer</strong></li>
<li><strong>Jumper Wires</strong>:
<ul>
<li><strong>Female-to-Male</strong> jumper wires for connecting the Pico 2 to the buzzer pins (Positive and Ground).</li>
</ul>
</li>
</ul>
<p>The buzzer has two pins:  Positive(Signal), Ground; The positive side of the buzzer is typically marked with a <strong>+</strong> symbol and is the longer pin, while the negative side (ground) is the shorter pin, similar to an LED. However, some passive buzzers may allow for either pin to be connected to ground or signal, depending on the specific model.</p>
<p>By the way, I used an active buzzer in my experiment. A passive buzzer is recommended if you plan to play different sounds, as it provides a better tone.</p>
<h2 id="connection-overview-1"><a class="header" href="#connection-overview-1">Connection Overview</a></h2>
<table style="margin-bottom:20px">
  
<thead>
    
<tr>
      <th>Pico Pin</th>
      <th style="width: 250px; margin: 0 auto;">Wire</th>
      <th>Buzzer Pin</th>
      <th>Notes</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>GPIO 15</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire red" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>Positive Pin</td>
      <td>Receives PWM signals to produce sound.</td>
    </tr>

    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>Ground Pin</td>
      <td>Connects to ground.</td>
    </tr>

  </tbody>

</table>

<img style="display: block; margin: auto;" alt="pico2" src="buzzer/images/pico-buzzer-circuit.png" />
<p>Before moving forward, make sure you’ve read the following sections and understood the concepts.</p>
<ul>
<li><a href="#pulse-width-modulation-pwm">PWM introduction</a> in the Blink LED section</li>
<li><a href="#更多-pwm-细节">More on PWM</a> in the servo section</li>
<li><a href="#舵机与-pico">Calculating top</a> in the servo section</li>
</ul>
<h2 id="reference-1"><a class="header" href="#reference-1">Reference</a></h2>
<ul>
<li><a href="https://projects.raspberrypi.org/en/projects/introduction-to-the-pico/9">Pico official guide on buzzer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="蜂鸣器简介"><a href="#蜂鸣器简介" class="header">蜂鸣器简介</a></h1>
<h2 id="introduction-to-buzzer"><a class="header" href="#introduction-to-buzzer">Introduction to Buzzer</a></h2>
<p>A buzzer is an electronic device used to generate sound, beeps, or even melodies, and is commonly found in alarm systems, timers, computers, and for confirming user inputs, such as mouse clicks or keystrokes. Buzzers serve as audio signaling devices, providing audible feedback for various actions.</p>
<h2 id="active-buzzer-vs-passive-buzzer"><a class="header" href="#active-buzzer-vs-passive-buzzer">Active Buzzer vs Passive Buzzer</a></h2>
<h3 id="active-buzzer"><a class="header" href="#active-buzzer">Active Buzzer:</a></h3>
<ul>
<li>
<p><strong>Built-in Oscillator</strong>: An active buzzer has an internal oscillator that generates the tone automatically when power is applied. You can identify whether you have active buzzer or not by connecting the buzzer directly to the battery and it will make a sound.</p>
</li>
<li>
<p><strong>Simpler Usage</strong>: No need to worry about generating specific frequencies since the buzzer does it internally.</p>
</li>
<li>
<p><strong>Tone</strong>: Typically produces a single tone or a fixed frequency.
<img style="display: block; margin: auto;" alt="pico2" src="buzzer/images/active-buzzer.png" /></p>
</li>
<li>
<p><strong>How to identify</strong>: Usually has a white covering on top and a black smooth finish at the bottom. It produces sound when connected directly to a battery.</p>
</li>
</ul>
<h3 id="passive-buzzer"><a class="header" href="#passive-buzzer">Passive Buzzer:</a></h3>
<ul>
<li><strong>External Signal Required</strong>: A passive buzzer requires an external signal (usually a square wave) to generate sound. It does not have an internal oscillator, so it relies on a microcontroller to provide a frequency.</li>
<li><strong>Flexible Tones</strong>: You can control the frequency and create different tones, melodies, or alarms based on the input signal.</li>
</ul>
<img style="display: block; margin: auto;" alt="pico2" src="buzzer/images/passive-buzzer.png" />
<ul>
<li><strong>How to identify</strong>: Typically has no covering on the top and looks like a PCB-style blue or green covering at the bottom.</li>
</ul>
<h2 id="which-one-"><a class="header" href="#which-one-">Which one ?</a></h2>
<h3 id="choose-active-buzzer-if"><a class="header" href="#choose-active-buzzer-if">Choose <strong>Active Buzzer</strong> if:</a></h3>
<ul>
<li>You need a simple, fixed tone or beep. It’s ideal for basic alerts, alarms, or user input confirmation.</li>
</ul>
<h3 id="choose-passive-buzzer-if"><a class="header" href="#choose-passive-buzzer-if">Choose <strong>Passive Buzzer</strong> if:</a></h3>
<ul>
<li>You want to generate different tones, melodies, or sound patterns.</li>
</ul>
<p>It is recommended to use a passive buzzer for our exercises. However, if you only have an active buzzer, don’t worry; you can still use it. In fact, I personally used an active buzzer for this.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="beep"><a class="header" href="#beep">Beep</a></h1>
<p>In this exercise, we will generate a beeping sound with a 50% duty cycle, followed by a 0% duty cycle, creating a looping pattern of sound and silence. We will use the A4 note (440Hz frequency) for this. (If you’re not familiar with the A4 note, please look up more information on musical notes.)</p>
<h3 id="get-top-function"><a class="header" href="#get-top-function">Get Top function</a></h3>
<p>In the previous exercise (servo motor), we manually calculated and hardcoded the top value. In this exercise, we create a small function to calculate the top value based on the target frequency and div_int:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn get_top(freq: f64, div_int: u8) -&gt; u16 {
    let result = 150_000_000. / (freq * div_int as f64);
    result as u16 - 1
}
<span class="boring">}</span></code></pre>
<h3 id="div_int-value"><a class="header" href="#div_int-value"><code>div_int</code> value</a></h3>
<p>We will be using 64 as <code>div_int</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PWM_DIV_INT: u8 = 64;
<span class="boring">}</span></code></pre>
<h3 id="configure-the-gpio-15-pin"><a class="header" href="#configure-the-gpio-15-pin">Configure the GPIO 15 pin</a></h3>
<p>Next, we need to configure the GPIO pin (GPIO 15) to output the PWM signal.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pwm = &amp;mut pwm_slices.pwm7;
pwm.enable();
pwm.set_div_int(PWM_DIV_INT);
pwm.channel_b.output_to(pins.gpio15);
<span class="boring">}</span></code></pre>
<h3 id="to-set-a-frequency-440hza4-note"><a class="header" href="#to-set-a-frequency-440hza4-note">To Set a frequency 440Hz(A4 Note)</a></h3>
<p>Now we calculate the top value required to generate the 440Hz frequency (A4 note) and set it for the PWM:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let top = get_top(440., PWM_DIV_INT);
pwm.set_top(top);
<span class="boring">}</span></code></pre>
<h2 id="loop"><a class="header" href="#loop">Loop</a></h2>
<p>Finally, we create a loop to alternate between a 50% duty cycle (beep) and a 0% duty cycle (silence). The loop repeats with a delay of 500 milliseconds between each change:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    pwm.channel_b.set_duty_cycle_percent(50).unwrap();
    timer.delay_ms(500);
    pwm.channel_b.set_duty_cycle(0).unwrap();
    timer.delay_ms(500);
}
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-8"><a class="header" href="#clone-the-existing-project-8">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>beep</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/beep
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="got-buzzer"><a class="header" href="#got-buzzer">GOT Buzzer?</a></h1>
<p>We are going to play the Game of Thrones (GOT) background music (BGM) on the buzzer, thanks to the awesome <a href="https://github.com/robsoncouto/arduino-songs">arduino-songs</a> repository. It also has other bgms.</p>
<p>If you’re unsure about musical notes and sheet music, feel free to check out the quick theory I’ve provideded <a href="#音符">here</a>.</p>
<p>I’ve splitted the code into rust module(you can do it in single file as we have done so far): <a href="#music-module"><code>music</code></a>, <a href="#melody-example-game-of-thrones-theme"><code>got</code></a>.</p>
<h3 id="reference-2"><a class="header" href="#reference-2">Reference</a></h3>
<ul>
<li><a href="https://github.com/robsoncouto/arduino-songs">arduino-songs repo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="音符"><a href="#音符" class="header">音符</a></h1>
<h2 id="introduction-to-music-notes-and-sheet-music"><a class="header" href="#introduction-to-music-notes-and-sheet-music">Introduction to Music Notes and Sheet Music</a></h2>
<p>This is a brief guide to music notes and sheet music. While it may not cover everything, it provides a quick reference for key concepts.</p>
<h3 id="music-sheet"><a class="header" href="#music-sheet">Music Sheet</a></h3>
<p>The notes for the music are based on the following sheet. You can refer to this <a href="https://musescore.com/user/8407786/scores/2156716">Musescore</a> link for more details.</p>
<img style="display: block; margin: auto;" alt="pico2" src="buzzer/images/got-sheet.png" />
<p>In music, note durations are represented by the following types, which define how long each note is played:</p>
<ul>
<li><strong>Whole note</strong>: The longest note duration, lasting for 4 beats.</li>
<li><strong>Half note</strong>: A note that lasts for 2 beats.</li>
<li><strong>Quarter note</strong>: A note that lasts for 1 beat.</li>
<li><strong>Eighth note</strong>: A note that lasts for half a beat, or 1/8th of the duration of a whole note.</li>
<li><strong>Sixteenth note</strong>: A note that lasts for a quarter of a beat, or 1/16th of the duration of a whole note.</li>
</ul>
<h3 id="dotted-notes"><a class="header" href="#dotted-notes">Dotted Notes</a></h3>
<p>A dotted note is a note that has a dot next to it. The dot increases the note’s duration by half of its original value. For example:</p>
<ul>
<li><strong>Dotted half note</strong>: A half note with a dot lasts for 3 beats (2 + 1).</li>
<li><strong>Dotted quarter note</strong>: A quarter note with a dot lasts for 1.5 beats (1 + 0.5).</li>
</ul>
<h3 id="tempo-and-bpm-beats-per-minute"><a class="header" href="#tempo-and-bpm-beats-per-minute">Tempo and BPM (Beats Per Minute)</a></h3>
<p>Tempo refers to the speed at which a piece of music is played. It is usually measured in <strong>beats per minute</strong> (BPM), indicating how many beats occur in one minute.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="music-module"><a class="header" href="#music-module">Music module</a></h1>
<p>In the music module, we define constants for common notes and their corresponding frequency values.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note frequencies in Hertz as f64
pub const NOTE_B0: f64 = 31.0;
pub const NOTE_C1: f64 = 33.0;
pub const NOTE_CS1: f64 = 35.0;
pub const NOTE_D1: f64 = 37.0;
pub const NOTE_DS1: f64 = 39.0;
pub const NOTE_E1: f64 = 41.0;
pub const NOTE_F1: f64 = 44.0;
pub const NOTE_FS1: f64 = 46.0;
pub const NOTE_G1: f64 = 49.0;
pub const NOTE_GS1: f64 = 52.0;
pub const NOTE_A1: f64 = 55.0;
pub const NOTE_AS1: f64 = 58.0;
pub const NOTE_B1: f64 = 62.0;
pub const NOTE_C2: f64 = 65.0;
pub const NOTE_CS2: f64 = 69.0;
pub const NOTE_D2: f64 = 73.0;
pub const NOTE_DS2: f64 = 78.0;
pub const NOTE_E2: f64 = 82.0;
pub const NOTE_F2: f64 = 87.0;
pub const NOTE_FS2: f64 = 93.0;
pub const NOTE_G2: f64 = 98.0;
pub const NOTE_GS2: f64 = 104.0;
pub const NOTE_A2: f64 = 110.0;
pub const NOTE_AS2: f64 = 117.0;
pub const NOTE_B2: f64 = 123.0;
pub const NOTE_C3: f64 = 131.0;
pub const NOTE_CS3: f64 = 139.0;
pub const NOTE_D3: f64 = 147.0;
pub const NOTE_DS3: f64 = 156.0;
pub const NOTE_E3: f64 = 165.0;
pub const NOTE_F3: f64 = 175.0;
pub const NOTE_FS3: f64 = 185.0;
pub const NOTE_G3: f64 = 196.0;
pub const NOTE_GS3: f64 = 208.0;
pub const NOTE_A3: f64 = 220.0;
pub const NOTE_AS3: f64 = 233.0;
pub const NOTE_B3: f64 = 247.0;
pub const NOTE_C4: f64 = 262.0;
pub const NOTE_CS4: f64 = 277.0;
pub const NOTE_D4: f64 = 294.0;
pub const NOTE_DS4: f64 = 311.0;
pub const NOTE_E4: f64 = 330.0;
pub const NOTE_F4: f64 = 349.0;
pub const NOTE_FS4: f64 = 370.0;
pub const NOTE_G4: f64 = 392.0;
pub const NOTE_GS4: f64 = 415.0;
pub const NOTE_A4: f64 = 440.0;
pub const NOTE_AS4: f64 = 466.0;
pub const NOTE_B4: f64 = 494.0;
pub const NOTE_C5: f64 = 523.0;
pub const NOTE_CS5: f64 = 554.0;
pub const NOTE_D5: f64 = 587.0;
pub const NOTE_DS5: f64 = 622.0;
pub const NOTE_E5: f64 = 659.0;
pub const NOTE_F5: f64 = 698.0;
pub const NOTE_FS5: f64 = 740.0;
pub const NOTE_G5: f64 = 784.0;
pub const NOTE_GS5: f64 = 831.0;
pub const NOTE_A5: f64 = 880.0;
pub const NOTE_AS5: f64 = 932.0;
pub const NOTE_B5: f64 = 988.0;
pub const NOTE_C6: f64 = 1047.0;
pub const NOTE_CS6: f64 = 1109.0;
pub const NOTE_D6: f64 = 1175.0;
pub const NOTE_DS6: f64 = 1245.0;
pub const NOTE_E6: f64 = 1319.0;
pub const NOTE_F6: f64 = 1397.0;
pub const NOTE_FS6: f64 = 1480.0;
pub const NOTE_G6: f64 = 1568.0;
pub const NOTE_GS6: f64 = 1661.0;
pub const NOTE_A6: f64 = 1760.0;
pub const NOTE_AS6: f64 = 1865.0;
pub const NOTE_B6: f64 = 1976.0;
pub const NOTE_C7: f64 = 2093.0;
pub const NOTE_CS7: f64 = 2217.0;
pub const NOTE_D7: f64 = 2349.0;
pub const NOTE_DS7: f64 = 2489.0;
pub const NOTE_E7: f64 = 2637.0;
pub const NOTE_F7: f64 = 2794.0;
pub const NOTE_FS7: f64 = 2960.0;
pub const NOTE_G7: f64 = 3136.0;
pub const NOTE_GS7: f64 = 3322.0;
pub const NOTE_A7: f64 = 3520.0;
pub const NOTE_AS7: f64 = 3729.0;
pub const NOTE_B7: f64 = 3951.0;
pub const NOTE_C8: f64 = 4186.0;
pub const NOTE_CS8: f64 = 4435.0;
pub const NOTE_D8: f64 = 4699.0;
pub const NOTE_DS8: f64 = 4978.0;
pub const REST: f64 = 0.0; // No sound, for pauses
<span class="boring">}</span></code></pre>
<p>Next, we create small helper <code>struct</code> to to represent a musical Song and provide some functions to calculate note durations based on tempo.</p>
<p>This struct has a single field whole_note, which will store the duration of a whole note in milliseconds. The reason we store the duration in milliseconds is that musical timing is often based on tempo (beats per minute, BPM), and we need to calculate how long each note lasts in terms of time.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>
pub struct Song {
    whole_note: u32,
}
<span class="boring">}</span></code></pre>
<p>The formula (60_000 * 4) / tempo as u32 calculates the duration of a whole note in milliseconds. We use 60_000 because there are 60,000 milliseconds in a minute, and we multiply by 4 because a whole note is typically equivalent to four beats.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Song {
    pub fn new(tempo: u16) -&gt; Self {
        let whole_note = (60_000 * 4) / tempo as u32;
        Self { whole_note }
    }
<span class="boring">}</span></code></pre>
<h3 id="calc_note_duration"><a class="header" href="#calc_note_duration"><code>calc_note_duration</code></a></h3>
<p>The <code>calc_note_duration</code> function calculates the duration of a musical note based on its division relative to a whole note. It takes in a <code>divider</code> parameter, which can be positive or negative, and returns the duration of the note in milliseconds.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn calc_note_duration(&amp;self, divider: i16) -&gt; u32 {
        if divider &gt; 0 {
            self.whole_note / divider as u32
        } else {
            let duration = self.whole_note / divider.unsigned_abs() as u32;
            (duration as f64 * 1.5) as u32
        }
    }
}
<span class="boring">}</span></code></pre>
<h4 id="logic"><a class="header" href="#logic">Logic:</a></h4>
<ol>
<li>
<p><strong>When <code>divider &gt; 0</code>:</strong></p>
<ul>
<li>If the <code>divider</code> is positive, the function calculates the note’s duration by dividing the duration of a whole note by the <code>divider</code>.</li>
<li>For example, if <code>divider = 4</code>, the function calculates the duration of a quarter note, which is 1/4 of a whole note.</li>
</ul>
</li>
<li>
<p><strong>When <code>divider &lt;= 0</code>:</strong></p>
<ul>
<li>If the <code>divider</code> is negative, the function first converts the <code>divider</code> to a positive value using <code>unsigned_abs()</code>.</li>
<li>It divides the whole note’s duration by this absolute value, then multiplies the result by <strong>1.5</strong> to account for <strong>dotted notes</strong> (e.g., dotted quarter note, dotted eighth note), which last 1.5 times the duration of a regular note.</li>
</ul>
</li>
</ol>
<p>This positive and negative logic is a custom approach (based on an Arduino example I referred to) to differentiate dotted notes. It is not related to standard musical logic.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="melody-example-game-of-thrones-theme"><a class="header" href="#melody-example-game-of-thrones-theme">Melody Example: Game of Thrones Theme</a></h1>
<p>These section contains code snippets for the rust module <code>got</code>.</p>
<h3 id="tempo"><a class="header" href="#tempo">Tempo</a></h3>
<p>we declare the tempo for the song(you can also change and observe the result).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const TEMPO: u16 = 85;
<span class="boring">}</span></code></pre>
<h2 id="melody-array"><a class="header" href="#melody-array">Melody Array</a></h2>
<p>We define the melody of the Game of Thrones theme using the notes and durations in an array. The melody consists of tuple of note frequencies and their corresponding durations. The duration of each note is represented by an integer, where positive values represent normal notes and negative values represent dotted notes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const MELODY: [(f64, i16); 92] = [
    // Game of Thrones Theme
    (NOTE_G4, 8),
    (NOTE_C4, 8),
    (NOTE_DS4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, 8),
    (NOTE_C4, 8),
    (NOTE_DS4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, 8),
    (NOTE_C4, 8),
    (NOTE_DS4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, 8),
    (NOTE_C4, 8),
    (NOTE_DS4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, 8),
    (NOTE_C4, 8),
    (NOTE_E4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, 8),
    (NOTE_C4, 8),
    (NOTE_E4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, 8),
    (NOTE_C4, 8),
    (NOTE_E4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, 8),
    (NOTE_C4, 8),
    (NOTE_E4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, -4),
    (NOTE_C4, -4),
    (NOTE_DS4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, 4),
    (NOTE_C4, 4),
    (NOTE_DS4, 16),
    (NOTE_F4, 16),
    (NOTE_D4, -1),
    (NOTE_F4, -4),
    (NOTE_AS3, -4),
    (NOTE_DS4, 16),
    (NOTE_D4, 16),
    (NOTE_F4, 4),
    (NOTE_AS3, -4),
    (NOTE_DS4, 16),
    (NOTE_D4, 16),
    (NOTE_C4, -1),
    // Repeat
    (NOTE_G4, -4),
    (NOTE_C4, -4),
    (NOTE_DS4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, 4),
    (NOTE_C4, 4),
    (NOTE_DS4, 16),
    (NOTE_F4, 16),
    (NOTE_D4, -1),
    (NOTE_F4, -4),
    (NOTE_AS3, -4),
    (NOTE_DS4, 16),
    (NOTE_D4, 16),
    (NOTE_F4, 4),
    (NOTE_AS3, -4),
    (NOTE_DS4, 16),
    (NOTE_D4, 16),
    (NOTE_C4, -1),
    (NOTE_G4, -4),
    (NOTE_C4, -4),
    (NOTE_DS4, 16),
    (NOTE_F4, 16),
    (NOTE_G4, 4),
    (NOTE_C4, 4),
    (NOTE_DS4, 16),
    (NOTE_F4, 16),
    (NOTE_D4, -2),
    (NOTE_F4, -4),
    (NOTE_AS3, -4),
    (NOTE_D4, -8),
    (NOTE_DS4, -8),
    (NOTE_D4, -8),
    (NOTE_AS3, -8),
    (NOTE_C4, -1),
    (NOTE_C5, -2),
    (NOTE_AS4, -2),
    (NOTE_C4, -2),
    (NOTE_G4, -2),
    (NOTE_DS4, -2),
    (NOTE_DS4, -4),
    (NOTE_F4, -4),
    (NOTE_G4, -1),
];
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="播放"><a href="#播放" class="header">播放</a></h1>
<h2 id="playing-the-game-of-thrones-melody"><a class="header" href="#playing-the-game-of-thrones-melody">Playing the Game of Thrones Melody</a></h2>
<p>This section demonstrates how to play the Game of Thrones melody using PWM (Pulse Width Modulation) for generating the tones and timing the note durations. The code calculates the duration of each note, sets the PWM duty cycle, and controls the timing to ensure proper pauses between notes.</p>
<h3 id="song-object"><a class="header" href="#song-object">Song object</a></h3>
<p>This creates a new Song object using the tempo value from got::TEMPO, which is set to 85 BPM.  The Song object will manage the note durations based on the tempo.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let song = Song::new(got::TEMPO);
<span class="boring">}</span></code></pre>
<h2 id="playing-the-notes"><a class="header" href="#playing-the-notes">Playing the notes</a></h2>
<p>This loop iterates over the muisc-notes array. Each item in the melody is a tuple containing a note and its duration type (e.g., quarter note, eighth note).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (note, duration_type) in got::MELODY {
        let top = get_top(note, PWM_DIV_INT);
        pwm.set_top(top);

        let note_duration = song.calc_note_duration(duration_type);
        let pause_duration = note_duration / 10; // 10% of note_duration

        pwm.channel_b.set_duty_cycle_percent(50).unwrap(); // Set duty cycle to 50% to play the note

        timer.delay_ms(note_duration - pause_duration); // Play 90%
        pwm.channel_b.set_duty_cycle(0).unwrap(); // Stop tone
        timer.delay_ms(pause_duration); // Pause for 10%
    }

<span class="boring">}</span></code></pre>
<p>First, we calculate the top value based on the note frequency. This sets the PWM frequency to match the target note.</p>
<p>Next, the <code>calc_note_duration</code> function is used to determine how long each note should be played. We also calculate the pause duration as 10% of the note duration. The 90% duration ensures that the note is played clearly, while the 10% pause creates a small gap between notes, resulting in a cleaner and more distinct melody.</p>
<h3 id="keeping-the-program-running"><a class="header" href="#keeping-the-program-running">Keeping the Program Running</a></h3>
<p>This loop keeps the program running indefinitely, as required by the main function’s signature. The main function has a -&gt; ! return type, meaning it doesn’t return.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    // Keep the program running
    timer.delay_ms(500);
}
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-9"><a class="header" href="#clone-the-existing-project-9">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>got-buzzer</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/got-buzzer
</code></pre>
<h2 id="wokwi-project"><a class="header" href="#wokwi-project">Wokwi Project</a></h2>
<p>An Arduino version of this exercise is available on the Wokwi site with the Pico board. Unfortunately, the site currently does not support coding in Rust for the Pico. However, you can refer to this project to understand how it works.</p>
<p><a href="https://wokwi.com/projects/414268602809291777">Project Link </a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="有源蜂鸣"><a href="#有源蜂鸣" class="header">有源蜂鸣</a></h1>
<h2 id="beeping-with-an-active-buzzer"><a class="header" href="#beeping-with-an-active-buzzer">Beeping with an Active Buzzer</a></h2>
<p>Since you already know that an active buzzer is simple to use, you can make it beep just by powering it. In this exercise, we’ll make it beep with just a little code.</p>
<h3 id="hardware-requirements-3"><a class="header" href="#hardware-requirements-3">Hardware Requirements</a></h3>
<ul>
<li><strong>Active Buzzer</strong></li>
<li><strong>Female-to-Male</strong> or <strong>Male-to-Male</strong> (depending on your setup)</li>
</ul>
<p>We’ll use the Embassy HAL for this project.</p>
<h2 id="project-from-template"><a class="header" href="#project-from-template">Project from template</a></h2>
<p>To set up the project, run:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.1.0
</code></pre>
<p>When prompted, give your project a name, like “active-beep” and select <code>embassy</code> as the HAL.</p>
<p>Then, navigate into the project folder:</p>
<pre><code class="language-sh">cd PROJECT_NAME
# For example, if you named your project "active-beep":
# cd active-beep
</code></pre>
<p>All you need to do is change the output pin from 25 to 15 in the template code.</p>
<pre class="playground"><code class="language-rust">// Active Buzzer
#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let p = embassy_rp::init(Default::default());
    let mut buzzer = Output::new(p.PIN_15, Level::Low); // Changed PIN number to 15

    loop {
        buzzer.set_high();
        Timer::after_millis(500).await;

        buzzer.set_low();
        Timer::after_millis(500).await;
    }
}</code></pre>
<h2 id="clone-the-existing-project-10"><a class="header" href="#clone-the-existing-project-10">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>active-beep</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-embassy-projects
cd pico2-embassy-projects/active-beep
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ldr-光敏电阻"><a href="#ldr-光敏电阻" class="header">LDR 光敏电阻</a></h1>
<h2 id="ldr-light-dependent-resistor"><a class="header" href="#ldr-light-dependent-resistor">LDR (Light Dependent Resistor)</a></h2>
<p>In this section, we will use an LDR (Light Dependent Resistor) with the Raspberry Pi Pico 2. An LDR changes its resistance based on the amount of light falling on it. The brighter the light, the lower the resistance, and the dimmer the light, the higher the resistance. This makes it ideal for applications like light sensing, automatic lighting, or monitoring ambient light levels.</p>
<img style="display: block; margin: auto;" alt="pico2" src="ldr/images/ldr.png" />
<h2 id="components-needed"><a class="header" href="#components-needed">Components Needed:</a></h2>
<ul>
<li>LDR (Light Dependent Resistor)</li>
<li>Resistor (typically 10kΩ); needed to create voltage divider</li>
<li>Jumper wires (as usual)</li>
</ul>
<h2 id="prerequisite-1"><a class="header" href="#prerequisite-1">Prerequisite</a></h2>
<p>To work with this, you should get familiar with what a voltage divider is and how it works. You also need to understand what ADC is and how it functions.</p>
<ul>
<li><a href="#voltage-divider">Voltage divider section</a>.</li>
<li><a href="#adc-analog-to-digital-converter">ADC</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="什么是-ldr"><a href="#什么是-ldr" class="header">什么是 LDR</a></h1>
<h2 id="how-ldr-works"><a class="header" href="#how-ldr-works">How LDR works?</a></h2>
<p>We have already given an introduction to what an LDR is. Let me repeat it again: an LDR changes its resistance based on the amount of light falling on it. The brighter the light, the lower the resistance, and the dimmer the light, the higher the resistance.</p>
<p>Dracula: Think of the LDR as Dracula. In sunlight, he gets weaker (just like the resistance gets lower). But in the dark, he gets stronger (just like the resistance gets higher).</p>
<p>We will not cover what kind of semiconductor materials are used to make an LDR, nor why it behaves this way in depth. I recommend you read this <a href="https://www.elprocus.com/ldr-light-dependent-resistor-circuit-and-working/">article</a> and do further research if you are interested.</p>
<h2 id="simulation-of-ldr-in-voltage-divider"><a class="header" href="#simulation-of-ldr-in-voltage-divider">Simulation of LDR in Voltage Divider</a></h2>
<p>I have created a voltage divider circuit with an LDR(a resistor symbol with arrows, kind of indicating light shining on it) in Falstad . You can import the circuit file I created, <a href="ldr/voltage-divider-ldr.circuitjs.txt"><code>voltage-divider-ldr.circuitjs.txt</code></a>, import into the <a href="https://www.falstad.com/circuit/e-voltdivide.html">Falstad site</a> and play around.</p>
<p>You can adjust the brightness value and observe how the resistance of R2 (which is the LDR) changes. Also, you can watch how the \( V_{out} \) voltage changes as you increase or decrease the brightness.</p>
<h3 id="example-output-for-full-brightness"><a class="header" href="#example-output-for-full-brightness">Example output for full brightness</a></h3>
<p>The resistance of the LDR is low when exposed to full brightness, causing the output voltage(\( V_{out} \)) to be significantly lower.</p>
<img style="display: block; margin: auto;" alt="voltage-divider-ldr1" src="ldr/images/voltage-divider-ldr1.png" />
<h3 id="example-output-for-low-light"><a class="header" href="#example-output-for-low-light">Example output for low light</a></h3>
<p>With less light, the resistance of the LDR increases and the output voltage increase.</p>
<img style="display: block; margin: auto;" alt="voltage-divider-ldr2" src="ldr/images/voltage-divider-ldr2.png" />
<h3 id="example-output-for-full-darkness"><a class="header" href="#example-output-for-full-darkness">Example output for full darkness</a></h3>
<p>In darkness, the LDR’s resistance is high, resulting in a higher output voltage (\( V_{out} \)).</p>
<img style="display: block; margin: auto;" alt="voltage-divider-ldr3" src="ldr/images/voltage-divider-ldr3.png" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ldr-与-led"><a href="#ldr-与-led" class="header">LDR 与 LED</a></h1>
<h2 id="turn-on-ledor-lamp-in-low-light-with-pico"><a class="header" href="#turn-on-ledor-lamp-in-low-light-with-pico">Turn on LED(or Lamp) in low Light with Pico</a></h2>
<p>In this exercise, we’ll control an LED based on ambient light levels. The goal is to automatically turn on the LED in low light conditions.</p>
<p>You can try this in a closed room by turning the room light on and off. When you turn off the room-light, the LED should turn on, given that the room is dark enough, and turn off again when the room-light is switched back on. Alternatively, you can adjust the sensitivity threshold or cover the light sensor (LDR) with your hand or some object to simulate different light levels.</p>
<p>Note: You may need to adjust the ADC threshold based on your room’s lighting conditions and the specific LDR you are using.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<h2 id="hardware-requirements-4"><a class="header" href="#hardware-requirements-4">Hardware Requirements</a></h2>
<ul>
<li><strong>LED</strong> – Any standard LED (choose your preferred color).</li>
<li><strong>LDR (Light Dependent Resistor)</strong> – Used to detect light intensity.</li>
<li><strong>Resistors</strong>
<ul>
<li><strong>330Ω</strong> – For the LED to limit current and prevent damage. (You might have to choose based on your LED)</li>
<li><strong>10kΩ</strong> – For the LDR, forming a voltage divider in the circuit. (You might have to choose based on your LDR)</li>
</ul>
</li>
<li><strong>Jumper Wires</strong> – For connecting components on a breadboard or microcontroller.</li>
</ul>
<h2 id="circuit-to-connect-led-ldr-with-pico"><a class="header" href="#circuit-to-connect-led-ldr-with-pico">Circuit to connect LED, LDR with Pico</a></h2>
<ol>
<li><strong>One side of the LDR</strong> is connected to <strong>AGND</strong> (Analog Ground).</li>
<li>The <strong>other side of the LDR</strong> is connected to <strong>GPIO26 (ADC0)</strong>, which is the analog input pin of the pico2</li>
<li>A <strong>resistor</strong> is connected in series with the LDR to create a voltage divider between the LDR and <strong>ADC_VREF</strong> (the reference voltage for the ADC).
<ul>
<li>From the datasheet: “ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico 2 by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required”</li>
</ul>
</li>
</ol>
<img style="display: block; margin: auto;" alt="pico2" src="ldr/ldr-led/images/ldr-pico-led-circuit.jpg" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="action-1"><a class="header" href="#action-1">Action</a></h1>
<p>We’ll use the Embassy HAL for this exercise.</p>
<h2 id="project-from-template-1"><a class="header" href="#project-from-template-1">Project from template</a></h2>
<p>To set up the project, run:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.1.0
</code></pre>
<p>When prompted, give your project a name, like “dracula-ldr” and select <code>embassy</code> as the HAL.</p>
<p>Then, navigate into the project folder:</p>
<pre><code class="language-sh">cd PROJECT_NAME
# For example, if you named your project "dracula-ldr":
# cd dracula-ldr
</code></pre>
<h2 id="interrupt-handler"><a class="header" href="#interrupt-handler">Interrupt Handler</a></h2>
<p>Let’s set up interrupt handling for the ADC.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use embassy_rp::adc::InterruptHandler;

bind_interrupts!(struct Irqs {
    ADC_IRQ_FIFO =&gt; InterruptHandler;
});
<span class="boring">}</span></code></pre>
<p>In simple terms, when the ADC completes a conversion and the result is ready, it triggers an interrupt. This tells the pico that the new data is available, so it can process the ADC value. The interrupt ensures that the pico doesn’t need to constantly check the ADC, allowing it to respond only when new data is ready.</p>
<p>Read more about RP2350 interreupts in the <a href="https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf">datasheet (82th page).</a></p>
<h2 id="initialize-the-embassy-hal"><a class="header" href="#initialize-the-embassy-hal">Initialize the Embassy HAL</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p = embassy_rp::init(Default::default());
<span class="boring">}</span></code></pre>
<h2 id="initialize-the-adc"><a class="header" href="#initialize-the-adc">Initialize the ADC</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut adc = Adc::new(p.ADC, Irqs, Config::default());
<span class="boring">}</span></code></pre>
<h2 id="configuring-the-adc-pin-and-led"><a class="header" href="#configuring-the-adc-pin-and-led">Configuring the ADC Pin and LED</a></h2>
<p>We set up the ADC input pin (PIN_26) for reading an analog signal.
Then we set up an output pin (PIN_15) to control an LED. The LED starts in the low state (Level::Low), meaning it will be off initially.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut p26 = Channel::new_pin(p.PIN_26, Pull::None);
let mut led = Output::new(p.PIN_15, Level::Low);
<span class="boring">}</span></code></pre>
<h2 id="main-loop-1"><a class="header" href="#main-loop-1">Main loop</a></h2>
<p>The logic is straightforward: read the ADC value, and if it’s greater than 3800, turn on the LED; otherwise, turn it off.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    let level = adc.read(&amp;mut p26).await.unwrap();
    if level &gt; 3800 {
        led.set_high();
    } else {
        led.set_low();
    }
    Timer::after_secs(1).await;
}
<span class="boring">}</span></code></pre>
<h2 id="the-full-code-3"><a class="header" href="#the-full-code-3">The full code</a></h2>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use embassy_executor::Spawner;
use embassy_rp::adc::{Adc, Channel, Config, InterruptHandler};
use embassy_rp::bind_interrupts;
use embassy_rp::block::ImageDef;
use embassy_rp::gpio::{Level, Output, Pull};
use embassy_time::Timer;
use {defmt_rtt as _, panic_probe as _};

#[link_section = ".start_block"]
#[used]
pub static IMAGE_DEF: ImageDef = ImageDef::secure_exe();

bind_interrupts!(struct Irqs {
    ADC_IRQ_FIFO =&gt; InterruptHandler;
});

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let p = embassy_rp::init(Default::default());
    let mut adc = Adc::new(p.ADC, Irqs, Config::default());

    let mut p26 = Channel::new_pin(p.PIN_26, Pull::None);
    let mut led = Output::new(p.PIN_15, Level::Low);

    loop {
        let level = adc.read(&amp;mut p26).await.unwrap();
        if level &gt; 3800 {
            led.set_high();
        } else {
            led.set_low();
        }
        Timer::after_secs(1).await;
    }
}</code></pre>
<h2 id="clone-the-existing-project-11"><a class="header" href="#clone-the-existing-project-11">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>dracula-ldr</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-embassy-projects
cd pico2-embassy-projects/dracula-ldr/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="adc-analog-to-digital-converter"><a class="header" href="#adc-analog-to-digital-converter">ADC (Analog to Digital Converter)</a></h1>
<p>An Analog-to-Digital Converter (ADC) is a device used to convert analog signals (continuous signals like sound, light, or temperature) into digital signals (discrete values, typically represented as 1s and 0s). This conversion is necessary for digital systems like microcontrollers (e.g., Raspberry Pi, Arduino) to interact with the real world. For example, sensors that measure temperature or sound produce analog signals, which need to be converted into digital format for processing by digital devices.</p>
<img style="display: block; margin: auto;" alt="pico2" src="core-concepts/images/adc.jpg" />
<h2 id="adc-resolution"><a class="header" href="#adc-resolution">ADC Resolution</a></h2>
<p>The resolution of an ADC refers to how precisely the ADC can measure an analog signal. It is expressed in bits, and the higher the resolution, the more precise the measurements.</p>
<ul>
<li>8-bit ADC produces digital values between 0 and 255.</li>
<li>10-bit ADC produces digital values between 0 and 1023.</li>
<li>12-bit ADC produces digital values between 0 and 4095.</li>
</ul>
<p>The resolution of the ADC can be expressed as the following formula:
\[
\text{Resolution} = \frac{\text{Vref}}{2^{\text{bits}} - 1}
\]</p>
<h2 id="pico"><a class="header" href="#pico">Pico</a></h2>
<p>Based on the <a href="https://datasheets.raspberrypi.com/pico/pico-2-datasheet.pdf">Pico datasheet</a>, Raspberry Pi Pico has 12-bit 500ksps Analogue to Digital Converter (ADC). So, it provides values ranging from 0 to 4095 (4096 possible values)</p>
<p>\[
\text{Resolution} = \frac{3.3V}{2^{12} - 1} = \frac{3.3V}{4095} \approx 0.000805 \text{V} \approx 0.8 \text{mV}
\]</p>
<h2 id="pins"><a class="header" href="#pins">Pins</a></h2>
<p>The Raspberry Pi Pico has <strong>four accessible ADC channels</strong> on the following GPIOs:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>GPIO Pin</strong></th><th><strong>ADC Channel</strong></th><th><strong>Function</strong></th></tr>
</thead>
<tbody>
<tr><td>GPIO26</td><td>ADC0</td><td>Can be used to read voltage from peripherals.</td></tr>
<tr><td>GPIO27</td><td>ADC1</td><td>Can be used to read voltage from peripherals.</td></tr>
<tr><td>GPIO28</td><td>ADC2</td><td>Can be used to read voltage from peripherals.</td></tr>
<tr><td>GPIO29</td><td>ADC3</td><td>Measures the VSYS supply voltage on the board.</td></tr>
</tbody>
</table>
</div>
<p>In pico, ADC operates with a reference voltage set by the supply voltage, which can be measured on pin 35 (ADC_VREF).</p>
<h2 id="adc-value-and-ldr-resistance-in-a-voltage-divider"><a class="header" href="#adc-value-and-ldr-resistance-in-a-voltage-divider">ADC Value and LDR Resistance in a Voltage Divider</a></h2>
<p>In a voltage divider with an LDR (Light-Dependent Resistor, core component of a light/brightness sensor) and a fixed resistor, the output voltage \( V_{\text{out}} \) is given by:</p>
<p>\[
V_{\text{out}} = V_{\text{in}} \times \frac{R_{\text{LDR}}}{R_{\text{LDR}} + R_{\text{fixed}}}
\]</p>
<p>It is same formula as explained in the previous chapter, just replaced the \({R_2}\) with \({R_{\text{LDR}}}\) and \({R_1}\) with \({R_{\text{fixed}}}\)</p>
<ul>
<li><strong>Bright light</strong> (low LDR resistance): \( V_{\text{out}} \) decreases, resulting in a lower ADC value.</li>
<li><strong>Dim light</strong> (high LDR resistance): \( V_{\text{out}} \) increases, leading to a higher ADC value.</li>
</ul>
<h2 id="example-adc-value-calculation"><a class="header" href="#example-adc-value-calculation">Example ADC value calculation:</a></h2>
<p><strong>Bright light</strong>:</p>
<p>Let’s say the Resistence value of LDR is \(1k\Omega\) in the bright light (and we have \(10k\Omega\) fixed resistor).</p>
<p>\[
V_{\text{out}} = 3.3V \times \frac{1k\Omega}{1k\Omega + 10k\Omega} \approx 0.3V
\]</p>
<p>The ADC value is calculated as:
\[
\text{ADC value} = \left( \frac{V_{\text{out}}}{V_{\text{ref}}} \right) \times (2^{12} - 1) \approx \left( \frac{0.3}{3.3} \right) \times 4095 \approx 372
\]</p>
<p><strong>Darkness</strong>:</p>
<p>Let’s say the Resistence value of LDR is \(140k\Omega \) in very low light.</p>
<p>\[
V_{\text{out}} = 3.3V \times \frac{140k\Omega}{140k\Omega + 10k\Omega} \approx 3.08V
\]</p>
<p>The ADC value is calculated as:
\[
\text{ADC value} = \left( \frac{V_{\text{out}}}{V_{\text{ref}}} \right) \times (2^{12} - 1) \approx \left( \frac{3.08}{3.3} \right) \times 4095 = 3822
\]</p>
<h3 id="converting-adc-value-back-to-voltage"><a class="header" href="#converting-adc-value-back-to-voltage"><strong>Converting ADC value back to voltage</strong>:</a></h3>
<p>Now, if we want to convert the ADC value back to the input voltage, we can multiply the ADC value by the resolution (0.8mV).</p>
<p>For example, let’s take an ADC value of 3822:</p>
<p>\[
\text{Voltage} = 3822 \times 0.8mV = 3057.6mV \approx 3.06V
\]</p>
<h2 id="reference-3"><a class="header" href="#reference-3">Reference</a></h2>
<ul>
<li><a href="https://www.elprocus.com/analog-to-digital-converter/">What is Analog to Digital Converter &amp; Its Working</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="thermistor"><a class="header" href="#thermistor">Thermistor</a></h1>
<p>In this section, we’ll be using a thermistor with the Raspberry Pi Pico.  A thermistor is a variable resistor that changes its resistance based on the temperature. The amount of change in resistance depends on its composition.  The term comes from combining “thermal” and “resistor.”.</p>
<p>Thermistors are categorized into two types:</p>
<ul>
<li>
<p>NTC (Negative Temperature Coefficient):</p>
<ul>
<li>Resistance decreases as temperature increases.</li>
<li>They are primarily used for temperature sensing and inrush current limiting.</li>
<li>We’ll be using the NTC thermistor to measure temperature in our exercise.
<img style="display: block; margin: auto;" alt="pico2" src="thermistor/images/ntc-resistor.png" /></li>
</ul>
</li>
<li>
<p>PTC (Positive Temperature Coefficient):</p>
<ul>
<li>Resistance increases as temperature rises.</li>
<li>They primarily protect against overcurrent and overtemperature conditions as resettable fuses and are commonly used in air conditioners, medical devices, battery chargers, and welding equipment.</li>
</ul>
</li>
</ul>
<h2 id="reference-4"><a class="header" href="#reference-4">Reference</a></h2>
<ul>
<li><a href="https://www.teamwavelength.com/thermistor-basics/">Thermistor Basics</a></li>
<li><a href="https://www.electronics-tutorials.ws/io/thermistors.html">Thermistors</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ntc-与分压器"><a href="#ntc-与分压器" class="header">NTC 与分压器</a></h1>
<h2 id="ntc-and-voltage-divider"><a class="header" href="#ntc-and-voltage-divider">NTC and Voltage Divider</a></h2>
<p>I have created a circuit on the Falstad website, and you can download the <a href="thermistor/voltage-divider-thermistor.circuitjs.txt">voltage-divider-thermistor.circuitjs.txt</a> ile to import and experiment with.   This setup is similar to what we covered in the <a href="#voltage-divider">voltage divider chapter of the LDR section</a>. If you haven’t gone through that section, I highly recommend completing the theory there before continuing.</p>
<p>This circuit includes a 10kΩ thermistor with a resistance of 10kΩ at 25°C. The input voltage \( V_{in} \) is set to 3.3V.</p>
<h3 id="themistor-at-25c"><a class="header" href="#themistor-at-25c">Themistor at 25°C</a></h3>
<p>The thermistor has a resistance of 10kΩ at 25°C, resulting in an output voltage (\( V_{out} \)) of 1.65V.</p>
<img style="display: block; margin: auto;" alt="pico2" src="thermistor/images/thermistor0.png" />
<h2 id="thermistor-at-38c"><a class="header" href="#thermistor-at-38c">Thermistor at 38°C</a></h2>
<p>The thermistor’s resistance decreases due to its negative temperature coefficient, altering the voltage divider’s output.</p>
<img style="display: block; margin: auto;" alt="pico2" src="thermistor/images/thermistor1.png" />
<h2 id="thermistor-at-10c"><a class="header" href="#thermistor-at-10c">Thermistor at 10°C</a></h2>
<p>The thermistor’s resistance increases, resulting in a higher output voltage (\( V_{out} \)).
<img style="display: block; margin: auto;" alt="pico2" src="thermistor/images/thermistor2.png" /></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="adc-1"><a href="#adc-1" class="header">ADC</a></h1>
<h2 id="adc"><a class="header" href="#adc">ADC</a></h2>
<p>When setting up the thermistor with the Pico, we don’t get the voltage directly. Instead, we receive an ADC value (refer to the <a href="#adc-analog-to-digital-converter">ADC</a> explanation in the LDR section). In the LDR exercise, we didn’t calculate the resistance corresponding to the ADC value since we only needed to check whether the ADC value increased. However, in this exercise, to determine the temperature, we must convert the ADC value into resistence.</p>
<h3 id="adc-to-resistance"><a class="header" href="#adc-to-resistance">ADC to Resistance</a></h3>
<p>We need resistance value from the adc value for the thermistor temperature calculation(that will be discussed in the next chapters).</p>
<p>We will use this formula to calculate the resistance value from the ADC reading. If you need how it is derived, refer the <a href="#数学">Deriving Resistance from ADC Value</a>.</p>
<p>\[
R_2 = \frac{R_1}{\left( \frac{\text{ADC_MAX}}{\text{adc_value}} - 1 \right)}
\]</p>
<p>Note: If you connected the thermistor to power supply instead of GND. You will need opposite. since thermistor becomes R1.</p>
<p>\[
R_1 = {R_2} \times \left(\frac{\text{ADC_MAX}}{\text{adc_value}} - 1\right)
\]</p>
<p>Where:</p>
<ul>
<li>R2: The resistance based on the ADC value.</li>
<li>R1: Reference resistor value (typically 10kΩ)</li>
<li>ADC_MAX: The maximum ADC value is 4095 (\( 2^{12}\) -1 ) for a 12-bit ADC</li>
<li>adc_value: ADC reading (a value between 0 and ADC_MAX).</li>
</ul>
<h3 id="rust-function"><a class="header" href="#rust-function">Rust Function</a></h3>
<pre class="playground"><code class="language-rust">
const ADC_MAX: u16 = 4095;
const REF_RES: f64 = 10_000.0; 

fn adc_to_resistance(adc_value: u16, ref_res:f64) -&gt; f64 {
    let x: f64 = (ADC_MAX as f64/adc_value as f64)  - 1.0;
    // ref_res * x // If you connected thermistor to power supply
    ref_res / x
}

fn main() {
    let adc_value = 2000; // Our example ADC value;

    let r2 = adc_to_resistance(adc_value, REF_RES);
    println!("Calculated Resistance (R2): {} Ω", r2);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="数学"><a href="#数学" class="header">数学</a></h1>
<h2 id="derivations"><a class="header" href="#derivations">Derivations</a></h2>
<p>You can skip this section if you’d like. It simply explains the math behind deriving the resistance from the ADC value.</p>
<h3 id="adc-to-voltage"><a class="header" href="#adc-to-voltage">ADC to Voltage</a></h3>
<p>The formula to convert an ADC value to voltage is:</p>
<p>\[
V_{\text{out}} = {{V_{in}}}  \times \frac{\text{adc_value}}{\text{adc_max}}
\]</p>
<p>Where:</p>
<ul>
<li><strong>adc_value</strong>: The value read from the ADC.</li>
<li><strong>v_in</strong>: The reference input voltage (3.3V for the Pico).</li>
<li><strong>adc_max</strong>: The maximum ADC value is 4095 (\( 2^{12}\) -1 ) for a 12-bit ADC.</li>
</ul>
<h3 id="deriving-resistance-from-adc-value"><a class="header" href="#deriving-resistance-from-adc-value">Deriving Resistance from ADC Value</a></h3>
<p>We combine the voltage divider formula with ADC Resolution formula to find the Resistance(R2).</p>
<p><span style="color:orange">Note:</span> It is assumed here that one side of the thermistor is connected to Ground (GND). I noticed that some online articles do the opposite, connecting one side of the thermistor to the power supply instead, which initially caused me some confusion.</p>
<!-- 
**ADC voltage calculation formula**
\\[
V_{out} = {{V_{in}}} \times \frac{\text{adc_value}}{\text{adc_max}}
\\] -->
<p><strong>Votlage Divider Formula</strong>
\[
V_{out} = V_{in} \times \frac{R_2}{R_1 + R_2}
\]</p>
<h4 id="step-1"><a class="header" href="#step-1">Step 1:</a></h4>
<p>We can substitue the Vout and make derive it like this</p>
<p>\[
{V_{in}} \times \frac{\text{adc_value}}{\text{adc_max}} = V_{in} \times \frac{R_2}{R_1 + R_2}
\]</p>
<p>\[
\require{cancel}
\cancel{V_{in}} \times \frac{\text{adc_value}}{\text{adc_max}} = \cancel {V_{in}} \times \frac{R_2}{R_1 + R_2}
\]</p>
<h4 id="step-2"><a class="header" href="#step-2">Step 2:</a></h4>
<p>Lets temperoarily assign the adc_value/adc_max to x for ease of derivation and finally subsitue</p>
<p>\[
x = \frac{\text{adc_value}}{\text{adc_max}}
\]</p>
<p>Substituting x into the equation:</p>
<p>\[
x = \frac{R_2}{R_1 + R_2}
\]</p>
<p>Rearrange to Solve \( R_2 \)</p>
<p>\[
R_2 = x \times (R_1 + R_2)
\]</p>
<p>Expand the right-hand side:</p>
<p>\[
R_2 = x \times R_1 + x \times R_2
\]</p>
<p>Rearrange to isolate \( R_2 \) terms:</p>
<p>\[
R_2 - x \times R_2 = R_1 \times x
\]</p>
<p>\[
R_2 \times (1 - x) =  R_1 \times x
\]</p>
<p>\[
R_2 = R_1  \times  \frac{{x}}{{1-x}}
\]</p>
<p>\[
R_2 = R_1 \times \frac{1}{\left( \frac{1}{x} - 1 \right)}
\]</p>
<h4 id="step-3"><a class="header" href="#step-3">Step 3</a></h4>
<p>Let’s subsitute the x value back. We need 1/x, lets convert it.
\[
\frac{1}{x} = \frac{\text{adc_max}}{\text{adc_value}}
\]</p>
<hr>
<h4 id="final-formula"><a class="header" href="#final-formula">Final Formula</a></h4>
<p>\[
R_2 = R_1 \times \frac{1}{\left( \frac{\text{adc_max}}{\text{adc_value}} - 1 \right)}
\]</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="非线性"><a href="#非线性" class="header">非线性</a></h1>
<h2 id="non-linear"><a class="header" href="#non-linear">Non-Linear</a></h2>
<p>Thermistors have a non-linear relationship between resistance and temperature, meaning that as the temperature changes, the resistance doesn’t change in a straight-line pattern. The behavior of thermistors can be described using the Steinhart-Hart equation or the B equation.</p>
<img style="display: block; margin: auto;" alt="pico2" src="thermistor/images/thermistor-non-linearity.jpg" />
<p>The B equation is simple to calculate using the B value, which you can easily find online. On the other hand, the Steinhart equation uses A, B, and C coefficients. Some manufacturers provide these coefficients, but you’ll still need to calibrate and find them yourself since the whole reason for using the Steinhart equation is to get accurate temperature readings.</p>
<p>In the next chapters, we will see in detail how to use B equation and Steinhart-Hart equation to determine the temperature.</p>
<h3 id="referemce"><a class="header" href="#referemce">Referemce</a></h3>
<ul>
<li><a href="https://blog.meteodrenthe.nl/2022/09/07/the-b-parameter-vs-steinhart-hart-equation/">The B parameter vs. Steinhart-Hart equation</a></li>
<li><a href="https://community.element14.com/challenges-projects/design-challenges/experimenting-with-thermistors/b/challenge-blog/posts/blog-3-characterising-thermistors-a-quick-primer-beta-value-steinhart-hart-coefficients">Characterising Thermistors – A Quick Primer, Beta Value &amp; Steinhart-Hart Coefficients</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="b-方程"><a href="#b-方程" class="header">B 方程</a></h1>
<h2 id="b-equation"><a class="header" href="#b-equation">B Equation</a></h2>
<p>The B equation is simpler but less precise.
\[
\frac{1}{T} = \frac{1}{T_0} + \frac{1}{B} \ln \left( \frac{R}{R_0} \right)
\]</p>
<p>Where:</p>
<ul>
<li>T is the temperature in <strong>Kelvin</strong>.</li>
<li>\( T_0 \)  is the reference temperature (usually 298.15K or 25°C), where the thermistor’s resistance is known (typically 10kΩ).</li>
<li>R is the <strong>resistance</strong> at temperature T.</li>
<li>\( R_0 \) is the <strong>resistance</strong> at the reference temperature \( T_0 \) (often 10kΩ).</li>
<li>B is the <strong>B-value</strong> of the thermistor.</li>
</ul>
<p>The B value is a constant usually provided by the manufacturers, changes based on the material of a thermistor. It describes the gradient of the resistive curve over a specific temperature range between two points(i.e \( T_0 \) vs \( R_0 \) and T vs R). You can even rewrite the above formula to get B value yourself by calibrating the resistance at two temperatures.</p>
<p><strong>Example Calculation:</strong></p>
<p>Given:</p>
<ul>
<li>Reference temperature \( T_0 = 298.15K \) (i.e., 25°C + 273.15 to convert to Kelvin)</li>
<li>Reference resistance \( R_0 = 10k\Omega \)</li>
<li>B-value B = 3950 (typical for many thermistors)</li>
<li>Measured resistance at temperature T: 10475Ω</li>
</ul>
<h3 id="step-1-apply-the-b-parameter-equation"><a class="header" href="#step-1-apply-the-b-parameter-equation">Step 1: Apply the B-parameter equation</a></h3>
<p>Substitute the given values:</p>
<p>\[
\frac{1}{T} = \frac{1}{298.15} + \frac{1}{3950} \ln \left( \frac{10,475}{10,000} \right)
\]</p>
<p>\[
\frac{1}{T} = 0.003354016 + \frac{1}{3950} \ln(1.0475)
\]</p>
<p>\[
\frac{1}{T} = 0.003354016 + (0.000011748)
\]</p>
<p>\[
\frac{1}{T} = 0.003365764
\]</p>
<h3 id="step-2-calculate-the-temperature-t"><a class="header" href="#step-2-calculate-the-temperature-t">Step 2: Calculate the temperature (T)</a></h3>
<p>\[
T = \frac{1}{0.003365764} = 297.10936358 (Kelvin)
\]</p>
<p>Convert to Celsius:</p>
<p>\[
T_{Celsius} = 297.10936358 - 273.15 \approx 23.95936358°C
\]</p>
<h3 id="result-1"><a class="header" href="#result-1">Result:</a></h3>
<p>The temperature corresponding to a resistance of 10475Ω is approximately <strong>23.96°C</strong>.</p>
<h3 id="rust-function-1"><a class="header" href="#rust-function-1">Rust function</a></h3>
<pre class="playground"><code class="language-rust">fn calculate_temperature(current_res: f64, ref_res: f64, ref_temp: f64, b_val: f64) -&gt; f64 {
    let ln_value = (current_res/ref_res).ln();
    // let ln_value = libm::log(current_res / ref_res); // use this crate for no_std
    let inv_t = (1.0 / ref_temp) + ((1.0 / b_val) * ln_value);
    1.0 / inv_t
}

fn kelvin_to_celsius(kelvin: f64) -&gt; f64 {
    kelvin -  273.15
}

fn celsius_to_kelvin(celsius: f64) -&gt; f64 {
    celsius + 273.15
}

const B_VALUE: f64 = 3950.0;
const V_IN: f64 = 3.3; // Input voltage
const REF_RES: f64 = 10_000.0; // Reference resistance in ohms (10kΩ)
const REF_TEMP: f64 = 25.0;  // Reference temperature 25°C

fn main() {
    let t0 = celsius_to_kelvin(REF_TEMP);
    let r = 9546.0; // Measured resistance in ohms
    
    let temperature_kelvin = calculate_temperature(r, REF_RES, t0, B_VALUE);
    let temperature_celsius = kelvin_to_celsius(temperature_kelvin);
    println!("Temperature: {:.2} °C", temperature_celsius);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="steinhart-方程"><a href="#steinhart-方程" class="header">Steinhart 方程</a></h1>
<h2 id="steinhart-hart-equation"><a class="header" href="#steinhart-hart-equation">Steinhart Hart equation</a></h2>
<p>The Steinhart-Hart equation provides a more accurate temperature-resistance relationship over a wide temperature range.
\[
\frac{1}{T} = A + B \ln R + C (\ln R)^3
\]</p>
<p>Where:</p>
<ul>
<li>T is the temperature in <strong>Kelvins</strong>. (Formula to calculate kelvin from degree Celsius, K = °C + 273.15)</li>
<li>R is the resistance at temperature T in <strong>Ohms</strong>.</li>
<li>A, B, and C are constants specific to the thermistor’s material, often provided by the manufacturer. For better accuracy, you may need to calibrate and determine these values yourself. Some datasheets provide resistance values at various temperatures, which can also be used to calculate this.</li>
</ul>
<h3 id="calibration"><a class="header" href="#calibration">Calibration</a></h3>
<p>To determine the accurate values for A, B, and C, place the thermistor in three temperature conditions: room temperature, ice water, and boiling water. For each condition, measure the thermistor’s resistance using the ADC value and use a reliable thermometer to record the actual temperature. Using the resistance values and corresponding temperatures, calculate the coefficients:</p>
<ul>
<li>Assign A to the ice water temperature,</li>
<li>B to the room temperature, and</li>
<li>C to the boiling water temperature.</li>
</ul>
<h3 id="calculating-steinhart-hart-coefficients"><a class="header" href="#calculating-steinhart-hart-coefficients">Calculating Steinhart-Hart Coefficients</a></h3>
<p>With three resistance and temperature data points, we can find the A, B and C.</p>
<p>$$
\begin{bmatrix}
1 &amp; \ln R_1 &amp; \ln^3 R_1 \\
1 &amp; \ln R_2 &amp; \ln^3 R_2 \\
1 &amp; \ln R_3 &amp; \ln^3 R_3
\end{bmatrix}\begin{bmatrix}
A \\
B \\
C
\end{bmatrix} = \begin{bmatrix}
\frac{1}{T_1} \\
\frac{1}{T_2} \\
\frac{1}{T_3}
\end{bmatrix}
$$</p>
<p>Where:</p>
<ul>
<li>\( R_1, R_2, R_3 \) are the resistance values at temperatures \( T_1, T_2, T_3 \).</li>
</ul>
<p><strong>Let’s calculate the coefficients</strong></p>
<p>Compute the natural logarithms of resistances:
$$
L_1 = \ln R_1, \quad L_2 = \ln R_2, \quad L_3 = \ln R_3
$$</p>
<p>Intermediate calculations:
$$
Y_1 = \frac{1}{T_1}, \quad Y_2 = \frac{1}{T_2}, \quad Y_3 = \frac{1}{T_3}
$$</p>
<p>$$
\gamma_2 = \frac{Y_2 - Y_1}{L_2 - L_1}, \quad \gamma_3 = \frac{Y_3 - Y_1}{L_3 - L_1}
$$</p>
<p>So, finally:
$$
C = \left( \frac{ \gamma_3 - \gamma_2 }{ L_3 - L_2} \right) \left(L_1 + L_2 + L_3\right)^{-1} \
$$
$$
B = \gamma_2 - C \left(L_1^2 + L_1 L_2 + L_2^2\right) \
$$
$$
A = Y_1 - \left(B + L_1^2 C\right) L_1
$$</p>
<p><span style="color: green;">Good news, Everyone!</span> You don’t need to calculate the coefficients manually. Simply provide the resistance and temperature values for cold, room, and hot environments, and use the form below to determine A, B and C</p>
<h3 id="adc-value-and-resistance-calculation"><a class="header" href="#adc-value-and-resistance-calculation">ADC value and Resistance Calculation</a></h3>
<p><span style="color: orange;">Note:</span> if you already have the temperature and corresponding resistance, you can directly use the second table to input those values.</p>
<p>If you have the ADC value and want to calculate the resistance, use this table to find the corresponding resistance at different temperatures. As you enter the ADC value for each temperature, the calculated resistance will be automatically updated in the second table.</p>
<p>To perform this calculation, you’ll need the base resistance of the thermistor, which is essential for determining the resistance at a given temperature based on the ADC value.</p>
<p>Please note that the ADC bits may need to be adjusted if you’re using a different microcontroller. In our case, for the the Raspberry Pi Pico, the ADC resolution is 12 bits.</p>
<form id="adcForm">
  <label for="baseResistance">Base Resistance (Ω): </label>
  <input type="number" id="baseResistance" name="baseResistance" step="any" value="10000" oninput="updateResistance()">
    <br />
    <label for="adcBits">ADC Bits: </label>
  <input type="number" id="adcBits" name="adcBits" step="any" value="12" oninput="updateResistance()">
  <br />
  <br />
  
<table>
    
<thead>
      
<tr>
         <th>Environment</th>
        <th>ADC value</th>
      </tr>

    </thead>

    
<tbody>
      <!-- Cold Water Row -->
      
<tr>
        <td>Cold Water</td>
        <td><input type="number" id="adcColdCount" name="adcColdCount" step="any" oninput="updateResistance()"></td>
      </tr>

      <!-- Room Temperature Row -->
      
<tr>
        <td>Room Temperature</td>
        <td><input type="number" id="adcRoomCount" name="adcRoomCount" step="any" oninput="updateResistance()"></td>
      </tr>

      <!-- Boiling Water Row -->
      
<tr>
      <td>Boiling Water</td>
        <td><input type="number" id="adcBoilCount" name="adcBoilCount" step="any" oninput="updateResistance()"></td>
      </tr>

    </tbody>

  </table>

</form>
<h3 id="coefficients-finder"><a class="header" href="#coefficients-finder">Coefficients Finder</a></h3>
<p>Adjust the temperature by entering a value in either Fahrenheit or Celsius; the form will automatically convert it to the other format. Provide the resistance corresponding to each temperature, and then click the “Calculate Coefficients” button.</p>
<form id="steinhartForm" onsubmit="calcCoeffBtnClicked(event)">
<table>
<thead>
<tr>
<th>Environment</th>
<th>Resistance (Ohms)</th>
<th>Temperature (°F)</th>
<th>Temperature (°C)</th>
<th>Temperature (K)</th>
</tr>

</thead>

<tbody>
<tr>
<td>Cold Water</td>
<td><input type="number" id="resistanceCold" name="resistanceCold" step="any" oninput="validateInput()"></td>
<td><input type="number" id="coldTempF" name="coldTempF" step="any" oninput="calcTempFromFarenhit(&#39;coldTempC&#39;, &#39;coldTempF&#39;, &#39;coldTempK&#39;, &#39;resistanceCold&#39;)"></td>
<td><input type="number" id="coldTempC" name="coldTempC" step="any" oninput="calcTempFromCel(&#39;coldTempC&#39;, &#39;coldTempF&#39;, &#39;coldTempK&#39;, &#39;resistanceCold&#39;)"></td>
<td><input type="number" id="coldTempK" name="coldTempK" step="any" readonly=""></td>
</tr>

<tr>
<td>Room Temperature</td>
<td><input type="number" id="resistanceRoom" name="resistanceRoom" step="any" oninput="validateInput()"></td>
<td><input type="number" id="roomTempF" name="roomTempF" step="any" oninput="calcTempFromFarenhit(&#39;roomTempC&#39;, &#39;roomTempF&#39;, &#39;roomTempK&#39;, &#39;resistanceRoom&#39;)"></td>
<td><input type="number" id="roomTempC" name="roomTempC" step="any" value="25" oninput="calcTempFromCel(&#39;roomTempC&#39;, &#39;roomTempF&#39;, &#39;roomTempK&#39;, &#39;resistanceRoom&#39;)"></td>
<td><input type="number" id="roomTempK" name="roomTempK" step="any" readonly=""></td>
</tr>

<tr>
<td>Boiling Water</td>
<td><input type="number" id="resistanceBoiling" name="resistanceBoiling" step="any" oninput="validateInput()"></td>
<td><input type="number" id="boilTempF" name="boilTempF" step="any" oninput="calcTempFromFarenhit(&#39;boilTempC&#39;, &#39;boilTempF&#39;, &#39;boilTempK&#39;, &#39;resistanceBoiling&#39;)"></td>
<td><input type="number" id="boilTempC" name="boilTempC" step="any" oninput="calcTempFromCel(&#39;boilTempC&#39;, &#39;boilTempF&#39;, &#39;boilTempK&#39;, &#39;resistanceBoiling&#39;)"></td>
<td><input type="number" id="boilTempK" name="boilTempK" step="any" readonly=""></td>
</tr>

</tbody>

</table>

<h3>Results</h3>

<p>
    A: <input type="text" id="resultA" readonly="" />
    <span id="actualA"></span> 
</p>

<p>
    B: <input type="text" id="resultB" readonly="" />
    <span id="actualB"></span> 
</p>

<p>
    C: <input type="text" id="resultC" readonly="" />
    <span id="actualC"></span> 
</p>

<p><button type="submit" id="submitBtn">Calculate Coefficients</button></p>
</form>
<h3>Calculate Temperature from Resistance</h3>

<p>Now, with these coefficients, you can calculate the temperature for any given resistance:</p>

<p><label for="r">R (Ohms): </label>
<input type="number" name="r" value="10000" id="inputResistance"></p>
<p><button type="button" id="calculateBtn" onclick="calculateTemperatureFromResistance()">Calculate Temperature</button></p>
<p><label for="tc">Result (°C): </label>
<input type="text" name="tc" id="resultCelsius" readonly=""></p>
<p><label for="tf">Result (°F): </label>
<input type="text" name="tf" id="resultFahrenheit" readonly=""></p>
<!-- Error Message Section -->
<p id="errorMessage" style="color: red; display: none;">Error: Please calculate the coefficients (A, B, C) first.</p>

<script>
window.onload = function() {
  // Default values for Cold Water
  document.getElementById("resistanceCold").value = 25000;
  document.getElementById("coldTempC").value = 5;
  calcTempFromCel('coldTempC', 'coldTempF', 'coldTempK', 'resistanceCold');
  
  // Default values for Room Temperature
  document.getElementById("resistanceRoom").value = 10000;
  document.getElementById("roomTempC").value = 25;
  calcTempFromCel('roomTempC', 'roomTempF', 'roomTempK', 'resistanceRoom');
  
  // Default values for Boiling Water
  document.getElementById("resistanceBoiling").value = 4000;
  document.getElementById("boilTempC").value = 45;
  calcTempFromCel('boilTempC', 'boilTempF', 'boilTempK', 'resistanceBoiling');

  calculateCoefficients();
};

// Function to calculate resistance based on base resistance and ADC value
function calculateResistance(baseResistance, adcCount, adcBits) {
  const maxADCValue = Math.pow(2, adcBits) - 1;  // Max ADC value for the given bits (e.g., 12 bits = 4095)
  
  const resistance = baseResistance * ((maxADCValue / adcCount)-1);
  
  return resistance;
}

function updateResistance() {
  const baseResistance = parseFloat(document.getElementById("baseResistance").value);
  const adcBits = parseInt(document.getElementById("adcBits").value);
  
  const adcColdCount = parseFloat(document.getElementById("adcColdCount").value);
  const adcRoomCount = parseFloat(document.getElementById("adcRoomCount").value);
  const adcBoilCount = parseFloat(document.getElementById("adcBoilCount").value);
  
  // Calculate resistance for each environment using the ADC counts
  if (!isNaN(baseResistance) && !isNaN(adcBits)) {
    const resistanceCold = calculateResistance(baseResistance, adcColdCount, adcBits);
    document.getElementById("resistanceCold").value = resistanceCold.toFixed(2);

    const resistanceRoom = calculateResistance(baseResistance, adcRoomCount, adcBits);
    document.getElementById("resistanceRoom").value = resistanceRoom.toFixed(2);

    const resistanceBoiling = calculateResistance(baseResistance, adcBoilCount, adcBits);
    document.getElementById("resistanceBoiling").value = resistanceBoiling.toFixed(2);
  }
}

function calcTempFromCel(celsiusId, fahrenheitId, kelvinId, resistanceId) {
    const tempC = parseFloat(document.getElementById(celsiusId).value);

    if (!isNaN(tempC)) {
        const tempF = (tempC * 9/5) + 32;
        const tempK = tempC + 273.15;
        document.getElementById(fahrenheitId).value = tempF.toFixed(2);
        document.getElementById(kelvinId).value = tempK.toFixed(2);
    } else{
        document.getElementById(fahrenheitId).value = "";
        document.getElementById(kelvinId).value = "";
    }
}

function calcTempFromFarenhit(celsiusId, fahrenheitId, kelvinId, resistanceId) {
    const tempF = parseFloat(document.getElementById(fahrenheitId).value);
    if (!isNaN(tempF)) {
        const tempC = (tempF - 32) * 5 / 9;
        const tempK = tempC + 273.15;
        document.getElementById(celsiusId).value = tempC.toFixed(2);
        document.getElementById(kelvinId).value = tempK.toFixed(2);
    } else{
        document.getElementById(celsiusId).value = "";
        document.getElementById(kelvinId).value = "";
    }
}


function validateInput() {
    const resistanceCold = document.getElementById("resistanceCold").value;
    const resistanceRoom = document.getElementById("resistanceRoom").value;
    const resistanceBoiling = document.getElementById("resistanceBoiling").value;
    const coldTempC = document.getElementById("coldTempC").value;
    const roomTempC = document.getElementById("roomTempC").value;
    const boilTempC = document.getElementById("boilTempC").value;
    const submitBtn = document.getElementById("submitBtn");
}

function calcCoeffBtnClicked(event){
    event.preventDefault();
    calculateCoefficients();
}

function calculateCoefficients() {
    // const coldTempC = parseFloat(document.getElementById("coldTempC").value);
    // const roomTempC = parseFloat(document.getElementById("roomTempC").value);
    // const boilTempC = parseFloat(document.getElementById("boilTempC").value);

    // const coldTempK = coldTempC + 273.15;
    // const roomTempK = roomTempC + 273.15;
    // const boilTempK = boilTempC + 273.15;
    const T1 = parseFloat(document.getElementById("coldTempK").value);
    const T2 = parseFloat(document.getElementById("roomTempK").value);
    const T3 = parseFloat(document.getElementById("boilTempK").value);

    const resistanceCold = parseFloat(document.getElementById("resistanceCold").value);
    const resistanceRoom = parseFloat(document.getElementById("resistanceRoom").value);
    const resistanceBoiling = parseFloat(document.getElementById("resistanceBoiling").value);

    const L1 = Math.log(resistanceCold); //natural logarithm
    const L2 = Math.log(resistanceRoom);
    const L3 = Math.log(resistanceBoiling);

    const Y1 = 1 / T1;
    const Y2 = 1 / T2;
    const Y3 = 1 / T3;

    const gamma2 = (Y2 - Y1) / (L2 - L1); //γ2
    const gamma3 = (Y3 - Y1) / (L3 - L1); //γ3

    // Calculate coefficients A, B, and C
    const C = ((gamma3 - gamma2) / (L3 - L2)) * (L1 + L2 + L3) ** -1;
    const B = gamma2 - C * (Math.pow(L1, 2) + L1 * L2 + Math.pow(L2, 2));
    const A = Y1 - (B + Math.pow(L1, 2) * C) * L1;

    document.getElementById("resultA").value = A.toExponential(8);
    document.getElementById("resultB").value = B.toExponential(8);
    document.getElementById("resultC").value = C.toExponential(8);

    document.getElementById("actualA").textContent = `(${A.toFixed(16)})`;
    document.getElementById("actualB").textContent = `(${B.toFixed(16)})`;
    document.getElementById("actualC").textContent = `(${C.toFixed(16)})`;
}

function calculateTemperatureFromResistance() {

    const A = parseFloat(document.getElementById('resultA').value);
    const B = parseFloat(document.getElementById('resultB').value);
    const C = parseFloat(document.getElementById('resultC').value);

    if (isNaN(A) || isNaN(B) || isNaN(C)) {
        document.getElementById('errorMessage').style.display = 'block'; 
        document.getElementById('resultFahrenheit').value = '';
        document.getElementById('resultCelsius').value = '';
        return;
    } else{
            document.getElementById('errorMessage').style.display = 'none';
    }

    let resistance = parseFloat(document.getElementById('inputResistance').value);
    if (isNaN(resistance)) {
        alert("Please enter a valid resistance.");
        return;
    }

    // Calculate temperature in Kelvin using Steinhart-Hart equation: 
    // 1/T = A + B*ln(R) + C*(ln(R))^3
    let inverseTemperature = A + B * Math.log(resistance) + C * Math.pow(Math.log(resistance), 3);
    let temperatureKelvin = 1 / inverseTemperature; 

    // Convert to Celsius and Fahrenheit
    let temperatureCelsius = temperatureKelvin - 273.15;  
    let temperatureFahrenheit = (temperatureCelsius * 9/5) + 32;  

    document.getElementById('resultFahrenheit').value = temperatureFahrenheit.toFixed(2);
    document.getElementById('resultCelsius').value = temperatureCelsius.toFixed(2);

}
</script>
<h3 id="rust-function-2"><a class="header" href="#rust-function-2">Rust function</a></h3>
<pre class="playground"><code class="language-rust">fn steinhart_temp_calc(
    resistance: f64, // Resistance in Ohms
    a: f64,          // Coefficient A
    b: f64,          // Coefficient B
    c: f64,          // Coefficient C
) -&gt; Result&lt;(f64, f64), String&gt; {
    if resistance &lt;= 0.0 {
        return Err("Resistance must be a positive number.".to_string());
    }

    // Calculate temperature in Kelvin using Steinhart-Hart equation:
    // 1/T = A + B*ln(R) + C*(ln(R))^3
    let ln_r = resistance.ln();
    let inverse_temperature = a + b * ln_r + c * ln_r.powi(3);

    if inverse_temperature == 0.0 {
        return Err("Invalid coefficients or resistance leading to division by zero.".to_string());
    }

    let temperature_kelvin = 1.0 / inverse_temperature;

    let temperature_celsius = temperature_kelvin - 273.15;
    let temperature_fahrenheit = (temperature_celsius * 9.0 / 5.0) + 32.0;

    Ok((temperature_celsius, temperature_fahrenheit))
}

fn main() {
    // Example inputs
     let a = 2.10850817e-3;
    let b = 7.97920473e-5;
    let c = 6.53507631e-7;
    let resistance = 10000.0;


    match steinhart_temp_calc(resistance, a, b, c) {
        Ok((celsius, fahrenheit)) =&gt; {
            println!("Temperature in Celsius: {:.2}", celsius);
            println!("Temperature in Fahrenheit: {:.2}", fahrenheit);
        }
        Err(e) =&gt; println!("Error: {}", e),
    }
}</code></pre>
<h3 id="referemce-1"><a class="header" href="#referemce-1">Referemce</a></h3>
<ul>
<li><a href="https://www.thinksrs.com/downloads/programs/therm%20calc/ntccalibrator/ntccalculator.html">Thermistor Calculator</a></li>
<li><a href="https://www.servo.jp/member/admin/document_upload/AN144-Thermistor-Steinhart-Hart-Coefficients.pdf">Thermistor Steinhart-Hart Coefficients for Calculating Motor Temperature</a></li>
<li><a href="https://www.thinksrs.com/downloads/PDFs/ApplicationNotes/LDC%20Note%204%20NTC%20Calculatorold.pdf">Calibrate Steinhart-Hart Coefficients for Thermistors</a></li>
<li><a href="https://www.instructables.com/ESP32-NTP-Temperature-Probe-Cooking-Thermometer-Wi/">Cooking Thermometer With Steinhart-Hart Correction</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="temperature-on-oled"><a class="header" href="#temperature-on-oled">Temperature on OLED</a></h1>
<p>In this section, we will measure the temperature in your room and display it on the OLED screen.</p>
<h2 id="hardware-requirments"><a class="header" href="#hardware-requirments">Hardware Requirments</a></h2>
<ul>
<li>An OLED display: (0.96 Inch I2C/IIC 4-Pin, 128x64 resolution, SSD1306 chip)</li>
<li>Jumper wires</li>
<li>NTC 103 Thermistor: 10K OHM, 5mm epoxy coated disc</li>
<li>10kΩ Resistor: Used with the thermistor to form a voltage divider</li>
</ul>
<h2 id="circuit-to-connect-oled-thermistor-with-raspberry-pi-pico"><a class="header" href="#circuit-to-connect-oled-thermistor-with-raspberry-pi-pico">Circuit to connect OLED, Thermistor with Raspberry Pi Pico</a></h2>
<img style="display: block; margin: auto;" alt="pico2" src="thermistor/images/thermistor-pico-oled-circuit.jpg" />
<ol>
<li><strong>One side of the Thermistor</strong> is connected to <strong>AGND</strong> (Analog Ground).</li>
<li>The <strong>other side of the Thermistor</strong> is connected to <strong>GPIO26 (ADC0)</strong>, which is the analog input pin of the pico2</li>
<li>A <strong>resistor</strong> is connected in series with the Thermistor to create a voltage divider between the Thermistor and <strong>ADC_VREF</strong> (the reference voltage for the ADC).</li>
</ol>
<p><span style="color:orange">Note:</span>Here, one side of the thermistor is connected to ground, as shown. If you’ve connected it to the power supply instead, you’ll need to use the alternate formula mentioned earlier.</p>
<h2 id="the-flow"><a class="header" href="#the-flow">The Flow</a></h2>
<ul>
<li>We read the ADC value</li>
<li>Get resisance value from ADC value</li>
<li>Calculate temperature using B parameter equation</li>
<li>Display the ADC, Resistance, Temperature(in Celsius) in the OLED</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="action-2"><a class="header" href="#action-2">Action</a></h1>
<p>We’ll use the Embassy HAL for this exercise.</p>
<h2 id="project-from-template-2"><a class="header" href="#project-from-template-2">Project from template</a></h2>
<p>To set up the project, run:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.1.0
</code></pre>
<p>When prompted, give your project a name, like “thermistor” and select <code>embassy</code> as the HAL.</p>
<p>Then, navigate into the project folder:</p>
<pre><code class="language-sh">cd PROJECT_NAME
# For example, if you named your project "thermistor":
# cd thermistor
</code></pre>
<h3 id="additional-crates-required"><a class="header" href="#additional-crates-required">Additional Crates required</a></h3>
<p>Update your Cargo.toml to add these additional crate along with the existing dependencies.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ssd1306 = "0.9.0"
heapless = "0.8.0"
libm = "0.2.11"
<span class="boring">}</span></code></pre>
<ul>
<li><strong><a href="https://docs.rs/ssd1306/latest/ssd1306/"><code>ssd1306</code></a></strong>: Driver for controlling SSD1306 OLED display.</li>
<li><strong><a href="https://docs.rs/heapless/latest/heapless/"><code>heapless</code></a></strong>: In a <code>no_std</code> environment, Rust’s standard <code>String</code> type (which requires heap allocation) is unavailable. This provides stack-allocated, fixed-size data structures. We will be using to store dynamic text, such as ADC, resistance, and temperature values, for display on the OLED screen</li>
<li><strong><a href="https://crates.io/crates/libm"><code>libm</code></a></strong>: Provides essential mathematical functions for embedded environments. We need this to calculate natural logarithm.</li>
</ul>
<h3 id="additional-imports-3"><a class="header" href="#additional-imports-3">Additional imports</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use heapless::String;
use ssd1306::mode::DisplayConfig;
use ssd1306::prelude::DisplayRotation;
use ssd1306::size::DisplaySize128x64;
use ssd1306::{I2CDisplayInterface, Ssd1306};

use embassy_rp::adc::{Adc, Channel};
use embassy_rp::peripherals::I2C1;
use embassy_rp::{adc, bind_interrupts, i2c};

use embassy_rp::gpio::Pull;

use core::fmt::Write;
<span class="boring">}</span></code></pre>
<h3 id="interrupt-handler-1"><a class="header" href="#interrupt-handler-1">Interrupt Handler</a></h3>
<p>We have set up only the ADC interrupt handler for the LDR exercises so far. For this exercise, we also need to set up an interrupt handler for I2C to enable communication with the OLED display.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bind_interrupts!(struct Irqs {
    ADC_IRQ_FIFO =&gt; adc::InterruptHandler;
    I2C1_IRQ =&gt; i2c::InterruptHandler&lt;I2C1&gt;;
});
<span class="boring">}</span></code></pre>
<h3 id="adc-related-functions"><a class="header" href="#adc-related-functions">ADC related functions</a></h3>
<p>We can hardcode 4095 for the Pico, but here’s a simple function to calculate ADC_MAX based on ADC bits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn calculate_adc_max(adc_bits: u8) -&gt; u16 {
    (1 &lt;&lt; adc_bits) - 1
}
const ADC_BITS: u8 = 12; // 12-bit ADC in Pico
const ADC_MAX: u16 = calculate_adc_max(ADC_BITS); // 4095 for 12-bit ADC
<span class="boring">}</span></code></pre>
<h3 id="thermistor-specific-values"><a class="header" href="#thermistor-specific-values">Thermistor specific values</a></h3>
<p>The thermistor I’m using has a 10kΩ resistance at 25°C and a B value of 3950.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const B_VALUE: f64 = 3950.0;
const REF_RES: f64 = 10_000.0; // Reference resistance in ohms (10kΩ)
const REF_TEMP: f64 = 25.0; // Reference temperature 25°C
<span class="boring">}</span></code></pre>
<h3 id="helper-functions"><a class="header" href="#helper-functions">Helper functions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We have already covered about this formula in ADC chpater
fn adc_to_resistance(adc_value: u16, ref_res: f64) -&gt; f64 {
    let x: f64 = (ADC_MAX as f64 / adc_value as f64) - 1.0;
    // ref_res * x // If you connected thermistor to power supply
    ref_res / x
}

// B Equation to convert resistance to temperature
fn calculate_temperature(current_res: f64, ref_res: f64, ref_temp: f64, b_val: f64) -&gt; f64 {
    let ln_value = libm::log(current_res / ref_res); // Use libm for `no_std`
    let inv_t = (1.0 / ref_temp) + ((1.0 / b_val) * ln_value);
    1.0 / inv_t
}

fn kelvin_to_celsius(kelvin: f64) -&gt; f64 {
    kelvin - 273.15
}

fn celsius_to_kelvin(celsius: f64) -&gt; f64 {
    celsius + 273.15
}
<span class="boring">}</span></code></pre>
<h3 id="base-setups"><a class="header" href="#base-setups">Base setups</a></h3>
<p>First, we set up the Embassy HAL, configure the ADC on GPIO 26, and prepare the I2C interface for communication with the OLED display</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p = embassy_rp::init(Default::default());
// ADC to read the Vout value
let mut adc = Adc::new(p.ADC, Irqs, adc::Config::default());
let mut p26 = Channel::new_pin(p.PIN_26, Pull::None);

// Setting up I2C send text to OLED display
let sda = p.PIN_18;
let scl = p.PIN_19;
let i2c = i2c::I2c::new_async(p.I2C1, scl, sda, Irqs, i2c::Config::default());
let interface = I2CDisplayInterface::new(i2c);
<span class="boring">}</span></code></pre>
<h3 id="setting-up-an-ssd1306-oled-display-in-terminal-mode"><a class="header" href="#setting-up-an-ssd1306-oled-display-in-terminal-mode">Setting Up an SSD1306 OLED Display in Terminal Mode</a></h3>
<p>Next, create a display instance, specifying the display size and orientation. And enable terminal mode.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut display =
    Ssd1306::new(interface, DisplaySize128x64, DisplayRotation::Rotate0).into_terminal_mode();
display.init().unwrap();
<span class="boring">}</span></code></pre>
<h3 id="heapless-string"><a class="header" href="#heapless-string">Heapless String</a></h3>
<p>This is a heapless string set up with a capacity of 64 characters. The string is allocated on the stack, allowing it to hold up to 64 characters. We use this variable to display the temperature, ADC, and resistance values on the screen.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut buff: String&lt;64&gt; = String::new();
<span class="boring">}</span></code></pre>
<h3 id="convert-the-reference-temperature-to-kelvin"><a class="header" href="#convert-the-reference-temperature-to-kelvin">Convert the Reference Temperature to Kelvin</a></h3>
<p>We defined the reference temperature as 25°C for the thermistor. However, for the equation, we need the temperature in Kelvin. To handle this, we use a helper function to perform the conversion. Alternatively, you could directly hardcode the Kelvin value (298.15 K, which is 273.15 + 25°C) to skip using the function.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ref_temp = celsius_to_kelvin(REF_TEMP);
<span class="boring">}</span></code></pre>
<h2 id="loop-1"><a class="header" href="#loop-1">Loop</a></h2>
<p>In a loop that runs every 1 second(adjust as you require), we read the ADC value, calculate the resistance from ADC, then derive the temperature from resistance, and display the results on the OLED.</p>
<h3 id="read-adc"><a class="header" href="#read-adc">Read ADC</a></h3>
<p>We read the ADC value; we also put into the buffer.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let adc_value = adc.read(&amp;mut p26).await.unwrap();
writeln!(buff, "ADC: {}", adc_value).unwrap();
<span class="boring">}</span></code></pre>
<h3 id="adc-to-resistance-1"><a class="header" href="#adc-to-resistance-1">ADC To Resistance</a></h3>
<p>We convert the ADC To resistance; we put this also into the buffer.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let current_res = adc_to_resistance(adc_value, REF_RES);
writeln!(buff, "R: {:.2}", current_res).unwrap();
<span class="boring">}</span></code></pre>
<h3 id="calculate-temperature-from-resistance"><a class="header" href="#calculate-temperature-from-resistance">Calculate Temperature from Resistance</a></h3>
<p>We use the measured resistance to calculate the temperature in Kelvin using the B-parameter equation.Afterward, we convert the temperature from Kelvin to Celsius.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let temperature_kelvin = calculate_temperature(current_res, REF_RES, ref_temp, B_VALUE);
let temperature_celsius = kelvin_to_celsius(temperature_kelvin);
<span class="boring">}</span></code></pre>
<h3 id="write-the-buffer-to-display"><a class="header" href="#write-the-buffer-to-display">Write the Buffer to Display</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>writeln!(buff, "Temp: {:.2} °C", temperature_celsius).unwrap();
display.write_str(&amp;buff).unwrap();
Timer::after_secs(1).await;
<span class="boring">}</span></code></pre>
<h3 id="clear-the-buffer-and-screen"><a class="header" href="#clear-the-buffer-and-screen">Clear the Buffer and Screen</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>buff.clear();
display.clear().unwrap();
<span class="boring">}</span></code></pre>
<h3 id="final-code"><a class="header" href="#final-code">Final code</a></h3>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use embassy_executor::Spawner;
use embassy_rp as hal;
use embassy_rp::block::ImageDef;
use embassy_rp::gpio::Pull;
use embassy_time::Timer;
use heapless::String;
use ssd1306::mode::DisplayConfig;
use ssd1306::prelude::DisplayRotation;
use ssd1306::size::DisplaySize128x64;
use ssd1306::{I2CDisplayInterface, Ssd1306};
use {defmt_rtt as _, panic_probe as _};

use embassy_rp::adc::{Adc, Channel};
use embassy_rp::peripherals::I2C1;
use embassy_rp::{adc, bind_interrupts, i2c};

use core::fmt::Write;

/// Tell the Boot ROM about our application
#[link_section = ".start_block"]
#[used]
pub static IMAGE_DEF: ImageDef = hal::block::ImageDef::secure_exe();

bind_interrupts!(struct Irqs {
    ADC_IRQ_FIFO =&gt; adc::InterruptHandler;
    I2C1_IRQ =&gt; i2c::InterruptHandler&lt;I2C1&gt;;
});
const fn calculate_adc_max(adc_bits: u8) -&gt; u16 {
    (1 &lt;&lt; adc_bits) - 1
}
const ADC_BITS: u8 = 12; // 12-bit ADC in Pico
const ADC_MAX: u16 = calculate_adc_max(ADC_BITS); // 4095 for 12-bit ADC

const B_VALUE: f64 = 3950.0;
const REF_RES: f64 = 10_000.0; // Reference resistance in ohms (10kΩ)
const REF_TEMP: f64 = 25.0; // Reference temperature 25°C
                            // We have already covered about this formula in ADC chpater
fn adc_to_resistance(adc_value: u16, ref_res: f64) -&gt; f64 {
    let x: f64 = (ADC_MAX as f64 / adc_value as f64) - 1.0;
    // ref_res * x // If you connected thermistor to power supply
    ref_res / x
}

// B Equation to convert resistance to temperature
fn calculate_temperature(current_res: f64, ref_res: f64, ref_temp: f64, b_val: f64) -&gt; f64 {
    let ln_value = libm::log(current_res / ref_res); // Use libm for `no_std`
    let inv_t = (1.0 / ref_temp) + ((1.0 / b_val) * ln_value);
    1.0 / inv_t
}

fn kelvin_to_celsius(kelvin: f64) -&gt; f64 {
    kelvin - 273.15
}

fn celsius_to_kelvin(celsius: f64) -&gt; f64 {
    celsius + 273.15
}

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let p = embassy_rp::init(Default::default());
    // ADC to read the Vout value
    let mut adc = Adc::new(p.ADC, Irqs, adc::Config::default());
    let mut p26 = Channel::new_pin(p.PIN_26, Pull::None);

    // Setting up I2C send text to OLED display
    let sda = p.PIN_18;
    let scl = p.PIN_19;
    let i2c = i2c::I2c::new_async(p.I2C1, scl, sda, Irqs, i2c::Config::default());
    let interface = I2CDisplayInterface::new(i2c);

    let mut display =
        Ssd1306::new(interface, DisplaySize128x64, DisplayRotation::Rotate0).into_terminal_mode();
    display.init().unwrap();
    let mut buff: String&lt;64&gt; = String::new();
    let ref_temp = celsius_to_kelvin(REF_TEMP);
    loop {
        buff.clear();
        display.clear().unwrap();

        let adc_value = adc.read(&amp;mut p26).await.unwrap();
        writeln!(buff, "ADC: {}", adc_value).unwrap();

        let current_res = adc_to_resistance(adc_value, REF_RES);
        writeln!(buff, "R: {:.2}", current_res).unwrap();

        let temperature_kelvin = calculate_temperature(current_res, REF_RES, ref_temp, B_VALUE);
        let temperature_celsius = kelvin_to_celsius(temperature_kelvin);

        writeln!(buff, "Temp: {:.2} °C", temperature_celsius).unwrap();
        display.write_str(&amp;buff).unwrap();
        Timer::after_secs(1).await;
    }
}

// Program metadata for `picotool info`.
// This isn't needed, but it's recomended to have these minimal entries.
#[link_section = ".bi_entries"]
#[used]
pub static PICOTOOL_ENTRIES: [embassy_rp::binary_info::EntryAddr; 4] = [
    embassy_rp::binary_info::rp_program_name!(c"Blinky Example"),
    embassy_rp::binary_info::rp_program_description!(
        c"This example tests the RP Pico on board LED, connected to gpio 25"
    ),
    embassy_rp::binary_info::rp_cargo_version!(),
    embassy_rp::binary_info::rp_program_build_attribute!(),
];

// End of file</code></pre>
<h2 id="clone-the-existing-project-12"><a class="header" href="#clone-the-existing-project-12">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>thermistor</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-embassy-projects
cd pico2-embassy-projects/thermistor/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="usb-serial-communication"><a class="header" href="#usb-serial-communication">USB Serial Communication</a></h1>
<p>In this section, we’ll explore how to establish communication between our device (Pico) and a computer(Linux). We’ll demonstrate how to send a simple string from the device(Pico) to the computer, as well as how to send input from the computer to the device.</p>
<h2 id="cdc-acm"><a class="header" href="#cdc-acm">CDC ACM</a></h2>
<p>The Communication Device Class (CDC) is a standard USB device class <a href="https://www.usb.org/document-library/class-definitions-communication-devices-12">defined</a> by the USB Implementers Forum (USB-IF). The Abstract Control Model (ACM) in CDC allows a device to act like a traditional serial port (like old COM ports). It’s commonly used for applications that previously relied on serial COM or UART communication.</p>
<h2 id="tools-for-linux"><a class="header" href="#tools-for-linux">Tools for Linux</a></h2>
<p>When you flash the code in this exercise, the device will appear as /dev/ttyACM0 in your computer. To interact with the USB serial port on Linux, you can use tools like minicom, tio (or cat ) to read and send data to and from the device</p>
<ul>
<li><a href="https://help.ubuntu.com/community/Minicom">minicom</a>: Minicom is a text-based serial port communications program. It is used to talk to external RS-232 devices such as mobile phones, routers, and serial console ports.</li>
<li><a href="https://github.com/tio/tio">tio</a>: tio is a serial device tool which features a straightforward command-line and configuration file interface to easily connect to serial TTY devices for basic I/O operations.</li>
</ul>
<h2 id="rust-crates"><a class="header" href="#rust-crates">Rust Crates</a></h2>
<p>We will be using the example taken from the RP-HAL repository. It use two crates: <a href="https://crates.io/crates/usb-device">usb-device</a>, an USB stack for embedded devices in Rust, and <a href="https://crates.io/crates/usbd-serial">usbd-serial</a>, which implements the USB CDC-ACM serial port class. The SerialPort class in usbd-serial implements a stream-like buffered serial port and can be used in a similar way to UART.</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://www.keil.com/pack/doc/mw/usb/html/group__usbd__cdc_functions__acm.html">CDC: Communication Device Class (ACM)</a></li>
<li><a href="https://docs.silabs.com/protocol-usb/1.2.0/protocol-usb-cdc/">USB Device CDC ACM Class</a></li>
<li><a href="https://rfc1149.net/blog/2013/03/05/what-is-the-difference-between-devttyusbx-and-devttyacmx/">What is the difference between /dev/ttyUSB and /dev/ttyACM?</a></li>
<li><a href="https://www.usb.org/defined-class-codes">Defined Class Codes</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pico-to-pc"><a class="header" href="#pico-to-pc">Pico to PC</a></h1>
<p>The example <a href="https://github.com/rp-rs/rp-hal/blob/main/rp235x-hal-examples/src/bin/usb.rs">provided</a> in the RP-HAL repository sends a simple “Hello, World!” message from the Pico to the computer once the timer ticks reach 2,000,000. To ensure the message is only sent once, we add a check that sends it only on the first occurrence. Also, it polls for any incoming data to the device (Pico). If data is received, it converts it to uppercase and send it back(This is just show communication is working, not just echoing).</p>
<p>We’ll slightly modify the code to make it more fun. Instead of sending “Hello, World!”, we’ll send “Hello, Rust!” to the computer. Wait, I know that’s not the fun part. Here it comes: if you type ‘r’ in the terminal connected via USB serial, the onboard LED will turn on. Type anything else, and the LED will turn off.</p>
<h2 id="project-from-template-3"><a class="header" href="#project-from-template-3">Project from template</a></h2>
<p>To set up the project, run:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.1.0
</code></pre>
<p>When prompted, give your project a name, like “usb-fun” and select <code>RP-HAL</code> as the HAL.</p>
<p>Then, navigate into the project folder:</p>
<pre><code class="language-sh">cd PROJECT_NAME
# For example, if you named your project "usb-fun":
# cd usb-fun
</code></pre>
<h3 id="additional-crates-required-1"><a class="header" href="#additional-crates-required-1">Additional Crates required</a></h3>
<p>Update your Cargo.toml to add these additional crate along with the existing dependencies.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>usbd-serial = "0.2.2"
usb-device = "0.3.2"
<span class="boring">}</span></code></pre>
<h3 id="additional-imports-4"><a class="header" href="#additional-imports-4">Additional imports</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// USB Device support
use usb_device::{class_prelude::*, prelude::*};
// USB Communications Class Device support
use usbd_serial::SerialPort;
<span class="boring">}</span></code></pre>
<h2 id="set-up-the-usb-driver"><a class="header" href="#set-up-the-usb-driver">Set up the USB driver</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let usb_bus = UsbBusAllocator::new(hal::usb::UsbBus::new(
    pac.USB,
    pac.USB_DPRAM,
    clocks.usb_clock,
    true,
    &amp;mut pac.RESETS,
));
<span class="boring">}</span></code></pre>
<h2 id="set-up-the-usb-communications-class-device-driver"><a class="header" href="#set-up-the-usb-communications-class-device-driver">Set up the USB Communications Class Device driver</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut serial = SerialPort::new(&amp;usb_bus);
<span class="boring">}</span></code></pre>
<h2 id="create-a-usb-device-with-a-fake-vid-and-pid"><a class="header" href="#create-a-usb-device-with-a-fake-vid-and-pid">Create a USB device with a fake VID and PID</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut usb_dev = UsbDeviceBuilder::new(&amp;usb_bus, UsbVidPid(0x16c0, 0x27dd))
    .strings(&amp;[StringDescriptors::default()
        .manufacturer("implRust")
        .product("Ferris")
        .serial_number("TEST")])
    .unwrap()
    .device_class(2) // 2 for the CDC, from: https://www.usb.org/defined-class-codes
    .build();
<span class="boring">}</span></code></pre>
<h2 id="sending-message-to-pc"><a class="header" href="#sending-message-to-pc">Sending Message to PC</a></h2>
<p>This part sends “Hello, Rust!” to the PC when the timer count exceeds 2,000,000 by writing the text to the serial port. We ensure the message is sent only once.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !said_hello &amp;&amp; timer.get_counter().ticks() &gt;= 2_000_000 {
    said_hello = true;
    // Writes bytes from `data` into the port and returns the number of bytes written.
    let _ = serial.write(b"Hello, Rust!\r\n");
}
<span class="boring">}</span></code></pre>
<h2 id="polling-for-data"><a class="header" href="#polling-for-data">Polling for data</a></h2>
<p>Here is the fun part. When you type characters on your computer, they are sent to the Pico via USB serial. On the Pico, we check if the received character matches the letter ‘r’. If it matches, the onboard LED turns on. For any other character, the LED turns off.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if usb_dev.poll(&amp;mut [&amp;mut serial]) {
    let mut buf = [0u8; 64];
    if let Ok(count) = serial.read(&amp;mut buf) {
        for &amp;byte in &amp;buf[..count] {
            if byte == b'r' {
                led.set_high().unwrap();
            } else {
                led.set_low().unwrap();
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="the-full-code-4"><a class="header" href="#the-full-code-4">The Full code</a></h2>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use embedded_hal::digital::OutputPin;
use hal::block::ImageDef;
use panic_halt as _;
use rp235x_hal as hal;

use usb_device::{class_prelude::*, prelude::*};
use usbd_serial::SerialPort;

#[link_section = ".start_block"]
#[used]
pub static IMAGE_DEF: ImageDef = hal::block::ImageDef::secure_exe();

const XTAL_FREQ_HZ: u32 = 12_000_000u32;

#[hal::entry]
fn main() -&gt; ! {
    let mut pac = hal::pac::Peripherals::take().unwrap();
    let mut watchdog = hal::Watchdog::new(pac.WATCHDOG);

    let clocks = hal::clocks::init_clocks_and_plls(
        XTAL_FREQ_HZ,
        pac.XOSC,
        pac.CLOCKS,
        pac.PLL_SYS,
        pac.PLL_USB,
        &amp;mut pac.RESETS,
        &amp;mut watchdog,
    )
    .ok()
    .unwrap();
    let timer = hal::Timer::new_timer0(pac.TIMER0, &amp;mut pac.RESETS, &amp;clocks);

    let sio = hal::Sio::new(pac.SIO);
    let pins = hal::gpio::Pins::new(
        pac.IO_BANK0,
        pac.PADS_BANK0,
        sio.gpio_bank0,
        &amp;mut pac.RESETS,
    );
    let mut led = pins.gpio25.into_push_pull_output();

    let usb_bus = UsbBusAllocator::new(hal::usb::UsbBus::new(
        pac.USB,
        pac.USB_DPRAM,
        clocks.usb_clock,
        true,
        &amp;mut pac.RESETS,
    ));

    let mut serial = SerialPort::new(&amp;usb_bus);

    let mut usb_dev = UsbDeviceBuilder::new(&amp;usb_bus, UsbVidPid(0x16c0, 0x27dd))
        .strings(&amp;[StringDescriptors::default()
            .manufacturer("implRust")
            .product("Ferris")
            .serial_number("TEST")])
        .unwrap()
        .device_class(2) // 2 for the CDC, from: https://www.usb.org/defined-class-codes
        .build();

    let mut said_hello = false;
    loop {
        // Send data to the PC
        if !said_hello &amp;&amp; timer.get_counter().ticks() &gt;= 2_000_000 {
            said_hello = true;
            // Writes bytes from `data` into the port and returns the number of bytes written.
            let _ = serial.write(b"Hello, Rust!\r\n");
        }

        // Read data from PC
        if usb_dev.poll(&amp;mut [&amp;mut serial]) {
            let mut buf = [0u8; 64];
            if let Ok(count) = serial.read(&amp;mut buf) {
                for &amp;byte in &amp;buf[..count] {
                    if byte == b'r' {
                        led.set_high().unwrap();
                    } else {
                        led.set_low().unwrap();
                    }
                }
            }
        }
    }
}

#[link_section = ".bi_entries"]
#[used]
pub static PICOTOOL_ENTRIES: [hal::binary_info::EntryAddr; 5] = [
    hal::binary_info::rp_cargo_bin_name!(),
    hal::binary_info::rp_cargo_version!(),
    hal::binary_info::rp_program_description!(c"USB Fun"),
    hal::binary_info::rp_cargo_homepage_url!(),
    hal::binary_info::rp_program_build_attribute!(),
];
</code></pre>
<h2 id="clone-the-existing-project-13"><a class="header" href="#clone-the-existing-project-13">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>usb-fun</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/usb-fun/
</code></pre>
<h2 id="how-to-run-"><a class="header" href="#how-to-run-">How to Run ?</a></h2>
<p>The method to flash (run the code) on the Pico is the same as usual. However, we need to set up tio to interact with the Pico through the serial port (/dev/ttyACM0). This allows us to read data from the Pico or send data to it.</p>
<h3 id="tio"><a class="header" href="#tio">tio</a></h3>
<p>Make sure you have tio installed on your system. If not, you can install it using:</p>
<pre><code class="language-sh">apt install tio
</code></pre>
<h3 id="connecting-to-the-serial-port"><a class="header" href="#connecting-to-the-serial-port">Connecting to the Serial Port</a></h3>
<p>Run the following command to connect to the Pico’s serial port:</p>
<pre><code class="language-sh">tio /dev/ttyACM0
</code></pre>
<p>This will open a terminal session for communicating with the Pico.</p>
<h3 id="flashing-and-running-the-code"><a class="header" href="#flashing-and-running-the-code">Flashing and Running the Code</a></h3>
<p>Open another terminal, navigate to the project folder, and flash the code onto the Pico as usual:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>If everything is set up correctly, you should see a “Connected” message in the tio terminal, followed by the “Hello, Rust!” message sent from the Pico.</p>
<img style="display: block; margin: auto;" src="usb-serial/images/tio-usb-pico.png" />
<h3 id="send-data-to-pico"><a class="header" href="#send-data-to-pico">Send data to Pico</a></h3>
<p>In the terminal where tio is running, you type that will be sent to the Pico. You won’t see what you type (since we’re not echoing back the input).</p>
<p>If you press the letter ‘r’, the onboard LED will be turned on. If you press any other character, the LED will be turned off.</p>
<h2 id="embassy-version"><a class="header" href="#embassy-version">Embassy version</a></h2>
<p>You can also refer to this project, which demonstrates using USB Serial with the Embassy framework.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-embassy-projects
cd pico2-embassy-projects/usb-serial/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rfid"><a class="header" href="#rfid">RFID</a></h1>
<p>In this section, we will use the RFID Card Reader (RC522) module to read data from RFID tags and key fob tags.</p>
<h2 id="what-is-rfid"><a class="header" href="#what-is-rfid">What is RFID?</a></h2>
<p>You’ve probably used them without even realizing it; on your apartment key, at the office, in parking lots, or with a contactless credit card. If you’ve got a toll pass in your car or used a hotel keycard, then yep, you’ve already seen them in action.</p>
<p>RFID (Radio Frequency Identification) is a technology that uses radio waves to identify and track objects, animals. It wirelessly transmits the stored data from a tag (containing a chip and antenna) to a reader when in range.</p>
<h2 id="categories-by-range"><a class="header" href="#categories-by-range">Categories By Range</a></h2>
<p>RFID systems can be categorized by their operating frequency. The three main types are:</p>
<ul>
<li>
<p><strong>Low Frequency (LF)</strong>: Operates at ~125 kHz with a short range (up to 10cm). It’s slower and commonly used in access control and livestock tracking.</p>
</li>
<li>
<p><strong>High Frequency (HF)</strong>: Operates at 13.56 MHz with a range of 10cm to 1m. It offers moderate speed and is widely used in access control systems, such as office spaces, apartments, hotel keycards, as well as in ticketing, payments, and data transfer.  We are going to use this one (RC522 module which operates at 13.56MHz)</p>
</li>
<li>
<p><strong>Ultra-High Frequency (UHF)</strong>: Operates at 860–960 MHz with a range of up to 12m. It’s faster and commonly used in retail inventory management, anti-counterfeiting, and logistics.</p>
</li>
</ul>
<h2 id="categories-by-power-source"><a class="header" href="#categories-by-power-source">Categories By Power source</a></h2>
<p>RFID tags can either be active or passive, depending on how they are powered.</p>
<ul>
<li><strong>Active tags</strong>: They have their own battery and can send signals on their own. These are typically used on large objects like rail cars, big reusable containers, and assets that need to be tracked over long distances.</li>
<li><strong>Passive tags:</strong>  Unlike active tags, passive tags don’t have a battery. They rely on the electromagnetic fields emitted by the RFID reader to power up. Once energized, they transmit data using radio waves. These are the most common type of RFID tags and are likely the ones you’ve encountered in everyday life. If you guessed it correctly, yes the RC522 is the passive tags.</li>
</ul>
<h2 id="components"><a class="header" href="#components">Components:</a></h2>
<p>RFID systems consist of an RFID Reader, technically referred to as the PCD (Proximity Coupling Device). In passive RFID tags, the reader powers the tag using an electromagnetic field. The tags themselves are called RFID Tags or, in technical terms, PICCs (Proximity Integrated Circuit Cards).  It is good to know its technical terms also, it will come in handy if you want to refer the datasheet and other documents.</p>
<p>Reader typically include memory components like FIFO buffers and EEPROM. They also incorporate cryptographic features to ensure secure communication with Tags, allowing only authenticated RFID readers to interact with them. For example, RFID readers from NXP Semiconductors use the Crypto-1 cipher for authentication.</p>
<p>Each RFID tag has a hardcoded UID (Unique Identifier), which can be 4, 7, or 10 bytes in size.</p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li><a href="https://www.sannytelecom.com/what-is-a-rfid-antenna/">What Is A RFID Antenna?</a></li>
<li><a href="https://www.impinj.com/products/technology/how-can-rfid-systems-be-categorized">Types of RFID Systems</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="meet-the-module"><a class="header" href="#meet-the-module">Meet the module</a></h1>
<p>We will be using the RC522 RFID Card Reader Module, which is built on the MFRC522 IC (designed by NXP), operates at 13.56 MHz . This module is widely available online at an affordable price and typically comes with an RFID tag (MIFARE Classic 1K) and key fob, each containing 1KB of memory. MFRC522 Datasheet can be found <a href="https://www.nxp.com/docs/en/data-sheet/MFRC522.pdf">here</a>.</p>
<img style="display: block; margin: auto;" src="rfid/images/rc522-rfid-card-reader.jpg" />
<p>The microcontroller can communicate with the reader using SPI, UART, I2C. It also has an IRQ (Interrupt Request) pin that can trigger interrupts, so the microcontroller(pico) knows when the tag is nearby, instead of constantly asking the reader (kind of like “Are we there yet?”).</p>
<p>Unfortunately, the library we’re going to use doesn’t support this feature yet, so we won’t be using it for now. We’ll update this section once support is added. So, are we there yet?</p>
<h3 id="additional-information-about-the-module"><a class="header" href="#additional-information-about-the-module">Additional Information about the Module:</a></h3>
<ul>
<li><strong>Supported Standards</strong>: ISO/IEC 14443 A / MIFARE</li>
<li><strong>Card Reading Distance</strong>: 0~50 mm</li>
<li><strong>Idle Current</strong>: 10–13 mA</li>
<li><strong>Operating Current</strong>: 13–26 mA</li>
<li><strong>Operating Voltage</strong>: DC 3.3V  (⚠️ Do not use 5V or higher, it will cause damage).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mifare"><a class="header" href="#mifare">MIFARE</a></h1>
<p>MIFARE is a series of integrated circuit (IC) chips used in contactless smart cards and proximity cards, developed by NXP Semiconductors. MIFARE cards follow ISO/IEC 14443A standards and use encryption methods such as Crypto-1 algorithm. The most common family is MIFARE Classic, with a subtype called <a href="https://www.nxp.com/products/rfid-nfc/mifare-hf/mifare-classic/mifare-classic-ev1-1k-4k:MF1S50YYX_V1">MIFARE Classic EV1</a>.</p>
<h2 id="memory-layout"><a class="header" href="#memory-layout">Memory Layout</a></h2>
<p>The MIFARE Classic 1K card is divided into 16 sectors, with each sector containing 4 blocks. Each block can hold up to 16 bytes, resulting in a total memory capacity of 1KB.</p>
<p>16 sectors × 4 blocks/sector × 16 bytes/block = 1024 bytes = 1KB</p>
<p><a href="rfid/images/mifare-memory-layout.jpg"><img style="display: block; margin: auto;" alt="MIFARE Memory layout" src="rfid/images/mifare-memory-layout.jpg" /></a></p>
<h3 id="sector-trailer"><a class="header" href="#sector-trailer">Sector Trailer</a></h3>
<p>The last block of each sector, known as the “trailer” holds two secret keys and programmable access conditions for the blocks within that sector. Each sector has its own pair of keys (KeyA and KeyB), enabling support for multiple applications with a key hierarchy.</p>
<div class="alert-box alert-box-info">
    <span class="icon"><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M144 80c0 26.5-21.5 48-48 48s-48-21.5-48-48s21.5-48 48-48s48 21.5 48 48zM0 224c0-17.7 14.3-32 32-32H96c17.7 0 32 14.3 32 32V448h32c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H64V256H32c-17.7 0-32-14.3-32-32z"/></svg></span></span>
    
<div class="alert-content">
        <b class="alert-title">Default Keys</b>
        
<p>The MIFARE Classic 1K card is pre-configured with the default key FF FF FF FF FF FF for both KeyA and KeyB.  When reading the trailer block, KeyA values are returned as all zeros (00 00 00 00 00 00), while KeyB returned as it is.</p>

    </div>

</div>

<p>By default, the access bytes (6, 7, and 8 of the trailer) are set to FF 07 80h. You can refer the 10th page for the <a href="https://www.nxp.com/docs/en/data-sheet/MF1S50YYX_V1.pdf">datasheet</a> for more information. And the 9th byte can be used for storing data.</p>
<table border="1" cellspacing="0" cellpadding="5" style="border-collapse: collapse; width: 100%; text-align: center;">
  
<thead>
    
<tr>
      <th rowspan="2" style="background-color: #607D8B; color: #000;">Byte Number</th>
    </tr>

    
<tr>
      <th style="background-color: #1B5E20;">0</th>
      <th style="background-color: #1B5E20;">1</th>
      <th style="background-color: #1B5E20;">2</th>
      <th style="background-color: #1B5E20;">3</th>
      <th style="background-color: #1B5E20;">4</th>
      <th style="background-color: #1B5E20;">5</th>
      <th style="background-color: #FF6F00;">6</th>
      <th style="background-color: #FF6F00;">7</th>
      <th style="background-color: #FF6F00;">8</th>
      <th style="background-color: #FF6F00;">9</th>
      <th style="background-color: #2962FF;">10</th>
      <th style="background-color: #2962FF;">11</th>
      <th style="background-color: #2962FF;">12</th>
      <th style="background-color: #2962FF;">13</th>
      <th style="background-color: #2962FF;">14</th>
      <th style="background-color: #2962FF;">15</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td style="background-color: #607D8B; color: #000;">Description</td>
      <td colspan="6" style="background-color: #1B5E20; color: #000;">KEY A</td>
      <td colspan="3" style="background-color: #FF6F00; color: #000;">Access Bits</td>
      <td style="background-color: #FF6F00; color: #000;">USER Data</td>
      <td colspan="6" style="background-color: #2962FF; color: #000;">KEY B</td>
    </tr>

    
<tr>
      <td style="background-color: #607D8B; color: #000;">Default Data</td>
      <td style="background-color: #1B5E20;">FF</td>
      <td style="background-color: #1B5E20;">FF</td>
      <td style="background-color: #1B5E20;">FF</td>
      <td style="background-color: #1B5E20;">FF</td>
      <td style="background-color: #1B5E20;">FF</td>
      <td style="background-color: #1B5E20;">FF</td>
      <td style="background-color: #FF6F00;">FF</td>
      <td style="background-color: #FF6F00;">07</td>
      <td style="background-color: #FF6F00;">80</td>
      <td style="background-color: #FF6F00;">69</td>
      <td style="background-color: #2962FF;">FF</td>
      <td style="background-color: #2962FF;">FF</td>
      <td style="background-color: #2962FF;">FF</td>
      <td style="background-color: #2962FF;">FF</td>
      <td style="background-color: #2962FF;">FF</td>
      <td style="background-color: #2962FF;">FF</td>
    </tr>

  </tbody>

</table>

<h3 id="manufacturer-block"><a class="header" href="#manufacturer-block">Manufacturer Block</a></h3>
<p>The first block (block 0) of the first sector(sector 0) contains IC manufacturer’s data including the UID. This block is write-protected.</p>
<h3 id="data-block"><a class="header" href="#data-block">Data Block</a></h3>
<p>Each sector has a trailer block, so only 3 blocks can be used for data storage in each sector. However, the first sector only has 2 usable blocks because the first block stores manufacturer data.</p>
<p>To read or write the data, you first need to authenticate with either Key A or Key B of that sector.</p>
<p>The data blocks can be further classified into two categories based on the access bits(we will explain about it later).</p>
<ul>
<li>read/write block: These are standard data blocks that allow basic operations such as reading and writing data.</li>
<li>value block: These blocks are ideal for applications like electronic purses, where they are commonly used to store numeric values, such as account balances. So, you can perform incrementing (e.g., adding $10 to a balance) or decrementing (e.g., deducting $5 for a transaction).</li>
</ul>
<h2 id="reference-5"><a class="header" href="#reference-5">Reference</a></h2>
<ul>
<li>Datasheet: <a href="https://www.nxp.com/docs/en/data-sheet/MF1S50YYX_V1.pdf">MIFARE Classic EV1 1K - Mainstream contactless smart card IC for fast and easy solution development</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="flow"><a class="header" href="#flow">Flow</a></h1>
<p>When you bring the tag near the reader, it goes into a state where it waits for either a REQA (Request) or WUPA (Wake Up) command.</p>
<p>To check if any tag is nearby, we send the REQA command in a loop. If the tag is nearby, it responds with an ATQA (Answer to Request).</p>
<p>Once we get the response, we select the card, and it sends back its UID (we won’t dive into the full technical details involved in this process). After that, we authenticate the sector we want to read or write from. Once we’re done with our operation, we send a HLTA command to put the card in the HALT state.</p>
<p>Note: Once the card is in the HALT state, only the WUPA command (reminds me of Chandler from Friends saying “WOOPAAH”) can wake it up and let us do more operations.</p>
<p><a href="rfid/images/mifare-flow.png"><img style="display: block; margin: auto;" alt="MIFARE Memory layout" src="rfid/images/mifare-flow.png" /></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="电路"><a href="#电路" class="header">电路</a></h1>
<h2 id="circuit-1"><a class="header" href="#circuit-1">Circuit</a></h2>
<p>The introduction has become quite lengthy, so we will move the circuit diagram for connecting the Pico to the RFID reader to a separate page. Additionally, there are more pins that involved in this than any of the previous components we’ve used so far.</p>
<h2 id="pinout-diagram-of-rc522"><a class="header" href="#pinout-diagram-of-rc522">Pinout diagram of RC522</a></h2>
<p>There are 8 pins in the RC522 RFID module.
<a href="rfid/images/rc522-pinout.jpg"><img style="display: block; margin: auto;" alt="pinout diagram of RC522" src="rfid/images/rc522-pinout.jpg" /></a></p>
<table style="border-collapse: collapse; width: 100%; border: 1px solid black;">
  
<tr style="border: 1px solid black;">
    <th style="background-color: #009B77; border: 1px solid black;">Pin</th>
    <th style="border: 1px solid black;">SPI Function</th>
    <th style="border: 1px solid black;">I²C Function</th>
    <th style="border: 1px solid black;">UART Function</th>
    <th style="border: 1px solid black;">Description</th>
  </tr>

  
<tr style="border: 1px solid black;">
    <td style="background-color: #ff0000; color: white; border: 1px solid black;">3.3V</td>
    <td style="border: 1px solid black;">Power</td>
    <td style="border: 1px solid black;">Power</td>
    <td style="border: 1px solid black;">Power</td>
    <td style="border: 1px solid black;">Power supply (3.3V).</td>
  </tr>

  
<tr style="border: 1px solid black;">
    <td style="background-color: #000; color: white; border: 1px solid black;">GND</td>
    <td style="border: 1px solid black;">Ground</td>
    <td style="border: 1px solid black;">Ground</td>
    <td style="border: 1px solid black;">Ground</td>
    <td style="border: 1px solid black;">Ground connection.</td>
  </tr>

  
<tr style="border: 1px solid black;">
    <td style="background-color: #7B3F00; color: white; border: 1px solid black;">RST</td>
    <td style="border: 1px solid black;">Reset</td>
    <td style="border: 1px solid black;">Reset</td>
    <td style="border: 1px solid black;">Reset</td>
    <td style="border: 1px solid black;">Reset the module.</td>
  </tr>

  
<tr style="border: 1px solid black;">
    <td style="background-color: #EFEFEF; border: 1px solid black;color:black;">IRQ</td>
    <td style="border: 1px solid black;">Interrupt (optional)</td>
    <td style="border: 1px solid black;">Interrupt (optional)</td>
    <td style="border: 1px solid black;">Interrupt (optional)</td>
    <td style="border: 1px solid black;">Interrupt Request (IRQ) informs the microcontroller when an RFID tag is detected. Without using IRQ, the microcontroller would need to constantly poll the module.</td>
  </tr>

  
<tr style="border: 1px solid black;">
    <td style="background-color: #FFC000; color: black; border: 1px solid black;">MISO</td>
    <td style="border: 1px solid black;">Master-In-Slave-Out</td>
    <td style="border: 1px solid black;">SCL</td>
    <td style="border: 1px solid black;">TX</td>
    <td style="border: 1px solid black;">In SPI mode, it acts as Master-In-Slave-Out (MISO). In I²C mode, it functions as the clock line (SCL). In UART mode, it acts as the transmit pin (TX).</td>
  </tr>

  
<tr style="border: 1px solid black;">
    <td style="background-color: #008000; color: white; border: 1px solid black;">MOSI</td>
    <td style="border: 1px solid black;">Master-Out-Slave-In</td>
    <td style="border: 1px solid black;">-</td>
    <td style="border: 1px solid black;">-</td>
    <td style="border: 1px solid black;">In SPI mode, it acts as Master-Out-Slave-In (MOSI).</td>
  </tr>

  
<tr style="border: 1px solid black;">
    <td style="background-color: #0F52BA; color: white; border: 1px solid black;">SCK</td>
    <td style="border: 1px solid black;">Serial Clock</td>
    <td style="border: 1px solid black;">-</td>
    <td style="border: 1px solid black;">-</td>
    <td style="border: 1px solid black;">In SPI mode, it acts as the clock line that synchronizes data transfer.</td>
  </tr>

  
<tr style="border: 1px solid black;">
    <td style="background-color: #FF5F1F; color: white; border: 1px solid black;">SDA</td>
    <td style="border: 1px solid black;">Slave Select (SS)</td>
    <td style="border: 1px solid black;">SDA</td>
    <td style="border: 1px solid black;">RX</td>
    <td style="border: 1px solid black;">In SPI mode, it acts as the Slave select (SS, also referred as Chip Select). In I²C mode, it serves as the data line (SDA). In UART mode, it acts as the receive pin (RX).</td>
  </tr>

</table>

<h2 id="connecting-the-rfid-reader-to-the-raspberry-pi-pico"><a class="header" href="#connecting-the-rfid-reader-to-the-raspberry-pi-pico">Connecting the RFID Reader to the Raspberry Pi Pico</a></h2>
<p>To establish communication between the Raspberry Pi Pico and the RFID Reader, we will use the SPI (Serial Peripheral Interface) protocol.  The SPI interface can handle data speed up to 10 Mbit/s. We wont be utilizing the following Pins: RST, IRQ at the moment.</p>
<table>
  
<thead>
    
<tr>
      <th>Pico Pin</th>
      <th style="width: 250px; margin: 0 auto;">Wire</th>
      <th>RFID Reader Pin</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>3.3V</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire red" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>3.3V</td>
    </tr>

    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GND</td>
    </tr>

    <!-- <tr>
      <td>GPIO 22</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        <div class="wire brown" style="width: 200px; margin: 0 auto;">
          <div class="male-left"></div>
          <div class="male-right"></div>
        </div>
      </td>
      <td>RST</td>
    </tr> -->
    
<tr>
      <td>GPIO 4</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire yellow" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>MISO</td>
    </tr>

    
<tr>
      <td>GPIO 5</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire orange" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>SDA</td>
    </tr>

    
<tr>
      <td>GPIO 6</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire blue" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>SCK</td>
    </tr>

    
<tr>
      <td>GPIO 7</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire green" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>MOSI</td>
    </tr>

  </tbody>

</table>

<p><a href="rfid/images/connecting-pico-with-mfrc522.jpg"><img style="display: block; margin: auto;" alt="pinout diagram of RC522" src="rfid/images/connecting-pico-with-mfrc522.jpg" /></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="read-uid"><a class="header" href="#read-uid">Read UID</a></h1>
<p>Alright, let’s get to the fun part and dive into some action! We’ll start by writing a simple program to read the UID of the RFID tag.</p>
<h3 id="mfrc522-driver"><a class="header" href="#mfrc522-driver">mfrc522 Driver</a></h3>
<p>We will be using the awesome crate  “<a href="https://crates.io/crates/mfrc522">mfrc522</a>”. It is still under development. However, it has everything what we need for purposes.</p>
<h3 id="usb-serial"><a class="header" href="#usb-serial">USB Serial</a></h3>
<p>To display the tag data, we’ll use USB serial, which we covered in the last chapter. This will allow us to read from the RFID tag and display the UID on the computer.</p>
<h3 id="project-from-template-4"><a class="header" href="#project-from-template-4">Project from template</a></h3>
<p>To set up the project, run:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.1.0
</code></pre>
<p>When prompted, give your project a name, like “rfid-uid” and select <code>RP-HAL</code> as the HAL.</p>
<p>Then, navigate into the project folder:</p>
<pre><code class="language-sh">cd PROJECT_NAME
# For example, if you named your project "rfid-uid":
# cd rfid-uid
</code></pre>
<h3 id="additional-crates-required-2"><a class="header" href="#additional-crates-required-2">Additional Crates required</a></h3>
<p>Update your Cargo.toml to add these additional crate along with the existing dependencies.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>usbd-serial = "0.2.2"
usb-device = "0.3.2"
heapless = "0.8.0"
mfrc522 = "0.8.0"
embedded-hal-bus = "0.2.0"
<span class="boring">}</span></code></pre>
<p>We have added embedded-hal-bus, which provides the necessary traits for SPI and I2C buses. This is required for interfacing the Pico with the RFID reader.</p>
<h3 id="additional-imports-5"><a class="header" href="#additional-imports-5">Additional imports</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hal::fugit::RateExtU32;
use core::fmt::Write;

// to prepare buffer with data before writing into USB serial
use heapless::String;

// for setting up USB Serial
use usb_device::{class_prelude::*, prelude::*};
use usbd_serial::SerialPort;

// Driver for the MFRC522
use mfrc522::{comm::blocking::spi::SpiInterface, Mfrc522};

use embedded_hal_bus::spi::ExclusiveDevice;
<span class="boring">}</span></code></pre>
<p>Make sure to check out the <a href="#pico-to-pc">USB serial</a> tutorial for setting up the USB serial. We won’t go over the setup here to keep it simple.</p>
<h3 id="helper-function-to-print-uid-in-hex"><a class="header" href="#helper-function-to-print-uid-in-hex">Helper Function to Print UID in Hex</a></h3>
<p>We’ll use this helper function to convert the u8 byte array (in this case UID) into a printable hex string.  You could also just use raw bytes and enable hex mode in tio(requires latest version) or minicom, but I find this approach easier. In hex mode, it prints everything in hex, including normal text.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_hex_to_serial&lt;B: UsbBus&gt;(data: &amp;[u8], serial: &amp;mut SerialPort&lt;B&gt;) {
    let mut buff: String&lt;64&gt; = String::new();
    for &amp;d in data.iter() {
        write!(buff, "{:02x} ", d).unwrap();
    }
    serial.write(buff.as_bytes()).unwrap();
}
<span class="boring">}</span></code></pre>
<h3 id="setting-up-the-spi-for-the-rfid-reader"><a class="header" href="#setting-up-the-spi-for-the-rfid-reader">Setting Up the SPI for the RFID Reader</a></h3>
<p>Now, let’s configure the SPI bus and the necessary pins to communicate with the RFID reader.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spi_mosi = pins.gpio7.into_function::&lt;hal::gpio::FunctionSpi&gt;();
let spi_miso = pins.gpio4.into_function::&lt;hal::gpio::FunctionSpi&gt;();
let spi_sclk = pins.gpio6.into_function::&lt;hal::gpio::FunctionSpi&gt;();
let spi_bus = hal::spi::Spi::&lt;_, _, _, 8&gt;::new(pac.SPI0, (spi_mosi, spi_miso, spi_sclk));
let spi_cs = pins.gpio5.into_push_pull_output();
let spi = spi_bus.init(
    &amp;mut pac.RESETS,
    clocks.peripheral_clock.freq(),
    1_000.kHz(),
    embedded_hal::spi::MODE_0,
);
<span class="boring">}</span></code></pre>
<h3 id="getting-the-spidevice-from-spi-bus"><a class="header" href="#getting-the-spidevice-from-spi-bus">Getting the <code>SpiDevice</code> from SPI Bus</a></h3>
<p>To work with the <code>mfrc522</code> crate, we need an <code>SpiDevice</code>. Since we only have the SPI bus from RP-HAL, we’ll use the <code>embedded_hal_bus</code> crate to get the <code>SpiDevice</code> from the SPI bus.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spi = ExclusiveDevice::new(spi, spi_cs, timer).unwrap();
<span class="boring">}</span></code></pre>
<h3 id="initialize-the-mfrc522"><a class="header" href="#initialize-the-mfrc522">Initialize the mfrc522</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let itf = SpiInterface::new(spi);
let mut rfid = Mfrc522::new(itf).init().unwrap();
<span class="boring">}</span></code></pre>
<h3 id="read-the-uid-and-print"><a class="header" href="#read-the-uid-and-print">Read the UID and Print</a></h3>
<p>The main logic for reading the UID is simple. We continuously send the REQA command. If a tag is present, it send us the ATQA response. We then use this response to select the tag and retrieve the UID.</p>
<p>Once we have the UID, we use our helper function to print the UID bytes in hex format via USB serial.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    // to estabilish USB serial
    let _ = usb_dev.poll(&amp;mut [&amp;mut serial]);

    if let Ok(atqa) = rfid.reqa() {
        if let Ok(uid) = rfid.select(&amp;atqa) {
            serial.write("\r\nUID: \r\n".as_bytes()).unwrap();
            print_hex_to_serial(uid.as_bytes(), &amp;mut serial);
            timer.delay_ms(500);
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-14"><a class="header" href="#clone-the-existing-project-14">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>rfid-uid</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/rfid-uid/
</code></pre>
<h2 id="how-to-run--1"><a class="header" href="#how-to-run--1">How to Run ?</a></h2>
<p>The method to flash (run the code) on the Pico is the same as usual. However, we need to set up tio to interact with the Pico through the serial port (/dev/ttyACM0). This allows us to read data from the Pico or send data to it.</p>
<h3 id="tio-1"><a class="header" href="#tio-1">tio</a></h3>
<p>Make sure you have tio installed on your system. If not, you can install it using:</p>
<pre><code class="language-sh">apt install tio
</code></pre>
<h3 id="connecting-to-the-serial-port-1"><a class="header" href="#connecting-to-the-serial-port-1">Connecting to the Serial Port</a></h3>
<p>Run the following command to connect to the Pico’s serial port:</p>
<pre><code class="language-sh">tio /dev/ttyACM0
</code></pre>
<p>This will open a terminal session for communicating with the Pico.</p>
<h3 id="flashing-and-running-the-code-1"><a class="header" href="#flashing-and-running-the-code-1">Flashing and Running the Code</a></h3>
<p>Open another terminal, navigate to the project folder, and flash the code onto the Pico as usual:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>If everything is set up correctly, you should see a “Connected” message in the tio terminal.</p>
<h3 id="reading-the-uid"><a class="header" href="#reading-the-uid">Reading the UID</a></h3>
<p>Now, bring the RFID tag near the reader. You should see the UID bytes displayed in hex format on the USB serial terminal.</p>
<img style="display: block; margin: auto;" src="rfid/images/uid-print-to-usb-serial.png" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="uid-匹配时点亮-led"><a href="#uid-匹配时点亮-led" class="header">UID 匹配时点亮 LED</a></h1>
<h2 id="turn-on-led-on-uid-match"><a class="header" href="#turn-on-led-on-uid-match">Turn on LED on UID Match</a></h2>
<p>In this section, we’ll use the UID obtained in the previous chapter and hardcode it into our program. The LED will turn on only when the matching RFID tag is nearby; otherwise, it will remain off. When you bring the RFID tag close, the LED will light up. If you bring a different tag, like a key fob or any other RFID tag, the LED will turn off.</p>
<h2 id="logic-1"><a class="header" href="#logic-1">Logic</a></h2>
<p>It is very simple straightforward logic.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut led = pins.gpio25.into_push_pull_output();

// Replace the UID Bytes with your tag UID
const TAG_UID: [u8; 4] = [0x13, 0x37, 0x73, 0x31];

loop {
    led.set_low().unwrap();

    if let Ok(atqa) = rfid.reqa() {
        if let Ok(uid) = rfid.select(&amp;atqa) {
            if *uid.as_bytes() == TAG_UID {
                led.set_high().unwrap();
                timer.delay_ms(500);
            }
        }
    }
}

<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-15"><a class="header" href="#clone-the-existing-project-15">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>rfid-led</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/rfid-led/
</code></pre>
<h3 id="light-it-up"><a class="header" href="#light-it-up">Light it Up</a></h3>
<p>Lets flash the pico with our program.</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>Now bring the RFID tag near the RFID reader, the onboard LED on the Pico should turn on. Next, try bringing the key fob closer to the reader, and the LED will turn off. Alternatively, you can first read the key fob UID and hardcode it into the program to see the opposite behavior.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="read-the-data"><a class="header" href="#read-the-data">Read the data</a></h1>
<p>In this section, we’ll read all the blocks from the first sector (sector 0). As we mentioned earlier, to read or write to a specific block on the RFID tag, we first need to authenticate with the corresponding sector.</p>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>Most tags come with a default key, typically 0xFF repeated six times. You may need to check the documentation to find the default key or try other common keys. For the RFID reader we are using, the default key is 0xFF repeated six times.</p>
<p>For authentication, we need:</p>
<ul>
<li>The tag’s UID (obtained using the REQA and Select commands).</li>
<li>The block number within the sector.</li>
<li>The key (hardcoded in this case).</li>
</ul>
<h2 id="read-the-block"><a class="header" href="#read-the-block">Read the block</a></h2>
<p>After successful authentication, we can read data from each block using the <code>mf_read</code> function from the mfrc522 crate. If the read operation succeeds, the function returns 16 bytes of data from the block. This data will then be converted into a hex string and sent to the USB serial output.</p>
<p>The first sector (sector 0) consists of 4 blocks, with absolute block numbers ranging from 0 to 3. For higher sectors, the absolute block numbers increase accordingly (e.g., for sector 1, the blocks are 4, 5, 6, 7).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_sector&lt;E, COMM: mfrc522::comm::Interface&lt;Error = E&gt;, B: UsbBus&gt;(
    uid: &amp;mfrc522::Uid,
    sector: u8,
    rfid: &amp;mut Mfrc522&lt;COMM, mfrc522::Initialized&gt;,
    serial: &amp;mut SerialPort&lt;B&gt;,
) -&gt; Result&lt;(), &amp;'static str&gt; {
    const AUTH_KEY: [u8; 6] = [0xFF; 6];

    let block_offset = sector * 4;
    rfid.mf_authenticate(uid, block_offset, &amp;AUTH_KEY)
        .map_err(|_| "Auth failed")?;

    for abs_block in block_offset..block_offset + 4 {
        let data = rfid.mf_read(abs_block).map_err(|_| "Read failed")?;
        print_hex_to_serial(&amp;data, serial);
        serial
            .write("\r\n".as_bytes())
            .map_err(|_| "Write failed")?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="the-main-loop-1"><a class="header" href="#the-main-loop-1">The main loop</a></h2>
<p>The main loop operates similarly to what we covered in the previous chapter. After selecting a tag, we proceed to read its blocks. Once the block data is read, the loop sends the HLTA and stop_crypto1 commands to put the card in HALT state.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    loop {
        let _ = usb_dev.poll(&amp;mut [&amp;mut serial]);

        if let Ok(atqa) = rfid.reqa() {
            if let Ok(uid) = rfid.select(&amp;atqa) {
                if let Err(e) = read_sector(&amp;uid, 0, &amp;mut rfid, &amp;mut serial) {
                    serial.write(e.as_bytes()).unwrap();
                }
                rfid.hlta().unwrap();
                rfid.stop_crypto1().unwrap();
            }
        }
    }
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-16"><a class="header" href="#clone-the-existing-project-16">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>rfid-read</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/rfid-read/
</code></pre>
<h2 id="how-to-run--2"><a class="header" href="#how-to-run--2">How to Run ?</a></h2>
<p>The method to flash (run the code) on the Pico is the same as usual. However, we need to set up tio to interact with the Pico through the serial port (/dev/ttyACM0). This allows us to read data from the Pico or send data to it.</p>
<h3 id="connecting-to-the-serial-port-2"><a class="header" href="#connecting-to-the-serial-port-2">Connecting to the Serial Port</a></h3>
<p>Run the following command to connect to the Pico’s serial port:</p>
<pre><code class="language-sh">tio /dev/ttyACM0
</code></pre>
<p>This will open a terminal session for communicating with the Pico.</p>
<h3 id="flashing-and-running-the-code-2"><a class="header" href="#flashing-and-running-the-code-2">Flashing and Running the Code</a></h3>
<p>Open another terminal, navigate to the project folder, and flash the code onto the Pico as usual:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>If everything is set up correctly, you should see a “Connected” message in the tio terminal.</p>
<h3 id="reading-the-uid-1"><a class="header" href="#reading-the-uid-1">Reading the UID</a></h3>
<p>Bring the RFID tag close to the reader, and the USB serial terminal will display the data bytes read from the blocks of the first sector (sector 0).</p>
<img style="display: block; margin: auto;" src="rfid/images/rfid-read-block-0.png" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="转储存储区"><a href="#转储存储区" class="header">转储存储区</a></h1>
<h2 id="dump-entire-memory"><a class="header" href="#dump-entire-memory">Dump Entire Memory</a></h2>
<p>You’ve learned how to read the data from each block of the first sector(sector 0) by authenticating into it. Now, we will loop through each sector. Re-Authentication is required every time we move to a new sector. For each sector, we will display the 16-byte data from every 4 blocks.</p>
<p>To make it clearer, we’ll add some formatting and labels, indicating which sector and block we’re referring to (both absolute and relative block numbers to the sector), as well as whether the block is a sector trailer or a data block.</p>
<h3 id="loop-through-the-sector"><a class="header" href="#loop-through-the-sector">Loop through the sector</a></h3>
<p>We will create a separate function to loop through all 16 sectors (sectors 0 to 15), read all the blocks within each sector, and print their data.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dump_memory&lt;E, COMM: mfrc522::comm::Interface&lt;Error = E&gt;, B: UsbBus&gt;(
    uid: &amp;mfrc522::Uid,
    rfid: &amp;mut Mfrc522&lt;COMM, mfrc522::Initialized&gt;,
    serial: &amp;mut SerialPort&lt;B&gt;,
) -&gt; Result&lt;(), &amp;'static str&gt; {
    let mut buff: String&lt;64&gt; = String::new();
    for sector in 0..16 {
        // Printing the Sector number
        write!(buff, "\r\n-----------SECTOR {}-----------\r\n", sector).unwrap();
        serial.write(buff.as_bytes()).unwrap();
        buff.clear();

        read_sector(uid, sector, rfid, serial)?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="labels"><a class="header" href="#labels">Labels</a></h3>
<p>The <code>read_sector</code> function follows the same logic as before, but with added formatting and labels. It now prints the absolute block number, the block number relative to the sector, and labels for the manufacturer data (MFD) block and sector trailer blocks.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_sector&lt;E, COMM: mfrc522::comm::Interface&lt;Error = E&gt;, B: UsbBus&gt;(
    uid: &amp;mfrc522::Uid,
    sector: u8,
    rfid: &amp;mut Mfrc522&lt;COMM, mfrc522::Initialized&gt;,
    serial: &amp;mut SerialPort&lt;B&gt;,
) -&gt; Result&lt;(), &amp;'static str&gt; {
    const AUTH_KEY: [u8; 6] = [0xFF; 6];

    let mut buff: String&lt;64&gt; = String::new();

    let block_offset = sector * 4;
    rfid.mf_authenticate(uid, block_offset, &amp;AUTH_KEY)
        .map_err(|_| "Auth failed")?;

    for abs_block in block_offset..block_offset + 4 {
        let rel_block = abs_block - block_offset;
        let data = rfid.mf_read(abs_block).map_err(|_| "Read failed")?;

        // Prining the Block absolute and relative numbers
        write!(buff, "\r\nBLOCK {} (REL: {}) | ", abs_block, rel_block).unwrap();
        serial.write(buff.as_bytes()).unwrap();
        buff.clear();

        // Printing the block data
        print_hex_to_serial(&amp;data, serial);

        // Printing block type
        let block_type = get_block_type(sector, rel_block);
        write!(buff, "| {} ", block_type).unwrap();
        serial.write(buff.as_bytes()).unwrap();
        buff.clear();
    }
    serial
        .write("\r\n".as_bytes())
        .map_err(|_| "Write failed")?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<p>We will create a small helper function to determine the block type based on the sector and its relative block number.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_block_type(sector: u8, rel_block: u8) -&gt; &amp;'static str {
    match rel_block {
        0 if sector == 0 =&gt; "MFD",
        3 =&gt; "TRAILER",
        _ =&gt; "DATA",
    }
}
<span class="boring">}</span></code></pre>
<h3 id="the-main-loop-2"><a class="header" href="#the-main-loop-2">The main loop</a></h3>
<p>There isn’t much change in the main loop. We just call the <code>dump_memory</code> function instead of <code>read_sector</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    let _ = usb_dev.poll(&amp;mut [&amp;mut serial]);
    if let Ok(atqa) = rfid.reqa() {
        if let Ok(uid) = rfid.select(&amp;atqa) {
            if let Err(e) = dump_memory(&amp;uid, &amp;mut rfid, &amp;mut serial) {
                serial.write(e.as_bytes()).unwrap();
            }
            rfid.hlta().unwrap();
            rfid.stop_crypto1().unwrap();
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-17"><a class="header" href="#clone-the-existing-project-17">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>rfid-dump</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/rfid-dump/
</code></pre>
<h2 id="dump"><a class="header" href="#dump">Dump</a></h2>
<p>When you run the program and bring your tag or key fob close, you should see output like this. If you notice the 0x40..0x43 bytes in the block 18 (the block 2 of the sector 4) and wonder why it’s there; good catch! That’s the custom data I wrote to the tag.</p>
<img style="display: block; margin: auto;" src="rfid/images/rfid-dump.png" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="write-data"><a class="header" href="#write-data">Write Data</a></h1>
<p>We will write data into block 2 of sector 4. First, we will print the data in the block before writing to it, and then again after writing. To perform the write operation, we will use the <code>mf_write</code> function from the mfrc522 crate.</p>
<div class="alert-box alert-box-danger">
    <span class="icon"><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M349.4 44.6c5.9-13.7 1.5-29.7-10.6-38.5s-28.6-8-39.9 1.8l-256 224c-10 8.8-13.6 22.9-8.9 35.3S50.7 288 64 288H175.5L98.6 467.4c-5.9 13.7-1.5 29.7 10.6 38.5s28.6 8 39.9-1.8l256-224c10-8.8 13.6-22.9 8.9-35.3s-16.6-20.7-30-20.7H272.5L349.4 44.6z"/></svg></span></span>
    
<div class="alert-content">
        <b class="alert-title">Writing trailer block</b>
        
<p>Accidentally writing to the wrong block and overwriting the trailer block may alter the authentication key or access bits, which could make the sector unusable.</p>

    </div>

</div>

<h2 id="write-function"><a class="header" href="#write-function">Write function</a></h2>
<p>We will use this function to write data to the block. The mf_write function requires the absolute block number, which we will calculate using the sector number and its relative block number.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn write_block&lt;E, COMM: mfrc522::comm::Interface&lt;Error = E&gt;&gt;(
    uid: &amp;mfrc522::Uid,
    sector: u8,
    rel_block: u8,
    data: [u8; 16],
    rfid: &amp;mut Mfrc522&lt;COMM, mfrc522::Initialized&gt;,
) -&gt; Result&lt;(), &amp;'static str&gt; {
    const AUTH_KEY: [u8; 6] = [0xFF; 6];

    let block_offset = sector * 4;
    let abs_block = block_offset + rel_block;

    rfid.mf_authenticate(uid, block_offset, &amp;AUTH_KEY)
        .map_err(|_| "Auth failed")?;

    rfid.mf_write(abs_block, data).map_err(|_| "Write failed")?;

    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="the-main-loop-3"><a class="header" href="#the-main-loop-3">The main loop</a></h2>
<p>The main loop begins by reading and printing the current content of a specified block before writing new data to it. The <code>write_block</code> function is used to write the constant DATA, which must fill the entire 16-byte block. Any unused bytes are padded with null bytes (0x00).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let target_sector = 4;
    let rel_block = 2;
    const DATA: [u8; 16] = [
        b'i', b'm', b'p', b'l', b'R', b'u', b's', b't', // "implRust"
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Remaining bytes as 0x00
    ];

    loop {
        let _ = usb_dev.poll(&amp;mut [&amp;mut serial]);

        if let Ok(atqa) = rfid.reqa() {
            if let Ok(uid) = rfid.select(&amp;atqa) {
                serial
                    .write("\r\n----Before Write----\r\n".as_bytes())
                    .unwrap();
                if let Err(e) = read_sector(&amp;uid, target_sector, &amp;mut rfid, &amp;mut serial) {
                    serial.write(e.as_bytes()).unwrap();
                }

                if let Err(e) = write_block(&amp;uid, target_sector, rel_block, DATA, &amp;mut rfid) {
                    serial.write(e.as_bytes()).unwrap();
                }

                serial
                    .write("\r\n----After Write----\r\n".as_bytes())
                    .unwrap();
                if let Err(e) = read_sector(&amp;uid, target_sector, &amp;mut rfid, &amp;mut serial) {
                    serial.write(e.as_bytes()).unwrap();
                }
                rfid.hlta().unwrap();
                rfid.stop_crypto1().unwrap();
            }
        }
    }
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-18"><a class="header" href="#clone-the-existing-project-18">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>rfid-write</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/rfid-write/
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<p>When you run the program, the output will display the hex representation of “implRust” visible in the third row.
<img style="display: block; margin: auto;" src="rfid/images/rfid-write.png" /></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="更改认证密钥"><a href="#更改认证密钥" class="header">更改认证密钥</a></h1>
<h2 id="changing-the-authentication-key"><a class="header" href="#changing-the-authentication-key">Changing the Authentication Key</a></h2>
<p>Let’s change the authentication key (KeyA) for sector 1. By default, it is set to <code>FF FF FF FF FF FF</code>. We’ll update it to <code>52 75 73 74 65 64</code> which is hex for “Rusted.” To do this, we need to modify the trailer block (block 3) of sector 1 while leaving the rest of the sector untouched.</p>
<p>Before proceeding, it is a good idea to verify the current contents of this block. Run the <a href="#转储存储区">Dump Memory</a> or <a href="#read-the-data">Read Data</a> program to check.</p>
<div class="alert-box alert-box-info">
    <span class="icon"><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M144 80c0 26.5-21.5 48-48 48s-48-21.5-48-48s21.5-48 48-48s48 21.5 48 48zM0 224c0-17.7 14.3-32 32-32H96c17.7 0 32 14.3 32 32V448h32c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H64V256H32c-17.7 0-32-14.3-32-32z"/></svg></span></span>
    
<div class="alert-content">
        <b class="alert-title">Default Keys</b>
        
<p>The MIFARE Classic 1K card is pre-configured with the default key FF FF FF FF FF FF for both KeyA and KeyB.  When reading the trailer block, KeyA values are returned as all zeros (00 00 00 00 00 00), while KeyB returned as it is.</p>

    </div>

</div>

<p>We’ll also modify the KeyB contents to verify that the write was successful. We’ll set KeyB to the hex bytes of “Ferris” (46 65 72 72 69 73).</p>
<p>Before writing, the access bytes and KeyB values in your block should mostly match what I have, but double-checking is always better than guessing.</p>
<p>Here’s the plan:</p>
<ol>
<li>In the program, we hardcode the default key (<code>FF FF FF FF FF FF</code>) into a variable named <code>current_key</code>.</li>
<li>Set the <code>new_key</code> to <code>Rusted</code> (in hex bytes). This is necessary to print the block content after writing; otherwise, we’ll get an auth error.</li>
<li>The program will print the block’s contents both before and after writing.</li>
</ol>
<p>Once the key is updated, bring the tag nearby again. You will likely see an “Auth failed” error. If you’re wondering why, congrats-you figured it out! The new key was successfully written, so the hardcoded <code>current_key</code> no longer works. To verify, modify the <code>read-data</code> program to use the new key (<code>Rusted</code>) and try again.</p>
<h3 id="key-and-data"><a class="header" href="#key-and-data">Key and Data</a></h3>
<p>The DATA array contains the new KeyA (“Rusted” in hex), access bits, and KeyB (“Ferris” in hex). The current_key is set to the default FF FF FF FF FF FF, and new_key is the first 6 bytes of DATA, which is “Rusted”.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let target_sector = 1;
let rel_block = 3;
const DATA: [u8; 16] = [
    0x52, 0x75, 0x73, 0x74, 0x65, 0x64, // Key A: "Rusted"
    0xFF, 0x07, 0x80, 0x69, // Access bits and trailer byte
    0x46, 0x65, 0x72, 0x72, 0x69, 0x73, // Key B: "Ferris"
];
let current_key = &amp;[0xFF; 6];
let new_key: &amp;[u8; 6] = &amp;DATA[..6].try_into().unwrap();
<span class="boring">}</span></code></pre>
<h3 id="write-block-function"><a class="header" href="#write-block-function">Write Block function</a></h3>
<p>We have slighly modified the write_block function to accept key as argument.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn write_block&lt;E, COMM: mfrc522::comm::Interface&lt;Error = E&gt;&gt;(
    uid: &amp;mfrc522::Uid,
    sector: u8,
    rel_block: u8,
    data: [u8; 16],
    key: &amp;[u8; 6],
    rfid: &amp;mut Mfrc522&lt;COMM, mfrc522::Initialized&gt;,
) -&gt; Result&lt;(), &amp;'static str&gt; {

    let block_offset = sector * 4;
    let abs_block = block_offset + rel_block;

    rfid.mf_authenticate(uid, block_offset, key)
        .map_err(|_| "Auth failed")?;

    rfid.mf_write(abs_block, data).map_err(|_| "Write failed")?;

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="read-sector-function"><a class="header" href="#read-sector-function">Read Sector function</a></h3>
<p>We have done similar modification for the read_sector function also.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_sector&lt;E, COMM: mfrc522::comm::Interface&lt;Error = E&gt;, B: UsbBus&gt;(
    uid: &amp;mfrc522::Uid,
    sector: u8,
    key: &amp;[u8; 6],
    rfid: &amp;mut Mfrc522&lt;COMM, mfrc522::Initialized&gt;,
    serial: &amp;mut SerialPort&lt;B&gt;,
) -&gt; Result&lt;(), &amp;'static str&gt; {
    let block_offset = sector * 4;
    rfid.mf_authenticate(uid, block_offset, key)
        .map_err(|_| "Auth failed")?;

    for abs_block in block_offset..block_offset + 4 {
        let data = rfid.mf_read(abs_block).map_err(|_| "Read failed")?;
        print_hex_to_serial(&amp;data, serial);
        serial
            .write("\r\n".as_bytes())
            .map_err(|_| "Write failed")?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="the-main-loop-4"><a class="header" href="#the-main-loop-4">The main loop</a></h3>
<p>There’s nothing new in the main loop. All the read and write functions are ones you’ve already seen. We’re just printing the sector content before and after changing the key.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    loop {
        let _ = usb_dev.poll(&amp;mut [&amp;mut serial]);

        if let Ok(atqa) = rfid.reqa() {
            if let Ok(uid) = rfid.select(&amp;atqa) {
                serial
                    .write("\r\n----Before Write----\r\n".as_bytes())
                    .unwrap();
                if let Err(e) = read_sector(&amp;uid, target_sector, current_key, &amp;mut rfid, &amp;mut serial) {
                    serial.write(e.as_bytes()).unwrap();
                }

                if let Err(e) =
                    write_block(&amp;uid, target_sector, rel_block, DATA, current_key, &amp;mut rfid)
                {
                    serial.write(e.as_bytes()).unwrap();
                }

                serial
                    .write("\r\n----After Write----\r\n".as_bytes())
                    .unwrap();
                if let Err(e) = read_sector(&amp;uid, target_sector, new_key, &amp;mut rfid, &amp;mut serial) {
                    serial.write(e.as_bytes()).unwrap();
                }
                rfid.hlta().unwrap();
                rfid.stop_crypto1().unwrap();
            }
        }
    }
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-19"><a class="header" href="#clone-the-existing-project-19">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>rfid-change-key</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/rfid-change-key/
</code></pre>
<h2 id="output-1"><a class="header" href="#output-1">Output</a></h2>
<p>As you can see in the output, when you run the program, it will display the contents of the target block before and after writing. After we change the key, bringing the tag back to the reader will result in an “auth failed” message because the current_key has been changed; The new key is 52 75 73 74 65 64 (Rusted).</p>
<img style="display: block; margin: auto;" src="rfid/images/change-auth-key.png" />
<p>You can also modify the read data program we used earlier with the new key to verify it.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="access-control"><a class="header" href="#access-control">Access Control</a></h1>
<p>The tag includes access bits that enable access control for the data stored in the tag. This chapter will explore how these access bits function. This section might feel a bit overwhelming, so I’ll try to make it as simple and easy to understand as possible.</p>
<div class="alert-box alert-box-danger">
    <span class="icon"><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M349.4 44.6c5.9-13.7 1.5-29.7-10.6-38.5s-28.6-8-39.9 1.8l-256 224c-10 8.8-13.6 22.9-8.9 35.3S50.7 288 64 288H175.5L98.6 467.4c-5.9 13.7-1.5 29.7 10.6 38.5s28.6 8 39.9-1.8l256-224c10-8.8 13.6-22.9 8.9-35.3s-16.6-20.7-30-20.7H272.5L349.4 44.6z"/></svg></span></span>
    
<div class="alert-content">
        <b class="alert-title">Modifying Access Bits</b>
        
<p>Be careful when writing the access bits, as incorrect values can make the sector unusable. </p>

    </div>

</div>

<h2 id="permissions"><a class="header" href="#permissions">Permissions</a></h2>
<p>These are the fundamental permissions that will be used to define access conditions. The table explains each permission operation and specifies the blocks to which it is applicable: normal data blocks (read/write), value blocks, or sector trailers.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>Operation</strong></th><th><strong>Description</strong></th><th><strong>Applicable for Block Type</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>Read</strong></td><td>Reads one memory block</td><td>Read/Write, Value, Sector Trailer</td></tr>
<tr><td><strong>Write</strong></td><td>Writes one memory block</td><td>Read/Write, Value, Sector Trailer</td></tr>
<tr><td><strong>Increment</strong></td><td>Increments the contents of a block and stores the result in the internal Transfer Buffer</td><td>Value</td></tr>
<tr><td><strong>Decrement</strong></td><td>Decrements the contents of a block and stores the result in the internal Transfer Buffer</td><td>Value</td></tr>
<tr><td><strong>Restore</strong></td><td>Reads the contents of a block into the internal Transfer Buffer</td><td>Value</td></tr>
<tr><td><strong>Transfer</strong></td><td>Writes the contents of the internal Transfer Buffer to a block</td><td>Value, Read/Write</td></tr>
</tbody>
</table>
</div>
<h2 id="access-conditions"><a class="header" href="#access-conditions">Access conditions</a></h2>
<p>Let’s address the elephant in the room: The access conditions. During my research, I found that many people struggled to make sense of the access condition section in the datasheet. Here is my attempt to explain it for easy to understand 🤞.</p>
<p>You can use just 3 bit-combinations per block to control its permissions. In the official datasheet, this is represented using a notation like CX<sub>Y</sub> (C1₀, C1₂… C3₃) for the access bits. The first number (X) in this notation refers to the access bit number, which ranges from 1 to 3, each corresponding to a specific permission type. However, the meaning of these permissions varies depending on whether the block is a data block or a trailer block. The second number (Y) in the subscript denotes the relative block number, which ranges from 0 to 3.</p>
<h3 id="table-1-access-conditions-for-the-sector-trailer"><a class="header" href="#table-1-access-conditions-for-the-sector-trailer">Table 1: Access conditions for the sector trailer</a></h3>
<p>In the original datasheet, the subscript number is not specified in the table. I have added the subscript “3”, as the sector trailer is located at Block 3.</p>
<div class="alert-box alert-box-info">
    <span class="icon"><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M144 80c0 26.5-21.5 48-48 48s-48-21.5-48-48s21.5-48 48-48s48 21.5 48 48zM0 224c0-17.7 14.3-32 32-32H96c17.7 0 32 14.3 32 32V448h32c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H64V256H32c-17.7 0-32-14.3-32-32z"/></svg></span></span>
    
<div class="alert-content">
        <b class="alert-title">Readable Key</b>
        
<p>If you can read the key, it cannot be used as an authentication key. Therefore, in this table, whenever Key B is readable, it cannot serve as the authentication key. If you've noticed, yes, the Key A can never be read.</p>

    </div>

</div>

<table class="table-bordered">
  
<thead>
    
<tr>
      <th colspan="3" rowspan="2">Access Bits</th>
      <th colspan="6">Access Condition for</th>
      <th rowspan="3">Remark</th>
    </tr>

    
<tr>
      <th colspan="2">Key A</th>
      <th colspan="2">Access Bits</th>
      <th colspan="2">Key B</th>
    </tr>

    
<tr>
      <th>C1<sub>3</sub></th>
      <th>C2<sub>3</sub></th>
      <th>C3<sub>3</sub></th>
      <th>Read</th>
      <th>Write</th>
      <th>Read</th>
      <th>Write</th>
      <th>Read</th>
      <th>Write</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>never</td>
      <td>key A</td>
      <td>key A</td>
      <td>never</td>
      <td>key A</td>
      <td>key A</td>
      <td>Key B may be read</td>
    </tr>

    
<tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>never</td>
      <td>never</td>
      <td>key A</td>
      <td>never</td>
      <td>key A</td>
      <td>never</td>
      <td>Key B may be read</td>
    </tr>

    
<tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>never</td>
      <td>key B</td>
      <td>key A|B</td>
      <td>never</td>
      <td>never</td>
      <td>key B</td>
      <td></td>
    </tr>

    
<tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>never</td>
      <td>never</td>
      <td>key A|B</td>
      <td>never</td>
      <td>never</td>
      <td>never</td>
      <td></td>
    </tr>

    
<tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>never</td>
      <td>key A</td>
      <td>key A</td>
      <td>key A</td>
      <td>key A</td>
      <td>key A</td>
      <td>Key B may be read; Default configuration</td>
    </tr>

    
<tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>never</td>
      <td>key B</td>
      <td>key A|B</td>
      <td>key B</td>
      <td>never</td>
      <td>key B</td>
      <td></td>
    </tr>

    
<tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>never</td>
      <td>never</td>
      <td>key A|B</td>
      <td>key B</td>
      <td>never</td>
      <td>never</td>
      <td></td>
    </tr>

    
<tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>never</td>
      <td>never</td>
      <td>key A|B</td>
      <td>never</td>
      <td>never</td>
      <td>never</td>
      <td></td>
    </tr>

  </tbody>

</table>

<p><strong>How to make sense out of this table?</strong></p>
<p>It is a simple table showing the correlation between bit combinations and permissions.</p>
<p>For example:
Let’s say you select “1 0	0” (3rd row in the table), then you can’t read KeyA, KeyB. However, you can modify the KeyA as well as KeyB value with KeyB. You can Read Access Bits with either KeyA or KeyB. But, you can never modify the Access Bits.</p>
<p>Now, where should these bits be stored? We will place them in the 6th, 7th, and 8th bytes at a specific location, which will be explained shortly.</p>
<h3 id="table-2-access-conditions-for-data-blocks"><a class="header" href="#table-2-access-conditions-for-data-blocks">Table 2: Access conditions for data blocks</a></h3>
<p>This applies to all data blocks. The original datasheet does not include the subscript “Y”, I have added it for context. Here, “Y” represents the block number (ranging from 0 to 2).</p>
<p>The default config here indicates that both Key A and Key B can perform all operations. However, as seen in the previous table, Key B is readable (in default config), making it unusable for authentication. Therefore, only Key A can be used.</p>
<table class="table-bordered">
  
<thead>
    
<tr>
      <th colspan="3">Access Bits</th>
      <th colspan="4">Access Condition for</th>
      <th rowspan="2">Application</th>
    </tr>

    
<tr>
      <th>C1<sub>Y</sub></th>
      <th>C2<sub>Y</sub></th>
      <th>C3<sub>Y</sub></th>
      <th>Read</th>
      <th>Write</th>
      <th>Increment</th>
      <th>Decrement,Transfer/Restore</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>Default configuration</td>
    </tr>

    
<tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>key A|B</td>
      <td>never</td>
      <td>never</td>
      <td>never</td>
      <td>read/write block</td>
    </tr>

    
<tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>key A|B</td>
      <td>key B</td>
      <td>never</td>
      <td>never</td>
      <td>read/write block</td>
    </tr>

    
<tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>key A|B</td>
      <td>key B</td>
      <td>key B</td>
      <td>key A|B</td>
      <td>value block</td>
    </tr>

    
<tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>key A|B</td>
      <td>never</td>
      <td>never</td>
      <td>key A|B</td>
      <td>value block</td>
    </tr>

    
<tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>key B</td>
      <td>key B</td>
      <td>never</td>
      <td>never</td>
      <td>read/write block</td>
    </tr>

    
<tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>key B</td>
      <td>never</td>
      <td>never</td>
      <td>never</td>
      <td>read/write block</td>
    </tr>

    
<tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>never</td>
      <td>never</td>
      <td>never</td>
      <td>never</td>
      <td>read/write block</td>
    </tr>

  </tbody>

</table>

Note: "If KeyB can be read in the Sector Trailer, it can't be used for authentication. As a result, if the reader uses KeyB to authenticate a block with access conditions that uses KeyB, the card will refuse any further memory access after authentication."
<p><strong>How to make sense out of this table?</strong></p>
<p>It’s similar to the previous one; it shows the relationship between bit combinations and permissions.</p>
<p>For example:
If you select “0 1 0” (2nd row in the table) and use this permission for block 1, you can use either KeyA or KeyB to read block 1. However, no other operations can be performed on block 1.</p>
<p>The notation for this is as follows: the block number is written as a subscript to the bit labels (e.g., C1<sub>1</sub>, C2<sub>1</sub>, C3<sub>1</sub>). Here, the subscript “1” represents block 1. For the selected combination “0 1 0”, this means:</p>
<ul>
<li>C1<sub>1</sub> = 0</li>
<li>C2<sub>1</sub> = 1</li>
<li>C3<sub>1</sub> = 0</li>
</ul>
<p>These bits will also be placed in the 6th, 7th, and 8th bytes at a specific location, which will be explained shortly.</p>
<h3 id="table-3-access-conditions-table"><a class="header" href="#table-3-access-conditions-table">Table 3: Access conditions table</a></h3>
<p>Let’s colorize the original table to better visualize what each bit represents. The 7th and 3rd bits in each byte are related to the sector trailer. The 6th and 2nd bits correspond to Block 2. The 5th and 1st bits are associated with Block 1. The 4th and 0th bits are related to Block 0.</p>
<p>The overline on the notation indicates inverted values. This means that if the CX<sub>y</sub> value is 0, then <span style="text-decoration: overline;">CX</span><sub>y</sub> becomes 1.</p>
<table>
  
<thead>
    
<tr>
      <th>Byte</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>Byte 6</td>
      <td style="color:white;background-color:#8B0000"><span style="text-decoration: overline;">C2</span><sub>3</sub></td>
      <td style="color:white;background-color:#002D62"><span style="text-decoration: overline;">C2</span><sub>2</sub></td>
      <td style="color:white;background-color:#78184A"><span style="text-decoration: overline;">C2</span><sub>1</sub></td>
      <td style="color:white;background-color:#234F1E"><span style="text-decoration: overline;">C2</span><sub>0</sub></td>
      <td style="color:white;background-color:#8B0000"><span style="text-decoration: overline;">C1</span><sub>3</sub></td>
      <td style="color:white;background-color:#002D62"><span style="text-decoration: overline;">C1</span><sub>2</sub></td>
      <td style="color:white;background-color:#78184A"><span style="text-decoration: overline;">C1</span><sub>1</sub></td>
      <td style="color:white;background-color:#234F1E"><span style="text-decoration: overline;">C1</span><sub>0</sub></td>
    </tr>

    
<tr>
      <td>Byte 7</td>
      <td style="color:white;background-color:#8B0000">C1<sub>3</sub></td>
      <td style="color:white;background-color:#002D62">C1<sub>2</sub></td>
      <td style="color:white;background-color:#78184A">C1<sub>1</sub></td>
      <td style="color:white;background-color:#234F1E">C1<sub>0</sub></td>
      <td style="color:white;background-color:#8B0000"><span style="text-decoration: overline;">C3</span><sub>3</sub></td>
      <td style="color:white;background-color:#002D62"><span style="text-decoration: overline;">C3</span><sub>2</sub></td>
      <td style="color:white;background-color:#78184A"><span style="text-decoration: overline;">C3</span><sub>1</sub></td>
      <td style="color:white;background-color:#234F1E"><span style="text-decoration: overline;">C3</span><sub>0</sub></td>
    </tr>

    
<tr>
      <td>Byte 8</td>
      <td style="color:white;background-color:#8B0000">C3<sub>3</sub></td>
      <td style="color:white;background-color:#002D62">C3<sub>2</sub></td>
      <td style="color:white;background-color:#78184A">C3<sub>1</sub></td>
      <td style="color:white;background-color:#234F1E">C3<sub>0</sub></td>
      <td style="color:white;background-color:#8B0000">C2<sub>3</sub></td>
      <td style="color:white;background-color:#002D62">C2<sub>2</sub></td>
      <td style="color:white;background-color:#78184A">C2<sub>1</sub></td>
      <td style="color:white;background-color:#234F1E">C2<sub>0</sub></td>
    </tr>

  </tbody>

</table>

<p>The default access bit “FF 07 80”. Let’s try to understand what it means.</p>
<table border="1">
  
<thead>
    
<tr>
      <th>Byte</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>Byte 6</td>
      <td style="color:white;background-color:#8B0000">1</td>
      <td style="color:white;background-color:#002D62">1</td>
      <td style="color:white;background-color:#78184A">1</td>
      <td style="color:white;background-color:#234F1E">1</td>
      <td style="color:white;background-color:#8B0000">1</td>
      <td style="color:white;background-color:#002D62">1</td>
      <td style="color:white;background-color:#78184A">1</td>
      <td style="color:white;background-color:#234F1E">1</td>
    </tr>

    
<tr>
      <td>Byte 7</td>
      <td style="color:white;background-color:#8B0000">0</td>
      <td style="color:white;background-color:#002D62">0</td>
      <td style="color:white;background-color:#78184A">0</td>
      <td style="color:white;background-color:#234F1E">0</td>
      <td style="color:white;background-color:#8B0000">0</td>
      <td style="color:white;background-color:#002D62">1</td>
      <td style="color:white;background-color:#78184A">1</td>
      <td style="color:white;background-color:#234F1E">1</td>
    </tr>

    
<tr>
      <td>Byte 8</td>
      <td style="color:white;background-color:#8B0000">1</td>
      <td style="color:white;background-color:#002D62">0</td>
      <td style="color:white;background-color:#78184A">0</td>
      <td style="color:white;background-color:#234F1E">0</td>
      <td style="color:white;background-color:#8B0000">0</td>
      <td style="color:white;background-color:#002D62">0</td>
      <td style="color:white;background-color:#78184A">0</td>
      <td style="color:white;background-color:#234F1E">0</td>
    </tr>

  </tbody>

</table>

<p>We can derive the CX<sub>Y</sub> values from the table above. Notice that only C3<sub>3</sub> is set to 1, while all other values are 0. Now, refer to Table 1 and Table 2 to understand which permission this corresponds to.</p>
<table border="1">
  
<thead>
    
<tr>
      <th>Block</th>
      <th>C1<sub>Y</sub></th>
      <th>C2<sub>Y</sub></th>
      <th>C3<sub>Y</sub></th>
      <th>Access</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>Block 0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>All permissions with Key A</td>
    </tr>

    
<tr>
      <td>Block 1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>All permissions with Key A</td>
    </tr>

    
<tr>
      <td>Block 2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>All permissions with Key A</td>
    </tr>

    
<tr>
      <td>Block 3 (Trailer)</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>You can write Key A using Key A. Access Bits and Key B can only be read and written using Key A. </td>
    </tr>

  </tbody>

</table>

<p>Since Key B is readable, you cannot use it for authentication.</p>
<h3 id="calculator-on-next-page"><a class="header" href="#calculator-on-next-page">Calculator on next page</a></h3>
<p>Still confused? Use the calculator on the next page to experiment with different combinations. Adjust the permissions for each block and observe how the Access Bits values change accordingly.</p>
<h3 id="reference-6"><a class="header" href="#reference-6">Reference</a></h3>
<ul>
<li><a href="https://www.nxp.com/docs/en/data-sheet/MF1S50YYX_V1.pdf">11th page of the datasheet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mifare-classic-1k-access-bits-calculator"><a class="header" href="#mifare-classic-1k-access-bits-calculator">MIFARE Classic 1K Access Bits Calculator</a></h1>
<style>
.nested-table {
    display: none;
    margin-top: 10px;
    border: 1px solid #ccc;
    padding: 10px;
}

.nested-table table {
    width: 100%;
    border-collapse: collapse;
}

.nested-table th, .nested-table td {
    border: 1px solid #ccc;
    padding: 5px;
    text-align: center;
}

.nested-table tr:hover{
    cursor: pointer;
}

.nested-table tr:hover{
    background:#30521b;
    color: white;
}

.edit-button {
    cursor: pointer;
    padding: 5px 10px;
}

.selected {
    background-color: #f0f0f0;
}

.selected-row {
    background-color: #d3f4d7;
}
</style>
<p>Decode:
You can modify the “Access bits” and the Data Block and Sector Trailer tables will automatically update.</p>
<p>Encode:
Click the “Edit” button in each row of the table to select your preferred access conditions. This will update the Access Bits.</p>
<div class="alert-box alert-box-warning">
    <span class="icon"><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M349.4 44.6c5.9-13.7 1.5-29.7-10.6-38.5s-28.6-8-39.9 1.8l-256 224c-10 8.8-13.6 22.9-8.9 35.3S50.7 288 64 288H175.5L98.6 467.4c-5.9 13.7-1.5 29.7 10.6 38.5s28.6 8 39.9-1.8l256-224c10-8.8 13.6-22.9 8.9-35.3s-16.6-20.7-30-20.7H272.5L349.4 44.6z"/></svg></span></span>
    
<div class="alert-content">
        <b class="alert-title">Warning</b>
        
<p>Writing an incorrect value to the access condition bits can make the sector inaccessible.</p>

    </div>

</div>

<p><strong>Access Bits</strong></p>
<div style="display: flex; align-items: center;">
  <input type="text" style="font-size:16px; height: 40px;" name="access_bits" id="access-bits" value="FF0780" />
  
<div id="error-box" style="ddisplay: none;  color: #FF2800; font-size: 18px; margin-left: 10px; font-weight:bold">
  </div>

</div>

<p><strong>Data Block Access Conditions:</strong></p>
<table border="1" id="db-table">
  
<thead>
    
<tr>
      <th>Block</th>
      <th>C1Y</th>
      <th>C2Y</th>
      <th>C3Y</th>
      <th>Read</th>
      <th>Write</th>
      <th>Increment</th>
      <th>Decrement/Transfer/Restore</th>
      <th>Remarks</th>
      <th>Action</th>
    </tr>

  </thead>

  
<tbody>
    
<tr data-row="1" id="db-row0">
      <td>Block 0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>Default configuration</td>
      <td><button class="edit-button" onclick="toggleNestedTable(this, &#39;nested-table&#39;,10)">Edit</button></td>
    </tr>

    
<tr data-row="2" id="db-row1">
      <td>Block 1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>Default configuration</td>
      <td><button class="edit-button" onclick="toggleNestedTable(this, &#39;nested-table&#39;,10)">Edit</button></td>
    </tr>

    
<tr data-row="3" id="db-row2">
      <td>Block 2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>key A|B</td>
      <td>Default configuration</td>
      <td><button class="edit-button" onclick="toggleNestedTable(this, &#39;nested-table&#39;,10)">Edit</button></td>
    </tr>

  </tbody>

</table>

<!-- Nested Table Template -->
<div class="nested-table" id="nested-table">
  
<table border="1">
    
<thead>
      
<tr>
        <th>C1Y</th>
        <th>C2Y</th>
        <th>C3Y</th>
        <th>Read</th>
        <th>Write</th>
        <th>Increment</th>
        <th>Decrement/Transfer/Restore</th>
        <th>Remarks</th>
      </tr>

    </thead>

    
<tbody>
      
<tr onclick="selectRow(this)">
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>key A|B</td>
        <td>key A|B</td>
        <td>key A|B</td>
        <td>key A|B</td>
        <td>Default configuration</td>
      </tr>

      
<tr onclick="selectRow(this)">
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>key A|B</td>
        <td>never</td>
        <td>never</td>
        <td>never</td>
        <td>read/write block</td>
      </tr>

      
<tr onclick="selectRow(this)">
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>key A|B</td>
        <td>key B</td>
        <td>never</td>
        <td>never</td>
        <td>read/write block</td>
      </tr>

      
<tr onclick="selectRow(this)">
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>key A|B</td>
        <td>key B</td>
        <td>key B</td>
        <td>key A|B</td>
        <td>value block</td>
      </tr>

      
<tr onclick="selectRow(this)">
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>key A|B</td>
        <td>never</td>
        <td>never</td>
        <td>key A|B</td>
        <td>value block</td>
      </tr>

      
<tr onclick="selectRow(this)">
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>key B</td>
        <td>key B</td>
        <td>never</td>
        <td>never</td>
        <td>read/write block</td>
      </tr>

      
<tr onclick="selectRow(this)">
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>key B</td>
        <td>never</td>
        <td>never</td>
        <td>never</td>
        <td>read/write block</td>
      </tr>

      
<tr onclick="selectRow(this)">
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>never</td>
        <td>never</td>
        <td>never</td>
        <td>never</td>
        <td>read/write block</td>
      </tr>

    </tbody>

  </table>

</div>

<p><strong>Sector Trailer (Block 3) Access Conditions:</strong></p>
<table border="1" id="st-table">
  
<thead>
    
<tr>
        <th>C1<sub>3</sub></th>
        <th>C2<sub>3</sub></th>
        <th>C3<sub>3</sub></th>
        <th>Read Key A</th>
        <th>Write Key A</th>
        <th>Read Access Bits</th>
        <th>Write Access Bits</th>
        <th>Read Key B</th>
        <th>Write Key B</th>
        <th>Remarks</th>
        <th>Action</th>
    </tr>

  </thead>

  
<tbody>
    
<tr data-row="1" id="st-row0"> 
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>never</td>
        <td>key A</td>
        <td>key A</td>
        <td>key A</td>
        <td>key A</td>
        <td>key A</td>
        <td>Key B may be read; Default configuration</td>
        <td><button class="edit-button" onclick="toggleNestedTable(this, &#39;nested-st&#39;, 11)">Edit</button></td>
    </tr>

  </tbody>

</table>

<div class="nested-table" id="nested-st">
  
<table border="1">
    
<thead>
      
<tr>
        <th>C1<sub>3</sub></th>
        <th>C2<sub>3</sub></th>
        <th>C3<sub>3</sub></th>
        <th>Read Key A</th>
        <th>Write Key A</th>
        <th>Read Access Bits</th>
        <th>Write Access Bits</th>
        <th>Read Key B</th>
        <th>Write Key B</th>
        <th>Remarks</th>
      </tr>

    </thead>

    
<tbody>
      
<tr onclick="selectStRow(this)">
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>never</td>
        <td>key A</td>
        <td>key A</td>
        <td>never</td>
        <td>key A</td>
        <td>key A</td>
        <td>Key B may be read</td>
      </tr>

      
<tr onclick="selectStRow(this)">
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>never</td>
        <td>never</td>
        <td>key A</td>
        <td>never</td>
        <td>key A</td>
        <td>never</td>
        <td>Key B may be read</td>
      </tr>

      
<tr onclick="selectStRow(this)">
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>never</td>
        <td>key B</td>
        <td>key A|B</td>
        <td>never</td>
        <td>never</td>
        <td>key B</td>
        <td></td>
      </tr>

      
<tr onclick="selectStRow(this)">
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>never</td>
        <td>never</td>
        <td>key A|B</td>
        <td>never</td>
        <td>never</td>
        <td>never</td>
        <td></td>
      </tr>

      
<tr onclick="selectStRow(this)">
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>never</td>
        <td>key A</td>
        <td>key A</td>
        <td>key A</td>
        <td>key A</td>
        <td>key A</td>
        <td>Key B may be read; Default configuration</td>
      </tr>

      
<tr onclick="selectStRow(this)">
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>never</td>
        <td>key B</td>
        <td>key A|B</td>
        <td>key B</td>
        <td>never</td>
        <td>key B</td>
        <td></td>
      </tr>

      
<tr onclick="selectStRow(this)">
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>never</td>
        <td>never</td>
        <td>key A|B</td>
        <td>key B</td>
        <td>never</td>
        <td>never</td>
        <td></td>
      </tr>

      
<tr onclick="selectStRow(this)">
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>never</td>
        <td>never</td>
        <td>key A|B</td>
        <td>never</td>
        <td>never</td>
        <td>never</td>
        <td></td>
      </tr>

    </tbody>

  </table>

</div>

<script>
  function toggleNestedTable(button, tmplId, colSpan) {
    const row = button.closest('tr');
    const rowId = row.id;
    // console.log(rowId);

    const table = row.closest('table');
    let nestedTable = row.nextElementSibling;

    // Check if nested table already exists, otherwise create a new one
    if (!nestedTable || !nestedTable.classList.contains('nested-table')) {
      nestedTable = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = colSpan;
      nestedTable.classList.add('nested-table');
      nestedTable.setAttribute('data-parent', rowId); 
      td.innerHTML = document.getElementById(tmplId).innerHTML; 
      nestedTable.appendChild(td);
       // Insert the nested table below the row
      row.insertAdjacentElement('afterend', nestedTable);
    }

    // Toggle visibility of the nested table
    nestedTable.style.display = nestedTable.style.display === 'none' || nestedTable.style.display === '' ? 'table-row' : 'none';
  }

    function selectRow(row) {
        const selectedData = row.cells;
        const nestedTable = row.closest('table');
        const parentRowId = nestedTable.closest('tr').getAttribute('data-parent');
        if (!parentRowId) {
            alert("Error");
            return;
        }
        const mainRow = document.getElementById(parentRowId);
        if (!mainRow){
        alert("Error");
            return;
        }

        // Bits
        mainRow.cells[1].textContent = selectedData[0].textContent; // C1Y
        mainRow.cells[2].textContent = selectedData[1].textContent; // C2Y
        mainRow.cells[3].textContent = selectedData[2].textContent; // C3Y
        // Permissions
        mainRow.cells[4].textContent = selectedData[3].textContent; // Read
        mainRow.cells[5].textContent = selectedData[4].textContent; // Write
        mainRow.cells[6].textContent = selectedData[5].textContent; // Increment
        mainRow.cells[7].textContent = selectedData[6].textContent; // Decrement/Transfer/Restore
        mainRow.cells[8].textContent = selectedData[7].textContent; // Remarks

        encode();
        row.classList.add('selected-row');
        setTimeout(() => row.classList.remove('selected-row'), 1000);
    }

    function selectStRow(row) {
        const selectedData = row.cells;
        const nestedTable = row.closest('table');
        const parentRowId = nestedTable.closest('tr').getAttribute('data-parent');

        if (!parentRowId) {
            alert('Error');
            return;
        }

        const mainRow = document.getElementById(parentRowId);
        if (!mainRow) {
            alert('Error');
            return;
        }

        // Bits:
        mainRow.cells[0].textContent = selectedData[0].textContent;
        mainRow.cells[1].textContent = selectedData[1].textContent;
        mainRow.cells[2].textContent = selectedData[2].textContent; 
        // permissions
        mainRow.cells[3].textContent = selectedData[3].textContent; 
        mainRow.cells[4].textContent = selectedData[4].textContent;
        mainRow.cells[5].textContent = selectedData[5].textContent; 
        mainRow.cells[6].textContent = selectedData[6].textContent;
        mainRow.cells[7].textContent = selectedData[7].textContent;
        mainRow.cells[8].textContent = selectedData[8].textContent;
        mainRow.cells[9].textContent = selectedData[9].textContent;

        encode();
        row.classList.add('selected-row');
        setTimeout(() => row.classList.remove('selected-row'), 1000);
  }

    document.getElementById('access-bits').addEventListener('input', decode);

    const DATA_ACCESS_BYTES = {
        "0 0 0": {
            read: "key A|B",
            write: "key A|B",
            increment: "key A|B",
            decrementTransferRestore: "key A|B",
            remarks: "Default configuration"
        },
        "0 1 0": {
            read: "key A|B",
            write: "never",
            increment: "never",
            decrementTransferRestore: "never",
            remarks: "read/write block"
        },
        "1 0 0": {
            read: "key A|B",
            write: "key B",
            increment: "never",
            decrementTransferRestore: "never",
            remarks: "read/write block"
        },
        "1 1 0": {
            read: "key A|B",
            write: "key B",
            increment: "key B",
            decrementTransferRestore: "key A|B",
            remarks: "value block"
        },
        "0 0 1": {
            read: "key A|B",
            write: "never",
            increment: "never",
            decrementTransferRestore: "key A|B",
            remarks: "value block"
        },
        "0 1 1": {
            read: "key B",
            write: "key B",
            increment: "never",
            decrementTransferRestore: "never",
            remarks: "read/write block"
        },
        "1 0 1": {
            read: "key B",
            write: "never",
            increment: "never",
            decrementTransferRestore: "never",
            remarks: "read/write block"
        },
        "1 1 1": {
            read: "never",
            write: "never",
            increment: "never",
            decrementTransferRestore: "never",
            remarks: "read/write block"
        }
    };

    const TRAILER_ACCESS_BYTES = {
        "0 0 0": {
            readKeyA: "never",
            writeKeyA: "key A",
            readAccessBits: "key A",
            writeAccessBits: "never",
            readKeyB: "key A",
            writeKeyB: "key A",
            remarks: "Key B may be read"
        },
        "0 1 0": {
            readKeyA: "never",
            writeKeyA: "never",
            readAccessBits: "key A",
            writeAccessBits: "never",
            readKeyB: "key A",
            writeKeyB: "never",
            remarks: "Key B may be read"
        },
        "1 0 0": {
            readKeyA: "never",
            writeKeyA: "key B",
            readAccessBits: "key A|B",
            writeAccessBits: "never",
            readKeyB: "never",
            writeKeyB: "key B",
            remarks: ""
        },
        "1 1 0": {
            readKeyA: "never",
            writeKeyA: "never",
            readAccessBits: "key A|B",
            writeAccessBits: "never",
            readKeyB: "never",
            writeKeyB: "never",
            remarks: ""
        },
        "0 0 1": {
            readKeyA: "never",
            writeKeyA: "key A",
            readAccessBits: "key A",
            writeAccessBits: "key A",
            readKeyB: "key A",
            writeKeyB: "key A",
            remarks: "Key B may be read; Default configuration"
        },
        "0 1 1": {
            readKeyA: "never",
            writeKeyA: "key B",
            readAccessBits: "key A|B",
            writeAccessBits: "key B",
            readKeyB: "never",
            writeKeyB: "key B",
            remarks: ""
        },
        "1 0 1": {
            readKeyA: "never",
            writeKeyA: "never",
            readAccessBits: "key A|B",
            writeAccessBits: "key B",
            readKeyB: "never",
            writeKeyB: "never",
            remarks: ""
        },
        "1 1 1": {
            readKeyA: "never",
            writeKeyA: "never",
            readAccessBits: "key A|B",
            writeAccessBits: "never",
            readKeyB: "never",
            writeKeyB: "never",
            remarks: ""
        }
    };

    function showError(message) {
        const errorBox = document.getElementById('error-box');
        errorBox.textContent = message; 
        errorBox.style.display = 'inline'; 
    }

    function hideError() {
        const errorBox = document.getElementById('error-box');
        errorBox.style.display = 'none';
    }

    // Function to determine permissions and acess from the bytes
    function decode() {
        const accessBits = document.getElementById('access-bits').value;

        if (accessBits.length < 6) {
            return;
        } else if (accessBits.length > 6) {
            showError("Invalid access bytes");
        }

        // console.log("Decoded Access Bits: ", accessBits);

        const byte6 = accessBits.slice(0, 2); // Byte 6
        const byte7 = accessBits.slice(2, 4); // Byte 7
        const byte8 = accessBits.slice(4, 6); // Byte 8

        // Convert the byte strings to integers (assuming hexadecimal)
        const byteArray = [
            parseInt(byte6, 16), // Convert byte6 to an integer
            parseInt(byte7, 16), // Convert byte7 to an integer
            parseInt(byte8, 16)  // Convert byte8 to an integer
        ];

        // Function to convert a byte to its corresponding bits array
        const byteToBits = (byte) => {
            return Array.from({ length: 8 }, (_, i) => (byte >> (7 - i)) & 1);
        };

        // Create a dictionary with byte keys and their corresponding bits array
        const byteToBitsDict = {
            "byte6": byteToBits(byteArray[0]),
            "byte7": byteToBits(byteArray[1]),
            "byte8": byteToBits(byteArray[2])
        };
        
        let Cxy = {
            "C10": byteToBitsDict.byte7[3],
            "C20": byteToBitsDict.byte8[7],
            "C30": byteToBitsDict.byte8[3],

            "C11": byteToBitsDict.byte7[2],
            "C21": byteToBitsDict.byte8[6],
            "C31": byteToBitsDict.byte8[2],

            "C12": byteToBitsDict.byte7[1],
            "C22": byteToBitsDict.byte8[5],
            "C32": byteToBitsDict.byte8[1],

            "C13": byteToBitsDict.byte7[0],
            "C23": byteToBitsDict.byte8[4],
            "C33": byteToBitsDict.byte8[0],
        };

        let ICxy = {
            // Inverted values
            "IC10": byteToBitsDict.byte6[7],
            "IC20": byteToBitsDict.byte6[3],
            "IC30": byteToBitsDict.byte7[7],

            "IC11": byteToBitsDict.byte6[6],
            "IC21": byteToBitsDict.byte6[2],
            "IC31": byteToBitsDict.byte7[6],

            "IC12": byteToBitsDict.byte6[5],
            "IC22": byteToBitsDict.byte6[1],
            "IC32": byteToBitsDict.byte7[5],

            "IC13": byteToBitsDict.byte6[4],
            "IC23": byteToBitsDict.byte6[0],
            "IC33": byteToBitsDict.byte7[4],
        };
        
        for (let key in Cxy) {
            let invertedKey = "I" + key; 
            let invertedBit = Cxy[key] ^ 1;
            if (invertedBit !== ICxy[invertedKey]) {
                // console.log(key, invertedKey, Cxy[key], ICxy[invertedKey]);
                showError("Invalid access bytes");
                return ;
            }
        }

        hideError();

        // console.log(byteToBitsDict);
        // let blockAccessBits = {
        //     "block0": byteToBitsDict.byte7[3] + " " + byteToBitsDict.byte8[7] + " " + byteToBitsDict.byte8[3],
        //     "block1": byteToBitsDict.byte7[2] + " " + byteToBitsDict.byte8[6] + " "+ byteToBitsDict.byte8[2],
        //     "block2": byteToBitsDict.byte7[1] + " " + byteToBitsDict.byte8[5] + " " + byteToBitsDict.byte8[1],
        //     "block3": byteToBitsDict.byte7[0] + " " + byteToBitsDict.byte8[4] + " " + byteToBitsDict.byte8[0],
        // }
        let blockAccessBits = {
            "block0": Cxy.C10 + " " + Cxy.C20 + " " + Cxy.C30,
            "block1": Cxy.C11 + " " + Cxy.C21 + " " + Cxy.C31,
            "block2": Cxy.C12 + " " + Cxy.C22 + " " + Cxy.C32,
            "block3": Cxy.C13 + " " + Cxy.C23 + " " + Cxy.C33,
        }

        for (let i = 0; i <= 2; i++) {
            let blockCols = DATA_ACCESS_BYTES[blockAccessBits[`block${i}`]];
            let row = document.getElementById(`db-row${i}`);

            row.cells[1].textContent = Cxy[`C1${i}`];
            row.cells[2].textContent = Cxy[`C2${i}`];
            row.cells[3].textContent = Cxy[`C3${i}`];
            row.cells[4].textContent = blockCols.read;
            row.cells[5].textContent = blockCols.write;
            row.cells[6].textContent = blockCols.increment;
            row.cells[7].textContent = blockCols.decrementTransferRestore;
            row.cells[8].textContent = blockCols.remarks;
        }

        let stCols = TRAILER_ACCESS_BYTES[blockAccessBits.block3];
        const stRow = document.getElementById('st-row0');
        stRow.cells[0].textContent = Cxy.C13;
        stRow.cells[1].textContent = Cxy.C23;
        stRow.cells[2].textContent = Cxy.C33;
        stRow.cells[3].textContent = stCols.readKeyA;
        stRow.cells[4].textContent = stCols.writeKeyA;
        stRow.cells[5].textContent = stCols.readAccessBits;
        stRow.cells[6].textContent = stCols.writeAccessBits;
        stRow.cells[7].textContent = stCols.readKeyB;
        stRow.cells[8].textContent = stCols.writeKeyB;
        stRow.cells[9].textContent = stCols.remarks;
    }

    // convert access and permission to bytes
    function encode() {
        let byte6 = 0xFF;
        let byte7 = 0x07;
        let byte8 = 0x80;

        let block0 = document.getElementById("db-row0");
        let block1 = document.getElementById("db-row1");
        let block2 = document.getElementById("db-row2");
        let block3 = document.getElementById("st-row0");

        let Cxy = {
            "C10": block0.cells[1].textContent,
            "C20": block0.cells[2].textContent,
            "C30": block0.cells[3].textContent,

            "C11": block1.cells[1].textContent,
            "C21": block1.cells[2].textContent,
            "C31": block1.cells[3].textContent,

            "C12": block2.cells[1].textContent,
            "C22": block2.cells[2].textContent,
            "C32": block2.cells[3].textContent,

            "C13": block3.cells[0].textContent,
            "C23": block3.cells[1].textContent,
            "C33": block3.cells[2].textContent,
        };

        let ICxy = {
            // Inverted values
            "IC10": Cxy.C10 ^ 1,
            "IC20": Cxy.C20 ^ 1,
            "IC30": Cxy.C30 ^ 1,

            "IC11": Cxy.C11 ^ 1,
            "IC21": Cxy.C21 ^ 1,
            "IC31": Cxy.C31 ^ 1,

            "IC12": Cxy.C12 ^ 1,
            "IC22": Cxy.C22 ^ 1,
            "IC32": Cxy.C32 ^ 1,

            "IC13": Cxy.C13 ^ 1,
            "IC23": Cxy.C23 ^ 1,
            "IC33": Cxy.C33 ^ 1,
        };

        byte6 = 
            ((ICxy.IC23 & 0x1) << 7) | 
            ((ICxy.IC22 & 0x1) << 6) | 
            ((ICxy.IC21 & 0x1) << 5) | 
            ((ICxy.IC20 & 0x1) << 4) |
            ((ICxy.IC13 & 0x1) << 3) | 
            ((ICxy.IC12 & 0x1) << 2) | 
            ((ICxy.IC11 & 0x1) << 1) | 
            ((ICxy.IC10 & 0x1) << 0);

        byte7 = 
            ((Cxy.C13 & 0x1) << 7) | 
            ((Cxy.C12 & 0x1) << 6) | 
            ((Cxy.C11 & 0x1) << 5) | 
            ((Cxy.C10 & 0x1) << 4) |
            ((ICxy.IC33 & 0x1) << 3) | 
            ((ICxy.IC32 & 0x1) << 2) | 
            ((ICxy.IC31 & 0x1) << 1) | 
            ((ICxy.IC30 & 0x1) << 0);

        byte8 = 
            ((Cxy.C33 & 0x1) << 7) | 
            ((Cxy.C32 & 0x1) << 6) | 
            ((Cxy.C31 & 0x1) << 5) | 
            ((Cxy.C30 & 0x1) << 4) |
            ((Cxy.C23 & 0x1) << 3) | 
            ((Cxy.C22 & 0x1) << 2) | 
            ((Cxy.C21 & 0x1) << 1) | 
            ((Cxy.C20 & 0x1) << 0);

        let finalAccessBits = byte6.toString(16).toUpperCase().padStart(2, '0') +
            byte7.toString(16).toUpperCase().padStart(2, '0') +
            byte8.toString(16).toUpperCase().padStart(2, '0');

        document.getElementById('access-bits').value = finalAccessBits;
    }
</script>
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<ul>
<li>This UI is inspired from this calculator: <a href="https://gitlab.com/limentas/mifare-calc">Mifarecalc</a></li>
<li><a href="https://github.com/akafugu/MIFARE-Classic-1K-Access-Bits-Calculator">MIFARE-Classic-1K-Access-Bits-Calculator </a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sd-card-sdcmmc"><a class="header" href="#sd-card-sdcmmc">SD Card (SDC/MMC)</a></h1>
<p>In this section, we will explore how to use the SD Card reader module. Depending on your project, you can use the SD card to store collected data from sensors, save game ROMs and progress, or store other types of information.</p>
<h2 id="mmc"><a class="header" href="#mmc">MMC</a></h2>
<p>The MultiMediaCard (MMC) was introduced as an early type of flash memory storage, preceding the SD Card. It was commonly used in devices such as camcorders, digital cameras, and portable music players. MMCs store data as electrical charges in flash memory cells, unlike optical disks, which rely on laser-encoded data on reflective surfaces.</p>
<h2 id="sd-secure-digital-card"><a class="header" href="#sd-secure-digital-card">SD (Secure Digital) Card</a></h2>
<p>The Secure Digital Card (SDC), commonly referred to as an SD Card, is an evolution of the MMC. SD Cards are widely used as external storage in electronic devices such as cameras, smartphones.  A smaller variant, the microSD card, is commonly used in smartphones, drones, and other devices.</p>
<img style="display: block; margin: auto;" alt="SD cards" src="sdcard/images/sd-cards.png" />
<p style="text-align: center; font-size: smaller; margin-top: 5px;">
Image credit: Based on <a href="https://en.wikipedia.org/wiki/File:SD_Cards.svg">SD card</a> by <a href="https://commons.wikimedia.org/wiki/User:Tkgd2007">Tkgd2007</a>, licensed under the GFDL and CC BY-SA 3.0, 2.5, 2.0, 1.0.
</p>

<p>SD cards read and write data in blocks, typically 512 bytes in size, allowing them to function as block devices; this makes SD cards behave much like hard drives.</p>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<p>To communicate with an SD card, we can use the SD Bus protocol, SPI protocol, or UHS-II Bus protocol. The Raspberry Pi (but not the Raspberry Pi Pico) uses the SD Bus protocol, which is more complex than SPI. The full specs of the SD Bus protocol are not accessible to the public and are only available through the SD Association. We will be using the SPI protocol, as the Rust driver we will be using is designed to work with it.</p>
<h2 id="hardware-requirements-5"><a class="header" href="#hardware-requirements-5">Hardware Requirements</a></h2>
<p>We’ll be using the Micro SD Card adapter module. You can search for either “Micro SD Card Reader Module” or “Micro SD Card Adapter” to find them.</p>
<img style="width: 450px;margin: auto;display: block; " alt="Micro SD Card adapter module" src="sdcard/images/micro-sd-card-adapter-reader-module.jpg" />
<p>And of course, you’ll need a microSD card. The SD card should be formatted with FAT32; Depending on your computer’s hardware, you might need a separate SD card adapter (not the one mentioned above) to format the microSD card. Some laptops comes with direct microSD card support.</p>
<h2 id="references-4"><a class="header" href="#references-4">References:</a></h2>
<ul>
<li>I highly recommend watching Jonathan Pallant’s <a href="https://www.youtube.com/watch?v=-ewuFNKIAVI">talk</a> at Euro Rust 2024 on writing an SD card driver in Rust.  He wrote the driver we are going to use (originally he created it to run MS-DOS on ARM). It is not intended for production systems.</li>
<li>If you want to understand how it works under the hood in SPI mode, you can refer to this article: <a href="http://elm-chan.org/docs/mmc/mmc_e.html">How to Use MMC/SDC</a></li>
<li><a href="https://en.wikipedia.org/wiki/SD_card">Wikipedia</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="电路-1"><a href="#电路-1" class="header">电路</a></h1>
<h2 id="circuit-2"><a class="header" href="#circuit-2">Circuit</a></h2>
<h3 id="microsd-card-pin-mapping-for-spi-mode"><a class="header" href="#microsd-card-pin-mapping-for-spi-mode">microSD Card Pin Mapping for SPI Mode</a></h3>
<p>We’ll focus only on the microSD card since that’s what we’re using. The microSD has 8 pins, but we only need 6 for SPI mode. You may have noticed that the SD card reader module we have also has only 6 pins, with markings for the SPI functions. The table below shows the microSD card pins and their corresponding SPI functions.</p>
<div style="display: flex; align-items: center;gap:18px;">
  <img style="width: 180px;" alt="microSD Card Pin Diagram" src="sdcard/images/micro-sd-card-pin.png" />
  
<table>
    
<thead>
      
<tr>
        <th>microSD Card Pin</th>
        <th>SPI Function</th>
      </tr>

    </thead>

    
<tbody>
      
<tr>
        <td>1</td>
        <td>-</td>
      </tr>

      
<tr>
        <td>2</td>
        <td>Chip Select (CS); also referred as Card Select</td>
      </tr>

      
<tr>
        <td>3</td>
        <td>Data Input (DI) - corresponds to MOSI. To receive data from the microcontroller.</td>
      </tr>

      
<tr>
        <td>4</td>
        <td>VDD - Power supply (3.3V)</td>
      </tr>

      
<tr>
        <td>5</td>
        <td>Serial Clock (SCK)</td>
      </tr>

      
<tr>
        <td>6</td>
        <td>Ground (GND)</td>
      </tr>

      
<tr>
        <td>7</td>
        <td>Data Output (DO) - corresponds to MISO. To send data from the microSD card to the microcontroller.</td>
      </tr>

      
<tr>
        <td>8</td>
        <td>-</td>
      </tr>

    </tbody>

  </table>

</div>

<h3 id="connecting-the-raspberry-pi-pico-to-the-sd-card-reader"><a class="header" href="#connecting-the-raspberry-pi-pico-to-the-sd-card-reader">Connecting the Raspberry Pi Pico to the SD Card Reader</a></h3>
<p>The microSD card operates at 3.3V, so using 5V to power it could damage the card. However, the reader module comes with an onboard voltage regulator and logic shifter, allowing it to safely be connected to the 5V power supply of the Pico.</p>
<table>
  
<thead>
    
<tr>
      <th>Pico Pin</th>
      <th style="width: 250px; margin: 0 auto;">Wire</th>
      <th>SD Card Pin</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>GPIO 1</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire green" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>CS</td>
    </tr>

    
<tr>
      <td>GPIO 2</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire blue" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>SCK</td>
    </tr>

    
<tr>
      <td>GPIO 3</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire orange" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>MOSI</td>
    </tr>

    
<tr>
      <td>GPIO 4</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire yellow" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>MISO</td>
    </tr>

        
<tr>
      <td>5V</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire red" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>VCC</td>
    </tr>

    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GND</td>
    </tr>

  </tbody>

</table>

<br />
<img style="display: block; margin: auto;" alt="SD Card reader pico connection" src="sdcard/images/sd-card-reader-module-pico-connection.jpg" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="read-sd-card-with-raspberry-pi-pico"><a class="header" href="#read-sd-card-with-raspberry-pi-pico">Read SD Card with Raspberry Pi Pico</a></h1>
<p>Let’s create a simple program that reads a file from the SD card and outputs its content over USB serial. Make sure the SD card is formatted with FAT32 and contains a file to read (for example, “RUST.TXT” with the content “Ferris”).</p>
<h3 id="project-from-template-5"><a class="header" href="#project-from-template-5">Project from template</a></h3>
<p>To set up the project, run:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.1.0
</code></pre>
<p>When prompted, give your project a name, like “read-sdcard” and select <code>RP-HAL</code> as the HAL.</p>
<p>Then, navigate into the project folder:</p>
<pre><code class="language-sh">cd PROJECT_NAME
# For example, if you named your project "read-sdcard":
# cd read-sdcard
</code></pre>
<h3 id="additional-crates-required-3"><a class="header" href="#additional-crates-required-3">Additional Crates required</a></h3>
<p>Update your Cargo.toml to add these additional crate along with the existing dependencies.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// USB serial communication
usbd-serial = "0.2.2"
usb-device = "0.3.2"
heapless = "0.8.0"

// To convert Spi bus to SpiDevice
embedded-hal-bus = "0.2.0"

// sd card driver
embedded-sdmmc = "0.8.1"
<span class="boring">}</span></code></pre>
<p>Except for the embedded-sdmmc crate, we have already used all these crates in previous exercises.</p>
<ul>
<li>The usbd-serial and usb-device crates are used for sending or receiving data to and from a computer via USB serial. The heapless crate acts as a helper, providing a buffer before printing data to USB serial.</li>
<li>The embedded-hal-bus crate offers the necessary traits for SPI and I²C buses, which are essential for interfacing the Pico with the SD card reader.</li>
<li>The embedded-sdmmc crate is a driver for reading and writing files on FAT-formatted SD cards.</li>
</ul>
<h3 id="additional-imports-6"><a class="header" href="#additional-imports-6">Additional imports</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use usb_device::{class_prelude::*, prelude::*};
use usbd_serial::SerialPort;

use hal::fugit::RateExtU32;
use heapless::String;

use core::fmt::Write;

use embedded_hal_bus::spi::ExclusiveDevice;
use embedded_sdmmc::{SdCard, TimeSource, Timestamp, VolumeIdx, VolumeManager};
<span class="boring">}</span></code></pre>
<p>Make sure to check out the <a href="#pico-to-pc">USB serial</a> tutorial for setting up the USB serial. We won’t go over the setup here to keep it simple.</p>
<h3 id="dummy-timesource"><a class="header" href="#dummy-timesource">Dummy Timesource</a></h3>
<p>The TimeSource is needed to retrieve timestamps and manage file metadata. Since we won’t be using this functionality, we’ll create a DummyTimeSource that implements the TimeSource trait. This is necessary for compatibility with the embedded-sdmmc crate.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Code from https://github.com/rp-rs/rp-hal-boards/blob/main/boards/rp-pico/examples/pico_spi_sd_card.rs
/// A dummy timesource, which is mostly important for creating files.
#[derive(Default)]
pub struct DummyTimesource();

impl TimeSource for DummyTimesource {
    // In theory you could use the RTC of the rp2040 here, if you had
    // any external time synchronizing device.
    fn get_timestamp(&amp;self) -&gt; Timestamp {
        Timestamp {
            year_since_1970: 0,
            zero_indexed_month: 0,
            zero_indexed_day: 0,
            hours: 0,
            minutes: 0,
            seconds: 0,
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="setting-up-the-spi-for-the-sd-card-reader"><a class="header" href="#setting-up-the-spi-for-the-sd-card-reader">Setting Up the SPI for the SD Card Reader</a></h3>
<p>Now, let’s configure the SPI bus and the necessary pins to communicate with the SD Card reader.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spi_cs = pins.gpio1.into_push_pull_output();
let spi_sck = pins.gpio2.into_function::&lt;hal::gpio::FunctionSpi&gt;();
let spi_mosi = pins.gpio3.into_function::&lt;hal::gpio::FunctionSpi&gt;();
let spi_miso = pins.gpio4.into_function::&lt;hal::gpio::FunctionSpi&gt;();
let spi_bus = hal::spi::Spi::&lt;_, _, _, 8&gt;::new(pac.SPI0, (spi_mosi, spi_miso, spi_sck));

let spi = spi_bus.init(
    &amp;mut pac.RESETS,
    clocks.peripheral_clock.freq(),
    400.kHz(), // card initialization happens at low baud rate
    embedded_hal::spi::MODE_0,
);

<span class="boring">}</span></code></pre>
<h3 id="getting-the-spidevice-from-spi-bus-1"><a class="header" href="#getting-the-spidevice-from-spi-bus-1">Getting the <code>SpiDevice</code> from SPI Bus</a></h3>
<p>To work with the embedded-sdmmc crate, we need an <code>SpiDevice</code>. Since we only have the SPI bus from RP-HAL, we’ll use the <code>embedded_hal_bus</code> crate to get the <code>SpiDevice</code> from the SPI bus.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spi = ExclusiveDevice::new(spi, spi_cs, timer).unwrap();
<span class="boring">}</span></code></pre>
<h3 id="setup-sd-card-driver"><a class="header" href="#setup-sd-card-driver">Setup SD Card driver</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sdcard = SdCard::new(spi, timer);
let mut volume_mgr = VolumeManager::new(sdcard, DummyTimesource::default());
<span class="boring">}</span></code></pre>
<h3 id="print-the-size-of-the-sd-card"><a class="header" href="#print-the-size-of-the-sd-card">Print the size of the SD Card</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match volume_mgr.device().num_bytes() {
    Ok(size) =&gt; {
        write!(buff, "card size is {} bytes\r\n", size).unwrap();
        serial.write(buff.as_bytes()).unwrap();
    }
    Err(e) =&gt; {
        write!(buff, "Error: {:?}", e).unwrap();
        serial.write(buff.as_bytes()).unwrap();
    }
}
<span class="boring">}</span></code></pre>
<h3 id="open-the-directory"><a class="header" href="#open-the-directory">Open the directory</a></h3>
<p>Let’s open the volume with the volume manager then open the root directory.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Ok(mut volume0) = volume_mgr.open_volume(VolumeIdx(0)) else {
    let _ = serial.write("err in open_volume".as_bytes());
    continue;
};

let Ok(mut root_dir) = volume0.open_root_dir() else {
    serial.write("err in open_root_dir".as_bytes()).unwrap();
    continue;
};
<span class="boring">}</span></code></pre>
<h3 id="open-the-file-in-read-only-mode"><a class="header" href="#open-the-file-in-read-only-mode">Open the file in read-only mode</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Ok(mut my_file) =  root_dir.open_file_in_dir("RUST.TXT", embedded_sdmmc::Mode::ReadOnly) else {
    serial.write("err in open_file_in_dir".as_bytes()).unwrap();
    continue;
};
<span class="boring">}</span></code></pre>
<h3 id="read-the-file-content-and-print"><a class="header" href="#read-the-file-content-and-print">Read the file content and print</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while !my_file.is_eof() {
    let mut buffer = [0u8; 32];
    let num_read = my_file.read(&amp;mut buffer).unwrap();
    for b in &amp;buffer[0..num_read] {
        write!(buff, "{}", *b as char).unwrap();
    }
}
serial.write(buff.as_bytes()).unwrap();
<span class="boring">}</span></code></pre>
<h2 id="full-code"><a class="header" href="#full-code">Full code</a></h2>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use embedded_hal::delay::DelayNs;
use hal::block::ImageDef;
use panic_halt as _;
use rp235x_hal::{self as hal, Clock};

use usb_device::{class_prelude::*, prelude::*};
use usbd_serial::SerialPort;

use hal::fugit::RateExtU32;
use heapless::String;

use core::fmt::Write;

use embedded_hal_bus::spi::ExclusiveDevice;
use embedded_sdmmc::{SdCard, TimeSource, Timestamp, VolumeIdx, VolumeManager};

#[link_section = ".start_block"]
#[used]
pub static IMAGE_DEF: ImageDef = hal::block::ImageDef::secure_exe();

const XTAL_FREQ_HZ: u32 = 12_000_000u32;

/// A dummy timesource, which is mostly important for creating files.
#[derive(Default)]
pub struct DummyTimesource();

impl TimeSource for DummyTimesource {
    // In theory you could use the RTC of the rp2040 here, if you had
    // any external time synchronizing device.
    fn get_timestamp(&amp;self) -&gt; Timestamp {
        Timestamp {
            year_since_1970: 0,
            zero_indexed_month: 0,
            zero_indexed_day: 0,
            hours: 0,
            minutes: 0,
            seconds: 0,
        }
    }
}

#[hal::entry]
fn main() -&gt; ! {
    let mut pac = hal::pac::Peripherals::take().unwrap();
    let mut watchdog = hal::Watchdog::new(pac.WATCHDOG);

    let clocks = hal::clocks::init_clocks_and_plls(
        XTAL_FREQ_HZ,
        pac.XOSC,
        pac.CLOCKS,
        pac.PLL_SYS,
        pac.PLL_USB,
        &amp;mut pac.RESETS,
        &amp;mut watchdog,
    )
    .ok()
    .unwrap();
    let mut timer = hal::Timer::new_timer0(pac.TIMER0, &amp;mut pac.RESETS, &amp;clocks);

    let sio = hal::Sio::new(pac.SIO);
    let pins = hal::gpio::Pins::new(
        pac.IO_BANK0,
        pac.PADS_BANK0,
        sio.gpio_bank0,
        &amp;mut pac.RESETS,
    );

    let usb_bus = UsbBusAllocator::new(hal::usb::UsbBus::new(
        pac.USB,
        pac.USB_DPRAM,
        clocks.usb_clock,
        true,
        &amp;mut pac.RESETS,
    ));

    let mut serial = SerialPort::new(&amp;usb_bus);

    let mut usb_dev = UsbDeviceBuilder::new(&amp;usb_bus, UsbVidPid(0x16c0, 0x27dd))
        .strings(&amp;[StringDescriptors::default()
            .manufacturer("implRust")
            .product("Ferris")
            .serial_number("TEST")])
        .unwrap()
        .device_class(2) // 2 for the CDC, from: https://www.usb.org/defined-class-codes
        .build();

    let spi_cs = pins.gpio1.into_push_pull_output();
    let spi_sck = pins.gpio2.into_function::&lt;hal::gpio::FunctionSpi&gt;();
    let spi_mosi = pins.gpio3.into_function::&lt;hal::gpio::FunctionSpi&gt;();
    let spi_miso = pins.gpio4.into_function::&lt;hal::gpio::FunctionSpi&gt;();
    let spi_bus = hal::spi::Spi::&lt;_, _, _, 8&gt;::new(pac.SPI0, (spi_mosi, spi_miso, spi_sck));

    let spi = spi_bus.init(
        &amp;mut pac.RESETS,
        clocks.peripheral_clock.freq(),
        400.kHz(), // card initialization happens at low baud rate
        embedded_hal::spi::MODE_0,
    );

    let spi = ExclusiveDevice::new(spi, spi_cs, timer).unwrap();
    let sdcard = SdCard::new(spi, timer);
    let mut buff: String&lt;64&gt; = String::new();

    let mut volume_mgr = VolumeManager::new(sdcard, DummyTimesource::default());

    let mut is_read = false;
    loop {
        let _ = usb_dev.poll(&amp;mut [&amp;mut serial]);
        if !is_read &amp;&amp; timer.get_counter().ticks() &gt;= 2_000_000 {
            is_read = true;
            serial
                .write("Init SD card controller and retrieve card size...".as_bytes())
                .unwrap();
            match volume_mgr.device().num_bytes() {
                Ok(size) =&gt; {
                    write!(buff, "card size is {} bytes\r\n", size).unwrap();
                    serial.write(buff.as_bytes()).unwrap();
                }
                Err(e) =&gt; {
                    write!(buff, "Error: {:?}", e).unwrap();
                    serial.write(buff.as_bytes()).unwrap();
                }
            }
            buff.clear();

            let Ok(mut volume0) = volume_mgr.open_volume(VolumeIdx(0)) else {
                let _ = serial.write("err in open_volume".as_bytes());
                continue;
            };

            let Ok(mut root_dir) = volume0.open_root_dir() else {
                serial.write("err in open_root_dir".as_bytes()).unwrap();
                continue;
            };

            let Ok(mut my_file) =
                root_dir.open_file_in_dir("RUST.TXT", embedded_sdmmc::Mode::ReadOnly)
            else {
                serial.write("err in open_file_in_dir".as_bytes()).unwrap();
                continue;
            };

            while !my_file.is_eof() {
                let mut buffer = [0u8; 32];
                let num_read = my_file.read(&amp;mut buffer).unwrap();
                for b in &amp;buffer[0..num_read] {
                    write!(buff, "{}", *b as char).unwrap();
                }
            }
            serial.write(buff.as_bytes()).unwrap();
        }
        buff.clear();

        timer.delay_ms(50);
    }
}

#[link_section = ".bi_entries"]
#[used]
pub static PICOTOOL_ENTRIES: [hal::binary_info::EntryAddr; 5] = [
    hal::binary_info::rp_cargo_bin_name!(),
    hal::binary_info::rp_cargo_version!(),
    hal::binary_info::rp_program_description!(c"USB Fun"),
    hal::binary_info::rp_cargo_homepage_url!(),
    hal::binary_info::rp_program_build_attribute!(),
];</code></pre>
<h2 id="clone-the-existing-project-20"><a class="header" href="#clone-the-existing-project-20">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>read-sdcard</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/read-sdcard/
</code></pre>
<h2 id="how-to-run--3"><a class="header" href="#how-to-run--3">How to Run ?</a></h2>
<p>The method to flash (run the code) on the Pico is the same as usual. However, we need to set up tio to interact with the Pico through the serial port (/dev/ttyACM0). This allows us to read data from the Pico or send data to it.</p>
<h3 id="tio-2"><a class="header" href="#tio-2">tio</a></h3>
<p>Make sure you have tio installed on your system. If not, you can install it using:</p>
<pre><code class="language-sh">apt install tio
</code></pre>
<h3 id="connecting-to-the-serial-port-3"><a class="header" href="#connecting-to-the-serial-port-3">Connecting to the Serial Port</a></h3>
<p>Run the following command to connect to the Pico’s serial port:</p>
<pre><code class="language-sh">tio /dev/ttyACM0
</code></pre>
<p>This will open a terminal session for communicating with the Pico.</p>
<h3 id="flashing-and-running-the-code-3"><a class="header" href="#flashing-and-running-the-code-3">Flashing and Running the Code</a></h3>
<p>Open another terminal, navigate to the project folder, and flash the code onto the Pico as usual:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>If everything is set up correctly, you should see a “Connected” message in the tio terminal. It will then print the card size and the content of the file once the timer’s ticks reach 2,000,000.</p>
<img style="display: block; margin: auto;" src="sdcard/images/sd-card-read-output.png" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lcd-display"><a class="header" href="#lcd-display">LCD Display</a></h1>
<p>In this section, we will be using Hitachi HD44780 compatible LCD (Liquid Crystal Display) displays. You might have seen them in devices like printers, digital clocks, microwaves, washing machines, air conditioners, and other home appliances. They’re also used in equipment like copiers, fax machines, and routers.</p>
<p>You can display ASCII character and up to 8 custom characters.</p>
<img style="display: block; margin: auto;width:500px;" alt="lcd1602" src="lcd-display/images/lcd1602.jpg" />
<h2 id="variants"><a class="header" href="#variants">Variants</a></h2>
<p>It comes in various variants, such as 16x2 (16 columns, 2 rows) and 20x4 (20 columns, 4 rows), and also based on backlight color (blue, yellow, or green). The one I have displays white characters with a blue backlight. However, you can choose any variant as it won’t significantly affect the code.  Most of these variants will have 16 pins.</p>
<h3 id="i2c-variants"><a class="header" href="#i2c-variants">I2C variants</a></h3>
<p>Some variants come with an I2C interface adapter, so you can use I2C for communication. The main advantage of I2C variant is that it reduces the number of pin connections. However, we’ll be working with the parallel interface instead.</p>
<p>You can also buy the I2C interface adapter separately and solder it later.</p>
<img style="display: block; margin: auto;width:400px;" alt="lcd1602 I2C" src="lcd-display/images/lcd1602-i2c.jpg" />
<h2 id="hardware-requirements-6"><a class="header" href="#hardware-requirements-6">Hardware Requirements</a></h2>
<ul>
<li><strong>LCD Display (LCD1602):</strong> I would recommend getting a 16x2 so you can follow along.</li>
<li><strong>Potentiometer (Optional):</strong> This is used to control the LCD contrast. I didn’t have one at the moment, so I used resistors instead.</li>
<li><strong>Resistors (Optional):</strong> Two 1K resistors. If you have a potentiometer, you can ignore this. I used these to control the contrast.</li>
<li><strong>Jump Wires:</strong> A lot! We’ll need around 15+ jump wires since we’re using a parallel interface (not I2C), which requires connecting many pins.</li>
</ul>
<h2 id="datasheet-1"><a class="header" href="#datasheet-1">Datasheet</a></h2>
<ul>
<li>You can access the datasheet for the HD44780 from <a href="https://www.sparkfun.com/datasheets/LCD/HD44780.pdf">Sparkfun</a> or <a href="https://academy.cba.mit.edu/classes/output_devices/44780.pdf">MIT site</a></li>
<li><a href="https://www.crystalfontz.com/controllers/datasheet-viewer.php?id=433">LCD Driver Data Book</a></li>
<li><a href="https://www.openhacks.com/uploadsproductos/eone-1602a1.pdf">LCD Module 1602A Datasheet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="how-it-works-1"><a class="header" href="#how-it-works-1">How it works?</a></h1>
<p>A Liquid Crystal Display (LCD) uses liquid crystals to control light. When electricity is applied, the crystals change orientation, either allowing light to pass through or blocking it, creating images or text. A backlight illuminates the screen, and colored sub-pixels (red, green, and blue) combine to form various colors. The crystals can also turn opaque in specific areas, blocking the backlight and creating dark regions to display characters.</p>
<h3 id="16x2-lcd-display-and-5x8-pixel-matrix"><a class="header" href="#16x2-lcd-display-and-5x8-pixel-matrix">16x2 LCD Display and 5x8 Pixel Matrix</a></h3>
<p>A 16x2 LCD has 2 rows and 16 columns, allowing it to display 32 characters in total. Each character is made up of a 5x8 pixel grid, where 5 columns and 8 rows of pixels form the shape of the character. This grid is used to display text and simple symbols on the screen.</p>
<img style="display: block; margin: auto;" alt="lcd1602" src="lcd-display/images/lcd1602-pixel-layout.png" />
<h3 id="displaying-text-and-custom-characters-on-16x2-lcd"><a class="header" href="#displaying-text-and-custom-characters-on-16x2-lcd">Displaying Text and Custom Characters on 16x2 LCD</a></h3>
<p>We don’t have to manually draw the pixels; This is taken care of by the HD44780 IC, which automatically maps ASCII characters to the 5x8 pixel grid.</p>
<p>However, if you’d like to create custom characters or symbols, you will need to define the 5x8 pixel pattern yourself. This pattern is saved in the LCD’s memory, and once it’s defined, you can use the custom character. Keep in mind, only up to 8 custom characters can be stored at a time.</p>
<h3 id="data-transfer-mode"><a class="header" href="#data-transfer-mode">Data transfer mode</a></h3>
<p>The LCM (Liquid Crystal Module) supports two types of data transfer modes: 8-bit and 4-bit. In 8-bit mode, data is sent as a full byte using all the data pins. In 4-bit mode, only the higher-order data bits are used, sending data in nibbles. While 8-bit mode is faster, it comes with a trade-off;using too many wires, which can quickly exhaust the GPIO pins on a microcontroller. To minimize wiring, we’ll use 4-bit mode.</p>
<h3 id="reference-7"><a class="header" href="#reference-7">Reference:</a></h3>
<ul>
<li><a href="http://www.efton.sk/curious/lcd1602.htm">16x2 character LCD dot matrix module</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="引脚布局"><a href="#引脚布局" class="header">引脚布局</a></h1>
<h2 id="pin-layout"><a class="header" href="#pin-layout">Pin Layout</a></h2>
<p>The LCD has a total of 16 pins for the parallel interface.</p>
<img style="display: block; margin: auto;" alt="lcd1602" src="lcd-display/images/lcd1602-pin-layout.jpg" />
<br />
 
<table border="1" style="border-collapse: collapse; width: 100%;">
  
<thead>
    
<tr>
      <th>Pin Position</th>
      <th style="width:14%">LCD Pin</th>
      <th>Details</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>1</td>
      <td><span class="slanted-text black">VSS</span></td>
      <td>Should be connected to the Ground.</td>
    </tr>

    
<tr>
      <td>2</td>
      <td><span class="slanted-text red">VSS</span></td>
      <td>Power supply (5V) for the logic</td>
    </tr>

    
<tr>
      <td>3</td>
      <td><span class="slanted-text purple">V<sub>O</sub></span></td>
      <td>
        Contrast adjustment:<br>
        - If you use a potentiometer (10k), connect the middle pin to adjust the contrast. Other pins of the potentiometer should be connected to 5V (or 3.3V) and GND.<br>
        - I used two 1k resistors instead, which was sufficient for this exercise.
      </td>
    </tr>

    
<tr>
      <td>4</td>
      <td><span class="slanted-text indigo">RS</span></td>
      <td>
        Register select pin:<br>
        - Set LOW (RS = 0) to send commands to the LCD.<br>
        - Set HIGH (RS = 1) to send data to the LCD.
      </td>
    </tr>

    
<tr>
      <td>5</td>
      <td><span class="slanted-text brown">RW</span></td>
      <td>
        Read/Write pin:<br>
        - Set LOW (RW = 0) to write to the LCD, which is what we will mostly do.<br>
        - Set HIGH (RW = 1) to read from the LCD (rarely used).<br>
        - We will connect this to Ground since we’re only writing.
      </td>
    </tr>

    
<tr>
      <td>6</td>
      <td><span class="slanted-text green">E</span></td>
      <td>
        The Enable pin is pulsed high and then brought back to low (ground) to trigger the LCD to accept and process data.
      </td>
    </tr>

    
<tr>
      <td>7-10</td>
      <td><span class="slanted-text black">D0 - D3</span></td>
      <td>These are the 4 lower-order data bits, used only in 8-bit mode. If you are using 4-bit mode, leave these pins unconnected.</td>
    </tr>

    
<tr>
      <td>11-14</td>
      <td><span class="slanted-text blue">D4 - D7</span></td>
      <td>These are the 4 higher-order data bits, used to represent the data in 4-bit mode.</td>
    </tr>

    
<tr>
      <td>15</td>
      <td><span class="slanted-text red">A</span></td>
      <td>Anode of the backlight. Should be connected to 5V.</td>
    </tr>

    
<tr>
      <td>16</td>
      <td><span class="slanted-text black">K</span></td>
      <td>Cathode of the backlight. Should be connected to Ground.</td>
    </tr>

  </tbody>

</table>

<h3 id="contrast-adjustment"><a class="header" href="#contrast-adjustment">Contrast Adjustment</a></h3>
<p>The V<sub>o</sub> pin  controls the contrast of the LCD.</p>
<p>According to the datasheet of the <a href="https://www.openhacks.com/uploadsproductos/eone-1602a1.pdf">LCD1602A</a>, the <strong>Vo</strong> pin controls the contrast of the LCD by adjusting the operating voltage for the LCD, which is the difference between the power supply for the logic (<strong>VDD</strong>) and the contrast control pin (<strong>Vo</strong>). When <strong>Vo</strong> is closer to ground, the voltage difference (<strong>VDD - Vo</strong>) is larger, resulting in a higher contrast, making the text on the screen more distinct and readable. When <strong>Vo</strong> is closer to <strong>VDD</strong>, the voltage difference decreases, resulting in a lower contrast, causing the text to appear faded or less visible.</p>
<img style="display: block; margin: auto;width:500px;" alt="lcd1602" src="lcd-display/images/power-supply.png" />
<p>You can use the potentiometer to adjust the contrast on the fly. You have to connect the middle pin of the potentiometer to Vo, and the other two pins to VCC and Ground.</p>
<p>You can also use resistors to adjust the contrast, which is what I did. You need to adjust the contrast one way or another. The first time I ran the program, I couldn’t see the text clearly. I placed two 1k resistors(when I added only one 1k resistor, it didn’t look that great) between Ground and the Vo, and then the text became visible.</p>
<h3 id="register-select-pin-rs"><a class="header" href="#register-select-pin-rs">Register Select Pin (RS)</a></h3>
<p>The Register Select (RS) pin determines whether the LCD is in command mode or data mode.</p>
<p>When it is in Low(RS = 0), the LCD is in command mode, where the input is interpreted as a command, such as clearing the display or setting the cursor position (e.g., sending a command to clear the display).</p>
<p>When it is in High(RS = 1), the LCD is in data mode, where the input is interpreted as data to be displayed on the screen (e.g., sending text to display).</p>
<h3 id="enable-pin-e"><a class="header" href="#enable-pin-e">Enable Pin (E)</a></h3>
<p>It is used to control when data is transferred to the LCD display. The enable pin is typically kept low (E=0) but is set high (E=1) for a specific period of time to initiate a data transfer, and then returned to low.. The data is latched into the LCD on the transition from high to low.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="circuit-3"><a class="header" href="#circuit-3">Circuit</a></h1>
<h2 id="connecting-lcd-display-lcd1602-to-the-raspberry-pi-pico"><a class="header" href="#connecting-lcd-display-lcd1602-to-the-raspberry-pi-pico">Connecting LCD Display (LCD1602) to the Raspberry Pi Pico</a></h2>
<p>We will be using parallel interface in 4bit mode. Remaining Pins like D0 to D3 won’t be connected.</p>
<table>
  
<thead>
    
<tr>
      <th style="width: 250px;">LCD Pin</th>
      <th style="width: 250px; text-align: center;">Wire</th>
      <th>Pico Pin</th>
      <th>Notes</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>VSS</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GND</td>
      <td>Ground</td>
    </tr>

    
<tr>
      <td>VDD</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire red" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>VBUS (5V)</td>
      <td>Power Supply</td>
    </tr>

    
<tr>
      <td>V<sub>O</sub></td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire brown" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GND or Potentiometer</td>
      <td>You can use Potentiometer or resistors to adjust the contrast. I placed two 1K resistors in between Ground and V<sub>O</sub></td>
    </tr>

    
<tr>
      <td>RS</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire yellow" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GPIO 16</td>
      <td>Register Select (0 = command, 1 = data)</td>
    </tr>

    
<tr>
      <td>RW</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GND</td>
      <td>Read/Write. Set '0' to write to display. If you want to read from display, set '1'</td>
    </tr>

    
<tr>
      <td>EN</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire green" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GPIO 17</td>
      <td>Enable</td>
    </tr>

    
<tr>
      <td>D4</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire orange" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GPIO 18</td>
      <td>Data Bit 4</td>
    </tr>

    
<tr>
      <td>D5</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire blue" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GPIO 19</td>
      <td>Data Bit 5</td>
    </tr>

    
<tr>
      <td>D6</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire brown" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GPIO 20</td>
      <td>Data Bit 6</td>
    </tr>

    
<tr>
      <td>D7</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire purple" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GPIO 21</td>
      <td>Data Bit 7</td>
    </tr>

    
<tr>
      <td>A</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire red" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>3V3(OUT)</td>
      <td>LED Backlight +</td>
    </tr>

    
<tr>
      <td>K</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GND</td>
      <td>LED Backlight -</td>
    </tr>

  </tbody>

</table>

<br />
<img style="display: block; margin: auto;" alt="lcd1602" src="lcd-display/images/connecting-pico-with-lcd-display-lcd1602.jpg" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hello-rust-in-lcd-display"><a class="header" href="#hello-rust-in-lcd-display">“Hello, Rust!” in LCD Display</a></h1>
<p>In this program, we will just print “Hello, Rust!” text in the LCD display.</p>
<h2 id="hd44780-drivers"><a class="header" href="#hd44780-drivers">HD44780 Drivers</a></h2>
<p>During my research, I came across many Rust crates for controll the LCD Display, but these two stood out as working well. In this program, we will start by using the <code>hd44780-driver</code> crate.</p>
<ul>
<li><a href="https://crates.io/crates/hd44780-driver">hd44780-driver</a></li>
<li><a href="https://crates.io/crates/liquid_crystal">liquid_crystal</a></li>
</ul>
<h3 id="project-from-template-6"><a class="header" href="#project-from-template-6">Project from template</a></h3>
<p>To set up the project, run:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.1.0
</code></pre>
<p>When prompted, give your project a name, like “lcd-hello” and select <code>RP-HAL</code> as the HAL.</p>
<p>Then, navigate into the project folder:</p>
<pre><code class="language-sh">cd PROJECT_NAME
# For example, if you named your project "lcd-hello":
# cd lcd-hello
</code></pre>
<h3 id="additional-crates-required-4"><a class="header" href="#additional-crates-required-4">Additional Crates required</a></h3>
<p>Update your Cargo.toml to add these additional crate along with the existing dependencies.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>hd44780-driver = "0.4.0"
<span class="boring">}</span></code></pre>
<h3 id="additional-imports-7"><a class="header" href="#additional-imports-7">Additional imports</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hd44780_driver::HD44780;
<span class="boring">}</span></code></pre>
<h3 id="mapping-pico-and-lcd-pins"><a class="header" href="#mapping-pico-and-lcd-pins">Mapping Pico and LCD Pins</a></h3>
<p>We connect GPIO16 to the RS pin, GPIO17 to the Enable (E) pin, and GPIO18-21 to the D4-D7 data pins of the LCD. We’re using only 4 data pins since we will be working on 4-bit mode.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Read Select Pin
let rs = pins.gpio16.into_push_pull_output();

// Enable Pin
let en = pins.gpio17.into_push_pull_output();

// Data Pins
let d4 = pins.gpio18.into_push_pull_output();
let d5 = pins.gpio19.into_push_pull_output();
let d6 = pins.gpio20.into_push_pull_output();
let d7 = pins.gpio21.into_push_pull_output();

<span class="boring">}</span></code></pre>
<h3 id="write-text-to-the-lcd"><a class="header" href="#write-text-to-the-lcd">Write Text to the LCD</a></h3>
<p>Here, we initialize the LCD module, clear the screen, and then write the text “Hello, Rust!”.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// LCD Init
let mut lcd = HD44780::new_4bit(rs, en, d4, d5, d6, d7, &amp;mut timer).unwrap();

// Clear the screen
lcd.reset(&amp;mut timer).unwrap();
lcd.clear(&amp;mut timer).unwrap();

// Write to the top line
lcd.write_str("Hello, Rust!", &amp;mut timer).unwrap();
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-21"><a class="header" href="#clone-the-existing-project-21">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>lcd-hello</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/lcd-hello/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="支持的字符"><a href="#支持的字符" class="header">支持的字符</a></h1>
<h2 id="supported-characters"><a class="header" href="#supported-characters">Supported Characters</a></h2>
<p>When referring to the HD44780 datasheet, you’ll find two character set tables corresponding to two different ROM versions(A00 and A02). To determine which ROM your display uses, try unique characters from both tables. The one that displays correctly indicates the ROM version. Once identified, you only need to refer to the relevant table.</p>
<p>In my case, the LCD module I’m using is based on ROM version A00. I’ll present the A00 table and explain how to interpret it, though the interpretation logic is the same for both versions.</p>
<img style="display: block; margin: auto;" alt="lcd1602" src="lcd-display/images/lcd1602-characters-set.png" />
<p>It’s an 8-bit character, where the upper 4 bits come first, followed by the lower 4 bits, to form the complete character byte. In the reference table, the upper 4 bits correspond to the columns, while the lower 4 bits correspond to the rows.</p>
<p>For example, to get the binary representation of the character “#,” the upper 4 bits are 0010, and the lower 4 bits are 0011. Combining them gives the full binary value 00100011. In Rust, you can represent this value either in binary (0b00100011) or as a hexadecimal (0x23).</p>
<h3 id="hd44780-driver-crate"><a class="header" href="#hd44780-driver-crate">hd44780-driver crate</a></h3>
<p>In the <code>hd44780-driver</code> crate we are using, we can write characters directly as a single byte or a sequence of bytes.</p>
<h4 id="write-single-byte"><a class="header" href="#write-single-byte">Write single byte</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lcd.write_byte(0x23, &amp;mut timer).unwrap();
lcd.write_byte(0b00100011, &amp;mut timer).unwrap();
<span class="boring">}</span></code></pre>
<h4 id="write-multiple-bytes"><a class="header" href="#write-multiple-bytes">Write multiple bytes</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lcd.write_bytes(&amp;[0x23, 0x24], &amp;mut timer).unwrap();
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="自定义字符"><a href="#自定义字符" class="header">自定义字符</a></h1>
<h2 id="custom-characters"><a class="header" href="#custom-characters">Custom Characters</a></h2>
<p>Besides the supported characters, you can create your own custom ones, like smileys or heart symbols. The module includes 64 bytes of Character Generator RAM (CGRAM), allowing up to 8 custom characters.</p>
<p>Each character is an 8x8 grid, where each row is represented by a single 8-bit value (<code>u8</code>). This makes it 8 bytes per character (8 rows × 1 byte per row). That’s why, with a total of 64 bytes, you can only store up to 8 custom characters (8 chars × 8 bytes = 64 bytes).</p>
<img style="display: block; margin: auto;width:400px;" alt="custom characters grid" src="lcd-display/images/custom-character-grid-bits.jpg" />
<p>Note: If you recall, in our LCD module, each character is represented as a 5x8 grid. But wait, didn’t we say we need an 8x8 grid for the characters? Yes, that’s correct-we need 8 x 8 (8 bytes) memory, but we only use 5 bits in each row. The 3 high-order bits in each row are left as zeros.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="生成器"><a href="#生成器" class="header">生成器</a></h1>
<h2 id="lcd-custom-character-generator-5x8-grid"><a class="header" href="#lcd-custom-character-generator-5x8-grid">LCD Custom Character Generator (5x8 Grid)</a></h2>
<p>Select the grids to create a symbol or character. As you select the grid, the corresponding bits in the byte array will be updated.</p>
<style>
    .container {
        display: flex;
        align-items: flex-start;
        gap: 20px;
    }

    .grid-wrapper {
        background-color: #0076CE;
        padding: 10px;
        width: 250px;
        height: auto;
        box-sizing: border-box;
        /* display: flex; */
        justify-content: center;
        align-items: center;
        margin-bottom: 10px;
    }

    .grid {
        display: grid;
        grid-template-columns: repeat(5, 40px);
        grid-template-rows: repeat(8, 40px);
        gap: 5px;
        margin-bottom: 10px;
    }

    .cell {
        width: 40px;
        height: 40px;
        background-color: #0076CE;
        border: 1px solid white;
        outline: none;
        cursor: pointer;
    }

    .cell.selected {
        background-color: white;
    }

    .output {
        margin-top: 20px;
        font-family: monospace;
        text-align: center;
        margin-left: 100px;
    }

    code {
        background-color: #eee;
        padding: 5px;
        border-radius: 5px;
        display: block !important;
        width: 100%;
        white-space: pre-wrap;
        text-align: left;
    }

    .button-wrapper {
        display: flex;
        justify-content: flex-start;
        gap: 10px;
        margin-top: 10px;
    }

    button {
        padding: 10px;
        margin: 5px;
        background-color: #0076CE;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }

    button:hover {
        background-color: #005f8c;
    }

    .text-left {
        text-align: left;
    }
</style>
<div class="container">
    
<div class="grid-wrapper">
        
<div class="grid" id="grid"></div>

    </div>

    
<div class="output" id="output-2">
        
<h4 class="text-left">Generated Array</h4>

        <code id="rust-code"></code>
        
<div class="button-wrapper">
            <button id="copy-btn">Copy</button>
        </div>

    </div>

</div>

<div class="button-wrapper">
    <button id="clear-btn">Clear</button>
    <button id="invert-btn">Invert</button>
</div>

<script>
    const gridContainer = document.getElementById('grid');
    const outputContainer = document.getElementById('rust-code');
    const clearButton = document.getElementById('clear-btn');
    const invertButton = document.getElementById('invert-btn');
    const copyButton = document.getElementById('copy-btn');
    const rows = 8;
    const cols = 5;

    for (let i = 0; i < rows * cols; i++) {
        const cell = document.createElement('button');
        cell.classList.add('cell');
        cell.dataset.row = Math.floor(i / cols);
        cell.dataset.col = i % cols;
        cell.addEventListener('click', () => {
            cell.classList.toggle('selected');
            updateOutput();
        });
        gridContainer.appendChild(cell);
    }

    function updateOutput() {
        let rustArray = [];
        for (let r = 0; r < rows; r++) {
            let rowArray = [];
            for (let c = 0; c < cols; c++) {
                const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                rowArray.push(cell.classList.contains('selected') ? '1' : '0');
            }
            rustArray.push(`0b${rowArray.join('')},`);
        }
        let tc = "[\n" + `    ${rustArray.join('\n    ')}` + "\n]";
        outputContainer.textContent = tc;
    }

    updateOutput();

    clearButton.addEventListener('click', () => {
        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => cell.classList.remove('selected'));
        updateOutput();
    });

    invertButton.addEventListener('click', () => {
        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => {
            cell.classList.toggle('selected');
        });
        updateOutput();
    });

    copyButton.addEventListener('click', () => {
        const trimmedCode = outputContainer.textContent
            .replace(/\s+/g, ' ')
            .replace(/,\s+/g, ', ')
            .trim();
        navigator.clipboard.writeText(trimmedCode).then(() => {
            alert('Code copied to clipboard!');
        }).catch(err => {
            console.error('Error copying code: ', err);
        });
    });

</script>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="在-lcd-上显示"><a href="#在-lcd-上显示" class="header">在 LCD 上显示</a></h1>
<h2 id="ferris-on-lcd-display"><a class="header" href="#ferris-on-lcd-display">Ferris on LCD Display</a></h2>
<p>Let’s create Ferris (my attempt to make it look like a crab; if you have a better design, feel free to send a pull request) using a single character. In fact, we can combine 4 or 6 adjacent grids to display a single symbol. Creativity is up to you, and you can improve it however you like.</p>
<p>We’ll use the custom character generator from the previous page to create this symbol. This will give us the byte array that we can use.</p>
<img style="display: block; margin: auto;" alt="lcd1602" src="lcd-display/images/custom-character-ferris.png" />
<p>Note that the previous crate hd44780-driver doesn’t support custom characters. To handle this, we can use the liquid_crystal crate, which allows us to work with custom characters.</p>
<h3 id="initialize-the-lcd-interface"><a class="header" href="#initialize-the-lcd-interface">Initialize the LCD interface</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut lcd_interface = Parallel::new(d4, d5, d6, d7, rs, en, lcd_dummy);
let mut lcd = LiquidCrystal::new(&amp;mut lcd_interface, Bus4Bits, LCD16X2);
lcd.begin(&amp;mut timer);
<span class="boring">}</span></code></pre>
<h3 id="our-generated-byte-array-for-the-custom-character"><a class="header" href="#our-generated-byte-array-for-the-custom-character">Our generated byte array for the custom character</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    const FERRIS: [u8; 8] = [
        0b01010, 0b10001, 0b10001, 0b01110, 0b01110, 0b01110, 0b11111, 0b10001,
    ];
    // Define the character
    lcd.custom_char(&amp;mut timer, &amp;FERRIS, 0);
<span class="boring">}</span></code></pre>
<h3 id="displaying"><a class="header" href="#displaying">Displaying</a></h3>
<p>Displaying the character is straightforward. You just need to use the CustomChar enum and pass the index of the custom character. We’ve defined only one custom character, which is at position 0.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    lcd.write(&amp;mut timer, CustomChar(0));
    lcd.write(&amp;mut timer, Text(" implRust!"));
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-22"><a class="header" href="#clone-the-existing-project-22">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>lcd-custom</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/lcd-custom/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="多字符生成器"><a href="#多字符生成器" class="header">多字符生成器</a></h1>
<h2 id="multi-custom-character-generator"><a class="header" href="#multi-custom-character-generator">Multi Custom Character Generator</a></h2>
<p>This is used when you want to combine multiple grids to create a symbol. You can utilize adjacent grids on the 16x2 LCD display to design a custom symbol or character.  You can view the example symbol created with this generator and how to use in Rust in the next page.</p>
<style>
    .container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap:0 10px;
    }

    .grid-wrapper {
        background-color: #0076CE;
        padding: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        align-items: center;
        margin-bottom: 10px;
    }

    .grid {
        display: grid;
        grid-template-columns: repeat(5, 20px);
        grid-template-rows: repeat(8, 20px);
        gap: 5px;
    }

    .cell {
        width: 20px;
        height: 20px;
        background-color: #0076CE;
        border: 1px solid white;
        outline: none;
        cursor: pointer;
    }

    .cell.selected {
        background-color: white;
    }

    .output {
        margin-top: 20px;
        font-family: monospace;
        text-align: center;
        width: 100%;
    }

    code {
        background-color: #eee;
        padding: 5px;
        border-radius: 5px;
        display: block !important;
        width: 100%;
        white-space: pre-wrap;
        text-align: left;
    }

    .button-wrapper {
        display: flex;
        justify-content: flex-start;
        gap: 4px;
        margin-top: 10px;
        margin-bottom: 10px;
    }

    button {
        padding: 8px;
        margin: 5px;
        background-color: #0076CE;
        color: white;
        border: none;
        /* border-radius: 5px; */
        cursor: pointer;
    }

    button:hover {
        background-color: #005f8c;
    }

    .text-left {
        text-align: left;
    }
    
   .custom-char-tbl {
    width: 100%;
    border-collapse: collapse;
     border: none; 
}

.custom-char-tbl td {
    width: auto;
    height: auto;
    text-align: center;
    vertical-align: middle;
    padding: 0; 
     border: none; 
}

.grid {
    display: grid;
    grid-template-columns: repeat(5, 20px);
    grid-template-rows: repeat(8, 20px);
    gap: 5px;
    margin: auto;
}

.cell {
    width: 20px;
    height: 20px;
    background-color: #0076CE;
    border: 1px solid white;
    outline: none;
    cursor: pointer;
}

.cell.selected {
    background-color: white;
}

.custom-char-tbl td div.grid {
    margin: auto; 
    width: calc(20px * 5 + 5px * 6); 
    height: calc(20px * 8 + 5px * 10); 
}

</style>
<div class="container">
    
<div class="button-wrapper">
        <button id="clear-btn-1">Clear</button>
        <button id="invert-btn-1">Invert</button>
        <select id="grid-size">
            <option value="2">2 Grids</option>
            <option value="4">4 Grids</option>
            <option value="6">6 Grids</option>
            <option value="8">8 Grids</option>
        </select>
        <select id="grid-layout">
            <option value="single-row">Single Row</option>
            <option value="single-column">Single Column</option>
        </select>
    </div>

    
<div class="grid-wrapper" id="grid-wrapper"></div>

    
<div class="output" id="output-3">
        
<h4 class="text-left">Generated Array</h4>

        <code id="rust-code-1"></code>
        
<div class="button-wrapper">
            <button id="copy-btn-1">Copy</button>
        </div>

    </div>

</div>

<script>
    const gridWrapper = document.getElementById('grid-wrapper');
    const outputContainer = document.getElementById('rust-code');
    const clearButton = document.getElementById('clear-btn');
    const invertButton = document.getElementById('invert-btn');
    const copyButton = document.getElementById('copy-btn');
    const gridSizeSelector = document.getElementById('grid-size');
    const gridLayoutSelector = document.getElementById('grid-layout');

    let gridCount = parseInt(gridSizeSelector.value);
    let layout = gridLayoutSelector.value;

    // Function to create and validate grid layout
    function validateLayout() {
        const gridSize = parseInt(gridSizeSelector.value);

        if (gridSize === 4) {
            gridLayoutSelector.innerHTML = `
                <option value="single-row">Single Row</option>
                <option value="two-rows">2 Rows</option>
            `;
        } else if (gridSize === 6 || gridSize === 8) {
            gridLayoutSelector.innerHTML = `
                <option value="single-row">Single Row</option>
                <option value="two-rows">2 Rows</option>
            `;
        } else {
            gridLayoutSelector.innerHTML = `
                <option value="single-row">Single Row</option>
                <option value="single-column">Single Column</option>
            `;
        }

        // Always default to the first valid layout
        gridLayoutSelector.value = gridLayoutSelector.options[0].value;
    }

    // Function to adjust cell size based on grid count
    // function adjustCellSize(count) {
    //     const cells = document.querySelectorAll('.cell');
    //     let cellSize = 40; // Default size

    //     if (count === 6) {
    //         cellSize = 20; // Smaller size for 6 grids
    //     } else if (count === 8) {
    //         cellSize = 20; // Smaller size for 8 grids
    //     }

    //     cells.forEach(cell => {
    //         cell.style.width = `${cellSize}px`;
    //         cell.style.height = `${cellSize}px`;
    //     });
    // }

    // Function to create grids inside table
    function createGrids(count, layout) {
        gridWrapper.innerHTML = '';

        let rows, columns;

        if (layout === 'single-row') {
            rows = 1;
            columns = count;
        } else if (layout === 'single-column') {
            rows = count;
            columns = 1;
        } else if (layout === 'two-rows') {
            rows = 2;
            columns = count === 4 ? 2 : count === 6 ? 3 : 4;
        }

        const table = document.createElement('table');
        table.classList.add('custom-char-tbl');  

        for (let r = 0; r < rows; r++) {
            const tr = document.createElement('tr');
            for (let c = 0; c < columns; c++) {
                if ((r * columns + c) >= count) break;

                const td = document.createElement('td');
                const grid = document.createElement('div');
                grid.classList.add('grid');
                grid.dataset.gridId = r * columns + c;

                for (let i = 0; i < 5 * 8; i++) {
                    const cell = document.createElement('button');
                    cell.classList.add('cell');
                    cell.dataset.row = Math.floor(i / 5);
                    cell.dataset.col = i % 5;
                    cell.dataset.gridId = r * columns + c;
                    cell.addEventListener('click', () => {
                        cell.classList.toggle('selected');
                        updateOutput(count);
                    });
                    grid.appendChild(cell);
                }

                td.appendChild(grid);
                tr.appendChild(td);
            }
            table.appendChild(tr);
        }

        gridWrapper.appendChild(table);

        // Adjust cell sizes after grid creation
        // adjustCellSize(count);
    }

    // Function to update the output code
    function updateOutput(count) {
        let rustCode = '';

        for (let g = 0; g < count; g++) {
            let rustArrays = [];
            for (let r = 0; r < 8; r++) {
                let rowArray = [];
                for (let c = 0; c < 5; c++) {
                    const cell = document.querySelector(`.cell[data-grid-id="${g}"][data-row="${r}"][data-col="${c}"]`);
                    rowArray.push(cell.classList.contains('selected') ? '1' : '0');
                }
                rustArrays.push(`0b${rowArray.join('')},`);
            }
            rustCode += `const SYMBOL${g + 1}: [u8; 8] = [
    ${rustArrays.join('\n    ')}
];\n\n`;
        }

        outputContainer.textContent = rustCode;
    }

    // Event listeners
    gridSizeSelector.addEventListener('change', () => {
        gridCount = parseInt(gridSizeSelector.value);
        validateLayout(); // Apply layout restriction
        createGrids(gridCount, gridLayoutSelector.value);
        updateOutput(gridCount);
    });

    gridLayoutSelector.addEventListener('change', () => {
        createGrids(gridCount, gridLayoutSelector.value);
        updateOutput(gridCount);
    });

    clearButton.addEventListener('click', () => {
        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => cell.classList.remove('selected'));
        updateOutput(gridCount);
    });

    invertButton.addEventListener('click', () => {
        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => {
            cell.classList.toggle('selected');
        });
        updateOutput(gridCount);
    });

    copyButton.addEventListener('click', () => {
        navigator.clipboard.writeText(outputContainer.textContent).then(() => {
            alert('Code copied to clipboard!');
        }).catch(err => {
            console.error('Error copying code: ', err);
        });
    });

    // Initialize the grid and output
    createGrids(gridCount, layout);
    updateOutput(gridCount);
</script>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="多个自定义字符"><a href="#多个自定义字符" class="header">多个自定义字符</a></h1>
<h2 id="multi-custom-character"><a class="header" href="#multi-custom-character">Multi Custom character</a></h2>
<p>I attempted to create the Ferris image using 6 adjacent grids with the generator from the previous page. Here’s the Rust code to utilize those byte arrays.</p>
<img style="display: block; margin: auto;width:400px;" alt="custom characters grid" src="lcd-display/images/ferris-with-6-grids-on-lcd-display.png" />
<h3 id="generated-byte-array-for-the-characters"><a class="header" href="#generated-byte-array-for-the-characters">Generated Byte array for the characters</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SYMBOL1: [u8; 8] = [
    0b00110, 0b01000, 0b01110, 0b01000, 0b00100, 0b00011, 0b00100, 0b01000,
];

const SYMBOL2: [u8; 8] = [
    0b00000, 0b00000, 0b00000, 0b10001, 0b10001, 0b11111, 0b00000, 0b00000,
];

const SYMBOL3: [u8; 8] = [
    0b01100, 0b00010, 0b01110, 0b00010, 0b00100, 0b11000, 0b00100, 0b00010,
];

const SYMBOL4: [u8; 8] = [
    0b01000, 0b01000, 0b00100, 0b00011, 0b00001, 0b00010, 0b00101, 0b01000,
];

const SYMBOL5: [u8; 8] = [
    0b00000, 0b00000, 0b00000, 0b11111, 0b01010, 0b10001, 0b00000, 0b00000,
];

const SYMBOL6: [u8; 8] = [
    0b00010, 0b00010, 0b00100, 0b11000, 0b10000, 0b01000, 0b10100, 0b00010,
];
<span class="boring">}</span></code></pre>
<h3 id="declare-them-as-character"><a class="header" href="#declare-them-as-character">Declare them as character</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lcd.custom_char(&amp;mut timer, &amp;SYMBOL1, 0);
lcd.custom_char(&amp;mut timer, &amp;SYMBOL2, 1);
lcd.custom_char(&amp;mut timer, &amp;SYMBOL3, 2);
lcd.custom_char(&amp;mut timer, &amp;SYMBOL4, 3);
lcd.custom_char(&amp;mut timer, &amp;SYMBOL5, 4);
lcd.custom_char(&amp;mut timer, &amp;SYMBOL6, 5);
<span class="boring">}</span></code></pre>
<h3 id="display"><a class="header" href="#display">Display</a></h3>
<p>Let’s write the first 3 grids into the first row, then the second half into the second row of the LCD display.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lcd.set_cursor(&amp;mut timer, 0, 4)
    .write(&amp;mut timer, CustomChar(0))
    .write(&amp;mut timer, CustomChar(1))
    .write(&amp;mut timer, CustomChar(2));

lcd.set_cursor(&amp;mut timer, 1, 4)
    .write(&amp;mut timer, CustomChar(3))
    .write(&amp;mut timer, CustomChar(4))
    .write(&amp;mut timer, CustomChar(5));
<span class="boring">}</span></code></pre>
<h2 id="clone-the-existing-project-23"><a class="header" href="#clone-the-existing-project-23">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>lcd-custom-multi</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/lcd-custom-multi/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="symbols-index"><a class="header" href="#symbols-index">Symbols Index</a></h1>
<p>Here is a list of custom symbols with their corresponding byte arrays. If you’ve designed an interesting symbol and want to add to this list, feel free to submit a pull request. Please use the <a href="#生成器">custom character generator</a> provided here to ensure consistency.</p>
<style>
    /* .preview-symbol{
        width:50px;
        height:80px;
    } */
    .preview-symbol {
        width: 50px;
        height: 80px;
        display: block;
        margin-left: auto;
        margin-right: auto;
        vertical-align: middle;

    }
</style>
<table>
    
<thead>
        
<tr>
            <th>Title</th>
            <th>Preview</th>
            <th>Byte Array</th>
        </tr>

    </thead>

    
<tbody>
        
<tr>
            <td>Heart</td>
            <td><img class="preview-symbol" src="lcd-display/images/custom-chars/heart.png" alt="heart"></td>
            <td>[ 0b00000, 0b01010, 0b11111, 0b11111, 0b01110, 0b00100, 0b00000, 0b00000,]</td>
        </tr>

        
<tr>
            <td>Lock</td>
            <td><img class="preview-symbol" src="lcd-display/images/custom-chars/lock.png" alt="lock"></td>
            <td>[ 0b01110, 0b10001, 0b10001, 0b11111, 0b11011, 0b11011, 0b11011, 0b11111, ]</td>
        </tr>

        
<tr>
            <td>Hollow Heart</td>
            <td><img class="preview-symbol" src="lcd-display/images/custom-chars/hollow-heart.png" alt="hollow-heart"></td>
            <td>[ 0b00000, 0b01010, 0b10101, 0b10001, 0b10001, 0b01010, 0b00100, 0b00000, ]</td>
        </tr>

        
<tr>
            <td>Battery</td>
            <td><img class="preview-symbol" src="lcd-display/images/custom-chars/battery.png" alt="battery"></td>
            <td>[ 0b01110, 0b11011, 0b10001, 0b10001, 0b10001, 0b11111, 0b11111, 0b11111, ]</td>
        </tr>

        
<tr>
            <td>Bus</td>
            <td><img class="preview-symbol" src="lcd-display/images/custom-chars/bus.png" alt="bus"></td>
            <td>[ 0b01110, 0b11111, 0b10001, 0b10001, 0b11111, 0b10101, 0b11111, 0b01010, ]</td>
        </tr>

        
<tr>
            <td>Bell</td>
            <td><img class="preview-symbol" src="lcd-display/images/custom-chars/bell.png" alt="bell"></td>
            <td>[ 0b00100, 0b01110, 0b01110, 0b01110, 0b11111, 0b00000, 0b00100, 0b00000, ]</td>
        </tr>

        
<tr>
            <td>Hour Glass</td>
            <td><img class="preview-symbol" src="lcd-display/images/custom-chars/hour-glass.png" alt="hour glass"></td>
            <td>[ 0b00000, 0b11111, 0b10001, 0b01010, 0b00100, 0b01010, 0b10101, 0b11111, ]</td>
        </tr>

        
<tr>
            <td>Charger</td>
            <td><img class="preview-symbol" src="lcd-display/images/custom-chars/charger.png" alt="charger"></td>
            <td>[ 0b01010, 0b01010, 0b11111, 0b10001, 0b10001, 0b01110, 0b00100, 0b00100, ]</td>
        </tr>

        
<tr>
            <td>Tick Mark</td>
            <td><img class="preview-symbol" src="lcd-display/images/custom-chars/tick-mark.png" alt="Tick Mark"></td>
            <td>[ 0b00000, 0b00000, 0b00001, 0b00011, 0b10110, 0b11100, 0b01000, 0b00000, ]</td>
        </tr>

        
<tr>
            <td>Music Note</td>
            <td><img class="preview-symbol" src="lcd-display/images/custom-chars/music-note.png" alt="Music note"></td>
            <td>[ 0b00011, 0b00010, 0b00010, 0b00010, 0b00010, 0b01110, 0b11110, 0b01110, ]</td>
        </tr>

    </tbody>

</table>

<div style="break-before: page; page-break-before: always;"></div>
<h1 id="joystick"><a class="header" href="#joystick">Joystick</a></h1>
<p>In this section, we’ll explore how to use the Joystick Module. It is similar to the joysticks found on PS2 (PlayStation 2) controllers. They are commonly used in gaming, as well as for controlling drones, remote-controlled cars, robots, and other devices to adjust position or direction.</p>
<h2 id="meet-the-hardware---joystick-module"><a class="header" href="#meet-the-hardware---joystick-module">Meet the hardware - Joystick module</a></h2>
<img style="display: block; margin: auto;width:250px;" alt="joystick" src="joystick/images/joystick.jpg" />
<p>You can move the joystick knob vertically and horizontally, sending its position (X and Y axes) to the MCU (e.g., Pico). Additionally, the knob can be pressed down like a button.  The joystick typically operates at 5V, but it can also be connected to 3.3V.</p>
<h2 id="how-it-works-2"><a class="header" href="#how-it-works-2">How it works?</a></h2>
<p>The joystick module has two 10K potentiometers: one for the X-axis and another for the Y-axis. It also includes a push button, which is visible.</p>
<p>When you move the joystick from right to left or left to right(X axis), you can observe one of the potentiometers moving accordingly. Similarly, when you move it up and down(Y-axis), you can observe the other potentiometer moving along.</p>
<img style="display: block; margin: auto;width:550px;" alt="joystick" src="joystick/images/joystick-potentiometers-push-button.jpg" />
<p>You can also observe the push-button being pressed when you press down on the knob.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="移动与-adc"><a href="#移动与-adc" class="header">移动与 ADC</a></h1>
<h2 id="joystick-movement-and-corresponding-adc-values"><a class="header" href="#joystick-movement-and-corresponding-adc-values">Joystick Movement and Corresponding ADC Values</a></h2>
<p>When you move the joystick along the X or Y axis, it produces an analog signal with a voltage that varies between 0 and 3.3V(or 5V if we connect it to 5V supply). When the joystick is in its center (rest) position, the output voltage is approximately 1.65V, which is half of the VCC(VCC is 3.3V in our case).</p>
<div class="alert-box alert-box-info">
    <span class="icon"><span class="fa-svg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M144 80c0 26.5-21.5 48-48 48s-48-21.5-48-48s21.5-48 48-48s48 21.5 48 48zM0 224c0-17.7 14.3-32 32-32H96c17.7 0 32 14.3 32 32V448h32c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H64V256H32c-17.7 0-32-14.3-32-32z"/></svg></span></span>
    
<div class="alert-content">
        <b class="alert-title">Voltage Divider</b>
        
<p>The reason it is 1.65V in the center position is that the potentiometer acts as a voltage divider. When the potentiometer is moved, its resistance changes, causing the voltage divider to output a different voltage accordingly. Refer the <a href="/core-concepts/voltage-divider.html">voltate divider section</a>.</p>

    </div>

</div>

<p>The joystick has a total of 5 pins, and we will shortly discuss what each of them represents. Out of these, two pins are dedicated to sending the X and Y axis positions, which should be connected to the ADC pins of the microcontroller.</p>
<p>As you may already know, the Raspberry Pi Pico has a 12-bit SAR-type ADC, which converts analog signals (voltage differences) into digital values. Since it is a 12-bit ADC, the analog values will be represented as digital values ranging from 0 to 4095. If you’re not familiar with ADC, refer to the <a href="#adc-analog-to-digital-converter">ADC section</a> that we covered earlier.</p>
<img style="display: block; margin: auto;width:580px;" alt="joystick-movement" src="joystick/images/joystick-movement-and-corresponding-pico-adc-values.jpg" />
<p><strong>Note:</strong></p>
<p>The ADC values in the image are just approximations to give you an idea and won’t be exact. For example, I got around 1850 for X and Y at the center position. When I moved the knob toward the pinout side, X went to 0, and when I moved it to the opposite side, it went to 4095. The same applies to the Y axis.So, You might need to calibrate your joystick.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pin-layout-1"><a class="header" href="#pin-layout-1">Pin layout</a></h1>
<p>The joystick has a total of 5 pins: power supply, ground, X-axis output, Y-axis output, and switch output pin.</p>
<img style="display: block; margin: auto;width:400px;margin-bottom: 10px;" alt="joystick" src="joystick/images/joystick-pin-layout.jpg" />
<table border="1" style="border-collapse: collapse; width: 100%;">
  
<thead>
    
<tr>
      <th style="width:14%">Joystick Pin</th>
      <th>Details</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td><span class="slanted-text black">GND</span></td>
      <td>Ground pin. Should be connected to the Ground of the circuit.</td>
    </tr>

    
<tr>
      <td><span class="slanted-text red">VCC</span></td>
      <td>Power supply pin (typically 5V or 3.3V ).</td>
    </tr>

    
<tr>
      <td><span class="slanted-text green">VRX</span></td>
      <td>The X-axis analog output pin varies its voltage based on the joystick's horizontal position, ranging from 0V to VCC as the joystick is moved left and right.</td>
    </tr>

    
<tr>
      <td><span class="slanted-text blue">VRY</span></td>
      <td>The Y-axis analog output pin varies its voltage based on the joystick's vertical position, ranging from 0V to VCC as the joystick is moved up and down.</td>
    </tr>

    
<tr>
      <td><span class="slanted-text purple">SW</span></td>
      <td>Switch pin. When the joystick knob is pressed, this pin is typically pulled LOW (to GND).</td>
    </tr>

  </tbody>

</table>

<div style="break-before: page; page-break-before: always;"></div>
<h1 id="connecting-the-joystick-to-the-raspberry-pi-pico"><a class="header" href="#connecting-the-joystick-to-the-raspberry-pi-pico">Connecting the Joystick to the Raspberry Pi Pico</a></h1>
<p>Let’s connect the joystick to the Raspberry Pi Pico. We need to connect the VRX and VRY pins to the ADC pins of the Pico. The joystick will be powered with 3.3V instead of 5V because the Pico’s GPIO pins are only 3.3V tolerant. Connecting it to 5V could damage the Pico’s pins. Thankfully, the joystick can operate at 3.3V as well.</p>
<table>
  
<thead>
    
<tr>
      <th>Pico Pin</th>
      <th style="width: 250px; margin: 0 auto;">Wire</th>
      <th>Joystick Pin</th>
    </tr>

  </thead>

  
<tbody>
    
<tr>
      <td>GND</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire black" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>GND</td>
    </tr>

    
<tr>
      <td>3.3V</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire red" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>VCC</td>
    </tr>

    
<tr>
      <td>GPIO 27 (ADC1)</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire green" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>VRX</td>
    </tr>

    
<tr>
      <td>GPIO 26 (ADC0)</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire blue" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>VRY</td>
    </tr>

    
<tr>
      <td>GPIO 15</td>
      <td style="text-align: center; vertical-align: middle; padding: 0;">
        
<div class="wire yellow" style="width: 200px; margin: 0 auto;">
          
<div class="male-left"></div>

          
<div class="male-right"></div>

        </div>

      </td>
      <td>SW</td>
    </tr>

  </tbody>

</table>

<img style="display: block; margin: auto;margin-top:30px;" alt="joystick" src="joystick/images/joystick-pico-circuit.jpg" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="输出-adc-数值"><a href="#输出-adc-数值" class="header">输出 ADC 数值</a></h1>
<h2 id="sending-joystick-movement-adc-values-to-usb-serial"><a class="header" href="#sending-joystick-movement-adc-values-to-usb-serial">Sending Joystick Movement ADC Values to USB Serial</a></h2>
<p>In this program, we’ll observe how joystick movement affects ADC values in real time. We will connect the Raspberry Pi Pico with the joystick and set up USB serial communication. If you’re not sure how to set up USB Serial, check the <a href="#usb-serial-communication">USB Serial</a> section.</p>
<p>As you move the joystick, the corresponding ADC values will be printed in the system. You can compare these values with the <a href="#移动与-adc">previous Movement and ADC Diagram</a>;they should approximately match the values shown. Pressing the joystick knob will print <strong>“Button Pressed”</strong> along with the current coordinates.</p>
<h3 id="project-from-template-7"><a class="header" href="#project-from-template-7">Project from template</a></h3>
<p>To set up the project, run:</p>
<pre><code class="language-sh">cargo generate --git https://github.com/ImplFerris/pico2-template.git --tag v0.1.0
</code></pre>
<p>When prompted, give your project a name, like “joystick-usb” and select <code>RP-HAL</code> as the HAL.</p>
<p>Then, navigate into the project folder:</p>
<pre><code class="language-sh">cd PROJECT_NAME
# For example, if you named your project "joystick-usb":
# cd joystick-usb
</code></pre>
<h3 id="additional-crates-required-5"><a class="header" href="#additional-crates-required-5">Additional Crates required</a></h3>
<p>Update your Cargo.toml to add these additional crate along with the existing dependencies.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>usb-device = "0.3.2"
usbd-serial = "0.2.2"
heapless = "0.8.0"

embedded_hal_0_2 = { package = "embedded-hal", version = "0.2.5", features = [
  "unproven",
] }
<span class="boring">}</span></code></pre>
<p>The first three should be familiar by now; they set up USB serial communication so we can send data between the Pico and the computer. heapless is a helper function for buffers.</p>
<p>embedded_hal_0_2 is the new crate. You might already have embedded-hal with version “1.0.0” in your Cargo.toml. So, you may wonder why we need this version. The reason is that Embedded HAL 1.0.0 doesn’t include an ADC trait to read ADC values, and the RP-HAL uses the one from version 0.2. (Don’t remove the existing embedded-hal 1.0.0; just add this one along with it.)</p>
<h3 id="additional-imports-8"><a class="header" href="#additional-imports-8">Additional imports</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This trait is the interface to an ADC that is configured to read a specific channel at the time
/// of the request (in contrast to continuous asynchronous sampling).
use embedded_hal_0_2::adc::OneShot;

// for USB Serial
use usb_device::{class_prelude::*, prelude::*};
use usbd_serial::SerialPort;
use heapless::String;
<span class="boring">}</span></code></pre>
<h3 id="usb-serial-1"><a class="header" href="#usb-serial-1">USB Serial</a></h3>
<p>Make sure you’ve completed the USB serial section and added the boilerplate code from there into your project.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let usb_bus = UsbBusAllocator::new(hal::usb::UsbBus::new(
        pac.USB,
        pac.USB_DPRAM,
        clocks.usb_clock,
        true,
        &amp;mut pac.RESETS,
    ));

    let mut serial = SerialPort::new(&amp;usb_bus);

    let mut usb_dev = UsbDeviceBuilder::new(&amp;usb_bus, UsbVidPid(0x16c0, 0x27dd))
        .strings(&amp;[StringDescriptors::default()
            .manufacturer("implRust")
            .product("Ferris")
            .serial_number("12345678")])
        .unwrap()
        .device_class(2) // 2 for the CDC, from: https://www.usb.org/defined-class-codes
        .build();

    let mut buff: String&lt;64&gt; = String::new();
<span class="boring">}</span></code></pre>
<h3 id="pin-setup"><a class="header" href="#pin-setup">Pin setup</a></h3>
<p>Let’s set up the ADC and configure GPIO 27 and GPIO 26, which are mapped to the VRX and VRY pins of the joystick:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut adc = hal::Adc::new(pac.ADC, &amp;mut pac.RESETS);

//VRX Pin
let mut adc_pin_1 = hal::adc::AdcPin::new(pins.gpio27).unwrap();
// VRY pin
let mut adc_pin_0 = hal::adc::AdcPin::new(pins.gpio26).unwrap();
<span class="boring">}</span></code></pre>
<p>We also configure GPIO15 as a pull-up input for the button:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut btn = pins.gpio15.into_pull_up_input();
<span class="boring">}</span></code></pre>
<h3 id="printing-co-ordinates"><a class="header" href="#printing-co-ordinates">Printing Co-ordinates</a></h3>
<p>We want to print the coordinates only when the vrx or vry values change beyond a certain threshold. This avoids continuously printing unnecessary values.</p>
<p>To achieve this, we initialize variables to store the previous values and a flag to determine when to print:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut prev_vrx: u16 = 0;
let mut prev_vry: u16 = 0;
let mut print_vals = true;
<span class="boring">}</span></code></pre>
<p><strong>Reading ADC Values:</strong></p>
<p>First, read the ADC values for vrx and vry. If there’s an error during the read operation, we ignore it and continue the loop:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Ok(vry): Result&lt;u16, _&gt; = adc.read(&amp;mut adc_pin_0) else {
    continue;
};
let Ok(vrx): Result&lt;u16, _&gt; = adc.read(&amp;mut adc_pin_1) else {
    continue;
};
<span class="boring">}</span></code></pre>
<p><strong>Checking for Threshold Changes:</strong></p>
<p>Next, we check if the absolute difference between the current and previous values of vrx or vry exceeds a threshold (e.g., 100). If so, we update the previous values and set the print_vals flag to true:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if vrx.abs_diff(prev_vrx) &gt; 100 {
    prev_vrx = vrx;
    print_vals = true;
}

if vry.abs_diff(prev_vry) &gt; 100 {
    prev_vry = vry;
    print_vals = true;
}
<span class="boring">}</span></code></pre>
<p>Using a threshold filters out small ADC fluctuations, avoids unnecessary prints, and ensures updates only for significant changes.</p>
<p><strong>Printing the Coordinates</strong></p>
<p>If print_vals is true, we reset it to false and print the X and Y coordinates via the USB serial:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if print_vals {
    print_vals = false;

    buff.clear();
    write!(buff, "X: {} Y: {}\r\n", vrx, vry).unwrap();
    let _ = serial.write(buff.as_bytes());
}
<span class="boring">}</span></code></pre>
<h3 id="button-press-detection-with-state-transition"><a class="header" href="#button-press-detection-with-state-transition">Button Press Detection with State Transition</a></h3>
<p>The button is normally in a high state. When you press the knob button, it switches from high to low. However, since the program runs in a loop, simply checking if the button is low could lead to multiple detections of the press. To avoid this, we only register the press once by detecting a high-to-low transition, which indicates that the button has been pressed.</p>
<p>To achieve this, we track the previous state of the button and compare it with the current state before printing the “button pressed” message. If the button is currently in a low state (pressed) and the previous state was high (not pressed), we recognize it as a new press and print the message. Then, we update the previous state to the current state, ensuring the correct detection of future transitions.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn_state = btn.is_low().unwrap();
if btn_state &amp;&amp; !prev_btn_state {
    let _ = serial.write("Button Pressed\r\n".as_bytes());
    print_vals = true;
}
prev_btn_state = btn_state;
<span class="boring">}</span></code></pre>
<h3 id="the-full-code-5"><a class="header" href="#the-full-code-5">The Full code</a></h3>
<pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use core::fmt::Write;
use embedded_hal::{delay::DelayNs, digital::InputPin};
use embedded_hal_0_2::adc::OneShot;
use hal::block::ImageDef;
use heapless::String;
use panic_halt as _;
use rp235x_hal as hal;

use usb_device::{class_prelude::*, prelude::*};
use usbd_serial::SerialPort;

#[link_section = ".start_block"]
#[used]
pub static IMAGE_DEF: ImageDef = hal::block::ImageDef::secure_exe();

const XTAL_FREQ_HZ: u32 = 12_000_000u32;

#[hal::entry]
fn main() -&gt; ! {
    let mut pac = hal::pac::Peripherals::take().unwrap();
    let mut watchdog = hal::Watchdog::new(pac.WATCHDOG);

    let clocks = hal::clocks::init_clocks_and_plls(
        XTAL_FREQ_HZ,
        pac.XOSC,
        pac.CLOCKS,
        pac.PLL_SYS,
        pac.PLL_USB,
        &amp;mut pac.RESETS,
        &amp;mut watchdog,
    )
    .ok()
    .unwrap();
    let mut timer = hal::Timer::new_timer0(pac.TIMER0, &amp;mut pac.RESETS, &amp;clocks);

    let sio = hal::Sio::new(pac.SIO);
    let pins = hal::gpio::Pins::new(
        pac.IO_BANK0,
        pac.PADS_BANK0,
        sio.gpio_bank0,
        &amp;mut pac.RESETS,
    );
    // let mut led = pins.gpio25.into_push_pull_output();

    let usb_bus = UsbBusAllocator::new(hal::usb::UsbBus::new(
        pac.USB,
        pac.USB_DPRAM,
        clocks.usb_clock,
        true,
        &amp;mut pac.RESETS,
    ));

    let mut serial = SerialPort::new(&amp;usb_bus);

    let mut usb_dev = UsbDeviceBuilder::new(&amp;usb_bus, UsbVidPid(0x16c0, 0x27dd))
        .strings(&amp;[StringDescriptors::default()
            .manufacturer("implRust")
            .product("Ferris")
            .serial_number("12345678")])
        .unwrap()
        .device_class(2) // 2 for the CDC, from: https://www.usb.org/defined-class-codes
        .build();

    let mut btn = pins.gpio15.into_pull_up_input();

    let mut adc = hal::Adc::new(pac.ADC, &amp;mut pac.RESETS);

    //VRX Pin
    let mut adc_pin_1 = hal::adc::AdcPin::new(pins.gpio27).unwrap();
    // VRY pin
    let mut adc_pin_0 = hal::adc::AdcPin::new(pins.gpio26).unwrap();

    let mut prev_vrx: u16 = 0;
    let mut prev_vry: u16 = 0;
    let mut prev_btn_state = false;
    let mut buff: String&lt;64&gt; = String::new();
    let mut print_vals = true;
    loop {
        let _ = usb_dev.poll(&amp;mut [&amp;mut serial]);

        let Ok(vry): Result&lt;u16, _&gt; = adc.read(&amp;mut adc_pin_0) else {
            continue;
        };
        let Ok(vrx): Result&lt;u16, _&gt; = adc.read(&amp;mut adc_pin_1) else {
            continue;
        };

        if vrx.abs_diff(prev_vrx) &gt; 100 {
            prev_vrx = vrx;
            print_vals = true;
        }

        if vry.abs_diff(prev_vry) &gt; 100 {
            prev_vry = vry;
            print_vals = true;
        }

        let btn_state = btn.is_low().unwrap();
        if btn_state &amp;&amp; !prev_btn_state {
            let _ = serial.write("Button Pressed\r\n".as_bytes());
            print_vals = true;
        }
        prev_btn_state = btn_state;

        if print_vals {
            print_vals = false;

            buff.clear();
            write!(buff, "X: {} Y: {}\r\n", vrx, vry).unwrap();
            let _ = serial.write(buff.as_bytes());
        }

        timer.delay_ms(50);
    }
}

#[link_section = ".bi_entries"]
#[used]
pub static PICOTOOL_ENTRIES: [hal::binary_info::EntryAddr; 5] = [
    hal::binary_info::rp_cargo_bin_name!(),
    hal::binary_info::rp_cargo_version!(),
    hal::binary_info::rp_program_description!(c"JoyStick USB"),
    hal::binary_info::rp_cargo_homepage_url!(),
    hal::binary_info::rp_program_build_attribute!(),
];</code></pre>
<h2 id="clone-the-existing-project-24"><a class="header" href="#clone-the-existing-project-24">Clone the existing project</a></h2>
<p>You can clone (or refer) project I created and navigate to the <code>joystick-usb</code> folder.</p>
<pre><code class="language-sh">git clone https://github.com/ImplFerris/pico2-rp-projects
cd pico2-projects/joystick-usb/
</code></pre>
<h2 id="how-to-run--4"><a class="header" href="#how-to-run--4">How to Run ?</a></h2>
<p>The method to flash (run the code) on the Pico is the same as usual. However, we need to set up tio to interact with the Pico through the serial port (/dev/ttyACM0). This allows us to read data from the Pico or send data to it.</p>
<h3 id="tio-3"><a class="header" href="#tio-3">tio</a></h3>
<p>Make sure you have tio installed on your system. If not, you can install it using:</p>
<pre><code class="language-sh">apt install tio
</code></pre>
<h3 id="connecting-to-the-serial-port-4"><a class="header" href="#connecting-to-the-serial-port-4">Connecting to the Serial Port</a></h3>
<p>Run the following command to connect to the Pico’s serial port:</p>
<pre><code class="language-sh">tio /dev/ttyACM0
</code></pre>
<p>This will open a terminal session for communicating with the Pico.</p>
<h3 id="flashing-and-running-the-code-4"><a class="header" href="#flashing-and-running-the-code-4">Flashing and Running the Code</a></h3>
<p>Open another terminal, navigate to the project folder, and flash the code onto the Pico as usual:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p>If everything is set up correctly, you should see a “Connected” message in the tio terminal. As you move the joystick, the coordinates will be printed. Pressing the knob downwards will also display a “Button pressed” message.</p>
<img style="display: block; margin: auto;" src="joystick/images/joystick-usb-output.png" />
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<ul>
<li><a href="#debugging-embedded-rust-on-raspberry-pi-pico-2-with-gdb">Debugging with GDB</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="debugging-embedded-rust-on-raspberry-pi-pico-2-with-gdb"><a class="header" href="#debugging-embedded-rust-on-raspberry-pi-pico-2-with-gdb">Debugging Embedded Rust on Raspberry Pi Pico 2 with GDB</a></h1>
<p>In this chapter, we will look at how to debug Embedded Rust programs on the Raspberry Pi Pico 2 (RP2350) using GDB. You will need a Debug Probe hardware and you must connect it to your Raspberry Pi Pico 2. Make sure you have read <a href="#用于-raspberry-pi-pico-2-的调试器debug-probe">this chapter</a> before continuing.</p>
<h2 id="what-a-debug-probe-gives-you"><a class="header" href="#what-a-debug-probe-gives-you">What a Debug Probe Gives You</a></h2>
<p>In the Debug Probe introduction chapter, we saw that it helps you avoid pressing the BOOTSEL button every time you want to flash your program. But the Debug Probe offers much more than that. It allows you to use GDB directly from your computer, so you can debug your program while it is running on the Pico 2.</p>
<h2 id="what-is-gdb"><a class="header" href="#what-is-gdb">What is GDB?</a></h2>
<p>If you have never used GDB, here is a simple explanation: GDB is a command line debugger that lets you pause your program, inspect what is happening inside it, read memory, and step through the code to find problems.</p>
<p>For debugging the Pico 2, you need a version of GDB that supports ARM targets. You can install it with:</p>
<pre><code class="language-sh">sudo apt install gdb-multiarch
</code></pre>
<h2 id="enable-gdb-in-embedtoml"><a class="header" href="#enable-gdb-in-embedtoml">Enable GDB in Embed.toml</a></h2>
<p>Earlier, we used probe-rs through the cargo embed command. The same tool can also start a GDB server, which lets you connect GDB to the Pico 2 through the Debug Probe.</p>
<p>For this, we need to edit the Embed.toml file in the root of your project. This file is the configuration file used by the cargo embed command. You should add the following section to enable the GDB server:</p>
<pre><code class="language-toml">[default.gdb]
# Whether or not a GDB server should be opened after flashing.
enabled = true
</code></pre>
<h2 id="example-project"><a class="header" href="#example-project">Example Project</a></h2>
<p>For this exercise, I have created a simple LED blink program using rp-hal. It does not use Embassy to keep things simple. The Embed.toml file is already set up, so you can clone the project and start working right away:</p>
<pre><code>git clone https://github.com/ImplFerris/pico-debug
cd pico-debug
</code></pre>
<p>If you run the cargo embed command now, the GDB server will start automatically and listen on port 1337 (the default port used by probe-rs).</p>
<h2 id="connecting-gdb-to-the-remote-server"><a class="header" href="#connecting-gdb-to-the-remote-server">Connecting GDB to the Remote Server</a></h2>
<p>To connect GDB to the running probe-rs GDB server, open a new terminal and start GDB with the our project binary file:</p>
<blockquote>
<p>Note: There is an issue with probe-rs version 0.30. When I try to connect to the GDB server, the connection closes immediately. I downgraded to version 0.28 as suggested in this <a href="https://github.com/probe-rs/probe-rs/issues/3633">issue discussion</a>. After downgrading, run cargo embed again.</p>
</blockquote>
<pre><code class="language-sh">gdb-multiarch ./target/thumbv8m.main-none-eabihf/debug/pico-debug
</code></pre>
<p>Then connect to the server on port 1337:</p>
<pre><code class="language-sh">(gdb) target remote :1337
</code></pre>
<p>At this point, GDB is connected to the Pico 2 through the Debug Probe, and you can start using breakpoints, stepping, memory inspection, and other debugging commands.</p>
<h2 id="resetting-to-the-start-of-the-program"><a class="header" href="#resetting-to-the-start-of-the-program">Resetting to the Start of the Program</a></h2>
<p>When you connect GDB to the running GDB server, the CPU may not be stopped at the start of your program. It might be sitting somewhere deep inside the code.</p>
<p>To ensure you start debugging from a clean state, run:</p>
<pre><code class="language-sh">(gdb) monitor reset halt
</code></pre>
<p>This command tells the Debug Probe to reset the Pico 2 and immediately halt the CPU. This puts the program back at the very beginning, right where the processor starts running after a reset.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="finding-the-reset-handler-and-tracing-the-call-to-main"><a class="header" href="#finding-the-reset-handler-and-tracing-the-call-to-main">Finding the Reset Handler and Tracing the Call to main</a></h1>
<p>When the Pico 2 resets, the CPU starts executing from the Reset Handler. To understand how our program starts, we will locate the Reset Handler, disassemble it, and follow the call chain until we reach our actual Rust main.</p>
<p>When the Pico 2 starts up, the CPU does not jump straight into our Rust main function.  Instead, it follows a small chain of functions provided by the Cortex-M runtime.</p>
<p>In this section, we will:</p>
<ol>
<li>
<p>Find where the chip starts executing after reset</p>
</li>
<li>
<p>See which function that Reset Handler calls</p>
</li>
<li>
<p>Follow the chain until we reach our real Rust main</p>
</li>
</ol>
<h2 id="read-the-reset-vector-entry"><a class="header" href="#read-the-reset-vector-entry">Read the Reset Vector Entry</a></h2>
<p>The Cortex-M processor starts execution by reading a table at the beginning of flash memory called the vector table.</p>
<p>The first two entries are:</p>
<ul>
<li><strong>Word 0</strong> (offset 0x00): Initial stack pointer value</li>
<li><strong>Word 1</strong> (offset 0x04): Reset handler address</li>
</ul>
<p>On Pico 2, flash starts at address 0x10000000 so:</p>
<ul>
<li>The initial stack pointer value is stored at 0x10000000</li>
<li>Reset handler address is at 0x10000004</li>
</ul>
<h3 id="what-is-the-reset-handler"><a class="header" href="#what-is-the-reset-handler">What is the Reset Handler?</a></h3>
<p>The reset handler is the first function that runs when the processor powers on or resets. It performs initialization and eventually calls our <code>main</code> function.</p>
<p>Read it in GDB:</p>
<pre><code class="language-sh">(gdb) x/wx 0x10000004
</code></pre>
<p>Example output:</p>
<pre><code class="language-sh">0x10000004 &lt;__RESET_VECTOR&gt;:    0x1000010d
</code></pre>
<p>This value is the address the CPU jumps to after reset. The last bit (the “Thumb bit”) is always 1, so the actual address is 0x1000010c.
But you can use either one of them (0x1000010d or 0x1000010c), GDB can handle it.</p>
<p>Alternatively, you can also use the readelf program to find the entrypoint address:</p>
<pre><code class="language-sh">arm-none-eabi-readelf -h ./target/thumbv8m.main-none-eabihf/debug/pico-debug
</code></pre>
<h2 id="disassemble-the-reset-handler"><a class="header" href="#disassemble-the-reset-handler">Disassemble the Reset Handler</a></h2>
<p>Now Let’s ask GDB to show the instructions at that address:</p>
<pre><code class="language-sh">(gdb) disas 0x1000010d

# or

(gdb) disas 0x1000010c
</code></pre>
<p>You will see assembly instructions for the reset handler. Look for a <code>bl</code> (<a href="https://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions/bl">Branch with Link</a>) instruction that calls another function:</p>
<pre><code class="language-sh">...
0x10000140 &lt;+52&gt;:    isb     sy
0x10000144 &lt;+56&gt;:    bl      0x1000031c &lt;main&gt;
0x10000148 &lt;+60&gt;:    udf     #0
</code></pre>
<p>The Reset Handler calls a function located at 0x1000031c, which GDB shows as main.  But this is not our Rust main yet.</p>
<h2 id="what-is-this-main"><a class="header" href="#what-is-this-main">What is this “main”?</a></h2>
<p>The main at 0x1000031c is not our program’s main function. It is a small wrapper created by the cortex-m-rt crate. This wrapper is often called the trampoline because it jumps to the real entry point later.</p>
<p>Its demangled name is usually:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOTE: here, pico_debug prefix is our project's name
pico_debug::__cortex_m_rt_main_trampoline
<span class="boring">}</span></code></pre>
<p>Let’s disassemble it.</p>
<h3 id="disassemble-that-trampoline"><a class="header" href="#disassemble-that-trampoline">Disassemble that trampoline</a></h3>
<pre><code class="language-sh">(gdb) disas 0x1000031c
</code></pre>
<p>Output:</p>
<pre><code class="language-sh">Dump of assembler code for function main:
   0x1000031c &lt;+0&gt;:     push    {r7, lr}
   0x1000031e &lt;+2&gt;:     mov     r7, sp
   0x10000320 &lt;+4&gt;:     bl      0x10000164 &lt;_ZN10pico_debug18__cortex_m_rt_main17he0b4d19700c84ad2E&gt;
End of assembler dump.
</code></pre>
<p>This is very small.  All it does is call the real Rust entrypoint, which is named:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pico_debug::__cortex_m_rt_main
<span class="boring">}</span></code></pre>
<h2 id="enable-demangled-names"><a class="header" href="#enable-demangled-names">Enable Demangled Names</a></h2>
<p>Rust function names are mangled by default and look unreadable.</p>
<p>Enable demangling:</p>
<pre><code class="language-sh">set print asm-demangle on
</code></pre>
<p>Now try:</p>
<pre><code class="language-sh">(gdb) disas 0x1000031c
#or
(gdb) disas pico_debug::__cortex_m_rt_main_trampoline
</code></pre>
<p>You should now see readable Rust names.</p>
<pre><code class="language-sh">Dump of assembler code for function pico_debug::__cortex_m_rt_main_trampoline:
   0x1000031c &lt;+0&gt;:     push    {r7, lr}
   0x1000031e &lt;+2&gt;:     mov     r7, sp
   0x10000320 &lt;+4&gt;:     bl      0x10000164 &lt;pico_debug::__cortex_m_rt_main&gt;
End of assembler dump.
</code></pre>
<h2 id="disassemble-the-actual-rust-main"><a class="header" href="#disassemble-the-actual-rust-main">Disassemble the Actual Rust main</a></h2>
<p>Now let’s inspect our main function:</p>
<pre><code class="language-sh">disas pico_debug::__cortex_m_rt_main
</code></pre>
<p>You will see the program’s logic, starting with the initial setup code followed by the loop that toggles the LED Pin.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

0x100002dc &lt;+376&gt;:   bl      0x100079a4 &lt;rp235x_hal::timer::Timer&lt;rp235x_hal::timer::CopyableTimer0&gt;::new_timer0&gt;
0x100002e0 &lt;+380&gt;:   bl      0x10000b30 &lt;rp235x_hal::gpio::Pin&lt;rp235x_hal::gpio::pin::bank0::Gpio25, rp235x_hal::gpio::func::FunctionNull, rp235x_hal::gpio::pull::PullDown&gt;::into_push_pull_output&lt;rp235x_hal::gpio::pin::bank0::Gpio25, rp235x_hal::gpio::func::FunctionNull, rp235x_hal::gpio::pull::PullDown&gt;&gt;
...
0x100002f8 &lt;+404&gt;:   bl      0x10000c48 &lt;rp235x_hal::gpio::eh1::{impl#1}::set_high&lt;rp235x_hal::gpio::pin::bank0::Gpio25, rp235x_hal::gpio::pull::PullDown&gt;&gt;
...
0x10000306 &lt;+418&gt;:   bl      0x100006b8 &lt;rp235x_hal::timer::{impl#7}::delay_ms&lt;rp235x_hal::timer::CopyableTimer0&gt;&gt;
...
0x1000030c &lt;+424&gt;:   bl      0x10000c38 &lt;rp235x_hal::gpio::eh1::{impl#1}::set_low&lt;rp235x_hal::gpio::pin::bank0::Gpio25, rp235x_hal::gpio::pull::PullDown&gt;&gt;
...
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="breakpoints"><a class="header" href="#breakpoints">Breakpoints</a></h1>
<p>Now that we’ve traced the execution path from reset to our main function, let’s set breakpoints in the LED loop and observe how the GPIO registers change when we toggle the LED.</p>
<h2 id="understanding-the-led-loop"><a class="header" href="#understanding-the-led-loop">Understanding the LED Loop</a></h2>
<p>Let me show you the disassembled code from the __cortex_m_rt_main function again. We need to look for the <code>bl</code> instructions. The <code>bl</code> stands for “branch and link” - these are instructions that call other functions. Specifically, we’re looking for the calls to set_high and set_low functions.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
// This is the set_high() call
0x100002f8 &lt;+404&gt;:   bl      0x10000c48 &lt;rp235x_hal::gpio::eh1::{impl#1}::set_high&lt;rp235x_hal::gpio::pin::bank0::Gpio25, rp235x_hal::gpio::pull::PullDown&gt;&gt;
...
// This is the delay_ms() call
0x10000306 &lt;+418&gt;:   bl      0x100006b8 &lt;rp235x_hal::timer::{impl#7}::delay_ms&lt;rp235x_hal::timer::CopyableTimer0&gt;&gt;
...
// This is the set_low() call
0x1000030c &lt;+424&gt;:   bl      0x10000c38 &lt;rp235x_hal::gpio::eh1::{impl#1}::set_low&lt;rp235x_hal::gpio::pin::bank0::Gpio25, rp235x_hal::gpio::pull::PullDown&gt;&gt;
...
// This is the delay_ms() call
0x10000314 &lt;+432&gt;:   bl      0x100006b8 &lt;rp235x_hal::timer::{impl#7}::delay_ms&lt;rp235x_hal::timer::CopyableTimer0&gt;&gt;
...
<span class="boring">}</span></code></pre>
<p>Look at those addresses on the left - 0x100002f8 and 0x1000030c. These are memory addresses where the LED control happens. The first address is where set_high gets called, and the second is where set_low gets called. We’re going to put breakpoints at these addresses so our program pauses right before running these instructions.</p>
<h2 id="setting-breakpoints-in-the-loop"><a class="header" href="#setting-breakpoints-in-the-loop">Setting Breakpoints in the Loop</a></h2>
<p>Let’s set up the first breakpoint. Type this in GDB:</p>
<pre><code class="language-sh">(gdb) break *0x100002f8
</code></pre>
<p>You’ll see:  <code>Breakpoint 1 at 0x100002f8: file src/main.rs, line 63.</code></p>
<p>This means GDB created a breakpoint at that address, and it corresponds to line 63 in our main.rs file.</p>
<pre><code class="language-sh">(gdb) break *0x1000030c
</code></pre>
<p>You’ll see: <code>Breakpoint 2 at 0x1000030c: file src/main.rs, line 65.</code></p>
<p>Now let’s reset everything to start fresh:</p>
<pre><code class="language-sh">monitor reset halt
</code></pre>
<p>This resets the microcontroller and stops it at the beginning, so we have a clean starting point.</p>
<h2 id="gpio-register-overview"><a class="header" href="#gpio-register-overview">GPIO Register Overview</a></h2>
<p>Before we continue, I need to explain what we’re going to look at. When you call set_high or set_low in your Rust code, what actually happens is that specific memory locations get changed. These memory locations are called registers, and they directly control the hardware.</p>
<p>On the RP2350 chip, there’s a register called GPIO_OUT that controls all the GPIO pins. You can find this in the RP2350 datasheet (chapter 3.1.11, page 55) under the SIO (Single-cycle IO) section.</p>
<p>Here’s where this register lives in memory:</p>
<ul>
<li>The SIO peripheral starts at base address 0xd0000000</li>
<li>The GPIO_OUT register is at offset 0x010 from that base</li>
<li>So the full address is: 0xd0000000 + 0x010 = 0xd0000010</li>
</ul>
<p>Think of GPIO_OUT as a 32-bit number where each bit controls one GPIO pin. Bit 0 controls GPIO0, bit 1 controls GPIO1, and so on. Bit 25 controls GPIO25 - that’s where the onboard LED is connected. When bit 25 is 0, the LED is off. When bit 25 is 1, the LED is on.</p>
<h2 id="running-to-the-first-breakpoint"><a class="header" href="#running-to-the-first-breakpoint">Running to the First Breakpoint</a></h2>
<p>Let’s run the program until it hits our first breakpoint:</p>
<pre><code class="language-sh">(gdb) continue
</code></pre>
<p>When the breakpoint is hit, GDB will show something like:</p>
<pre><code class="language-sh">Continuing.

Thread 1 hit Breakpoint 1, 0x100002f8 in pico_debug::__cortex_m_rt_main () at src/main.rs:63
63              led_pin.set_high().unwrap();
</code></pre>
<p>The program stopped right before calling set_high. This is the perfect moment to check what the register looks like before we turn the LED on.</p>
<h2 id="checking-gpio-registers-before-set_high"><a class="header" href="#checking-gpio-registers-before-set_high">Checking GPIO Registers Before set_high</a></h2>
<p>Let’s look at what’s currently in the GPIO_OUT register:</p>
<pre><code class="language-sh">(gdb) x/x 0xd0000010
</code></pre>
<p>The x/x command means “examine this memory address and show me the value in hexadecimal format.”</p>
<p>You’ll probably get an error message “Cannot access memory at address 0xd0000010”. This happens because GDB doesn’t automatically know about peripheral registers. We need to tell GDB that it’s allowed to read from this memory region.</p>
<h3 id="making-sio-peripheral-accessible-in-gdb"><a class="header" href="#making-sio-peripheral-accessible-in-gdb">Making SIO Peripheral Accessible in GDB</a></h3>
<p>To fix this, we need to tell GDB about the peripheral memory region. According to the RP2350 datasheet, the SIO region actually extends from 0xd0000000 to 0xdfffffff. However, we don’t need to map the entire SIO region - we only need enough to cover the registers we want to access.</p>
<p>So we can type:</p>
<pre><code class="language-sh">(gdb) mem 0xD0000000 0xD0001000 rw nocache
</code></pre>
<p>Here, we’re mapping about 4KB of the SIO region (from 0xD0000000 to 0xD0001000), which is more than enough to cover GPIO_OUT and the other SIO registers we’ll be looking at during debugging.</p>
<p>If you want to map even less and be more precise, you can use:</p>
<pre><code class="language-sh">(gdb) mem 0xD0000000 0xD0000100 rw nocache
</code></pre>
<p>This gives us just 256 bytes, which covers all the basic SIO registers we need, including GPIO_OUT at 0xD0000010. The key point is that we map enough memory to include the registers we want to read, without needing to map the entire SIO region.</p>
<p>Now try reading GPIO_OUT again:</p>
<pre><code class="language-sh">(gdb) x/x 0xd0000010
0xd0000010:     0x00000000
</code></pre>
<p>We get the value 0x00000000. This means all 32 bits are zero, so all GPIO pins are currently off. Our LED is off.</p>
<h2 id="continue-to-the-second-breakpoint"><a class="header" href="#continue-to-the-second-breakpoint">Continue to the Second Breakpoint</a></h2>
<p>Now let’s continue running and see what happens after set_high executes:</p>
<pre><code class="language-sh">(gdb) continue
Continuing.

Thread 1 received signal SIGINT, Interrupt.
rp235x_hal::gpio::eh1::{impl#1}::set_high&lt;rp235x_hal::gpio::pin::bank0::Gpio25, rp235x_hal::gpio::pull::PullDown&gt; (self=0x2007ffbd)
    at /home/implrust/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rp235x-hal-0.3.1/src/gpio/mod.rs:1549
1549            fn set_high(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {
</code></pre>
<p>We got interrupted inside the set_high function. Let’s continue again:</p>
<pre><code class="language-sh">(gdb) continue
Continuing.

Thread 1 hit Breakpoint 2, pico_debug::__cortex_m_rt_main () at src/main.rs:65
65              led_pin.set_low().unwrap();

</code></pre>
<p>Now the program has run through set_high and the delay, and stopped at our second breakpoint on line 65, right before calling set_low.  Let’s check GPIO_OUT again:</p>
<pre><code class="language-sh">(gdb) x/x 0xd0000010
0xd0000010:     0x02000000
</code></pre>
<p>The value changed from <code>0x00000000</code> to <code>0x02000000</code>.  You should also see the LED turned on by this time.</p>
<p>Let me explain what <code>0x02000000</code> means. In binary, this is <code>00000010 00000000 00000000 00000000</code>. If you count from the right starting at 0, bit 25 is now set to 1. That’s exactly what set_high did - it turned on bit 25 of the GPIO_OUT register, which turned on GPIO25, which lit up the LED.</p>
<h2 id="continue-to-see-set_low-in-action"><a class="header" href="#continue-to-see-set_low-in-action">Continue to See set_low in Action</a></h2>
<p>Now let’s continue one more time to see what happens when set_low executes. But first, let’s note that the LED is currently on and GPIO_OUT shows <code>0x02000000</code> with bit 25 set to 1.</p>
<p>Let’s continue:</p>
<pre><code class="language-sh">(gdb) continue
Continuing.

Thread 1 received signal SIGINT, Interrupt.
rp235x_hal::gpio::eh1::{impl#1}::set_low&lt;rp235x_hal::gpio::pin::bank0::Gpio25, rp235x_hal::gpio::pull::PullDown&gt; (self=0x2007ffbd)
    at /home/implrust/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rp235x-hal-0.3.1/src/gpio/mod.rs:1544
1544            fn set_low(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {
</code></pre>
<p>We got interrupted inside the set_low function. Let’s continue again:</p>
<pre><code class="language-sh">(gdb) continue
Continuing.

Thread 1 hit Breakpoint 1, 0x100002f8 in pico_debug::__cortex_m_rt_main () at src/main.rs:63
63              led_pin.set_high().unwrap();
</code></pre>
<p>The program ran through set_low and the delay, and looped back to our first breakpoint on line 63. Let’s check GPIO_OUT again:</p>
<pre><code class="language-sh">(gdb) x/x 0xd0000010
0xd0000010:     0x00000000
</code></pre>
<p>The value is back to <code>0x00000000</code>. Bit 25 is now 0, which means GPIO25 is off and the LED is off. You should see the LED turned off on your board.</p>
<h2 id="what-we-learned"><a class="header" href="#what-we-learned">What We Learned</a></h2>
<p>From what we observed:</p>
<ul>
<li>When we call <code>led_pin.set_high()</code>, bit 25 of GPIO_OUT changes from 0 to 1 (<code>0x00000000</code> → <code>0x02000000</code>)</li>
<li>When we call <code>led_pin.set_low()</code>, bit 25 changes from 1 to 0 (<code>0x02000000</code> → <code>0x00000000</code>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="atomic-gpio-register"><a class="header" href="#atomic-gpio-register">Atomic GPIO Register</a></h1>
<p>Earlier, we looked only at the GPIO_OUT register. That register holds the full 32-bit output value for all GPIO pins. But in practice, the rp-hal library does not write to GPIO_OUT directly. Instead, it uses the atomic helper registers: GPIO_OUT_SET, GPIO_OUT_CLR, and GPIO_OUT_XOR.</p>
<p>These atomic registers are write-only registers within the SIO block that don’t hold values themselves. When you write to them, the bits you set are used to modify the underlying GPIO_OUT register:</p>
<ul>
<li>GPIO_OUT_SET changes specified bits to 1. This register is at address 0xd0000018, as per the datasheet.</li>
<li>GPIO_OUT_CLR changes specified bits to 0.  This register is at address 0xd0000020, as per the datasheet.</li>
<li>GPIO_OUT_XOR toggles specified bits</li>
</ul>
<p>Only the bits that we write as 1 are changed. All other bits stay untouched. This makes it safer and prevents accidental changes to other pins.</p>
<p>For example, if we want to control GPIO25:</p>
<ul>
<li>
<p>To set GPIO25 high, we write a 1 to bit 25 of GPIO_OUT_SET. So the GPIO_OUT_SET value will be
0b00000010_00000000_00000000_00000000 (or in hex 0x02000000).</p>
</li>
<li>
<p>To set GPIO25 low, we write a 1 to bit 25 of GPIO_OUT_CLR. So the GPIO_OUT_CLR value will be
0b00000010_00000000_00000000_00000000 (or in hex 0x02000000).</p>
</li>
</ul>
<p>These operations modify only bit 25 in GPIO_OUT, leaving all other bits intact.</p>
<h2 id="inside-rp-hal-setting-a-pin-high-or-low"><a class="header" href="#inside-rp-hal-setting-a-pin-high-or-low">Inside rp-hal: Setting a Pin High or Low</a></h2>
<p>If we follow what set_high() and set_low() do inside rp-hal, we can see that they never write to GPIO_OUT directly. Instead, they write to the atomic registers GPIO_OUT_SET and GPIO_OUT_CLR.</p>
<p>The <a href="https://github.com/rp-rs/rp-hal/blob/28fdf0c3b3bfe67d1ceae92050ccbb469bff3a29/rp235x-hal/src/gpio/mod.rs#L672">code inside rp-hal</a> looks like this:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> #[inline]
pub(crate) fn _set_low(&amp;mut self) {
    let mask = self.id.mask();
    self.id.sio_out_clr().write(|w| unsafe { w.bits(mask) });
}

#[inline]
pub(crate) fn _set_high(&amp;mut self) {
    let mask = self.id.mask();
    self.id.sio_out_set().write(|w| unsafe { w.bits(mask) });
}
<span class="boring">}</span></code></pre>
<p>When these write() functions run, they eventually call core::ptr::write_volatile(). write_volatile does some pre-checks, and then the compiler’s intrinsic intrinsics::volatile_store performs the final store to the MMIO address. That volatile store is the moment the actual hardware register changes.</p>
<p>Now let’s check how this looks when we step through it in GDB.</p>
<h2 id="breakpoint-at-write_volatile"><a class="header" href="#breakpoint-at-write_volatile">Breakpoint at write_volatile</a></h2>
<p>There are many ways to reach write_volatile. One way is to step through set_low() or set_high() using stepi and nexti in GDB. But we will take a shorter path. We will set a breakpoint directly on core::ptr::write_volatile.</p>
<p>There is one thing to keep in mind. If you set this breakpoint right after reset (for example, right after <code>monitor reset halt</code>), GDB will stop many times. This is because write_volatile is used in a lot of places during startup. So we will not set it at the beginning.</p>
<p>Instead, follow the steps from the previous chapter. When the program stops at the first breakpoint in your code, like this:</p>
<pre><code class="language-sh">Continuing.

Thread 1 hit Breakpoint 1, 0x100002f8 in pico_debug::__cortex_m_rt_main () at src/main.rs:63
63              led_pin.set_high().unwrap();
</code></pre>
<blockquote>
<p>Note: You can check your breakpoints with <code>info break</code>. You can delete the breakpoint with <code>delete &lt;number&gt;</code>.</p>
</blockquote>
<p>Now that we’re past the startup code, let’s set our breakpoint on write_volatile:</p>
<pre><code class="language-sh">(gdb) break core::ptr::write_volatile
</code></pre>
<p>Then continue execution:</p>
<pre><code class="language-sh">(gdb) continue
</code></pre>
<p>You should see output similar to this:</p>
<pre><code class="language-sh">Thread 1 received signal SIGINT, Interrupt.
rp235x_hal::gpio::eh1::{impl#1}::set_high&lt;rp235x_hal::gpio::pin::bank0::Gpio25, rp235x_hal::gpio::pull::PullDown&gt; (self=0x2007ffbd)
    at /home/implrust/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rp235x-hal-0.3.1/src/gpio/mod.rs:1549
1549            fn set_high(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {
</code></pre>
<p>Continue again:</p>
<pre><code class="language-sh">(gdb) continue
</code></pre>
<p>Now we’ve stopped inside the write_volatile function:</p>
<pre><code class="language-sh">Thread 1 hit Breakpoint 3, core::ptr::write_volatile&lt;u32&gt; (dst=0xd0000018, src=33554432)
    at /home/implrust/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:76
76                  if ::core::ub_checks::$kind() {
</code></pre>
<p>Did you notice the function arguments here? The destination dst is 0xd0000018, which is the address of the GPIO_OUT_SET register. The source value src is 33554432. If we convert that to hexadecimal, we get 0x02000000. In binary, that’s 0b00000010_00000000_00000000_00000000. This is the exact bit mask for GPIO25.</p>
<p>Let’s disassemble the function to see what’s happening at the assembly level:</p>
<pre><code class="language-sh">(gdb) disas
Dump of assembler code for function _ZN4core3ptr14write_volatile17hc4948e781ca030f6E:
   0x10008084 &lt;+0&gt;:     push    {r7, lr}
   0x10008086 &lt;+2&gt;:     mov     r7, sp
   0x10008088 &lt;+4&gt;:     sub     sp, #24
   0x1000808a &lt;+6&gt;:     str     r2, [sp, #4]
   0x1000808c &lt;+8&gt;:     str     r1, [sp, #8]
   0x1000808e &lt;+10&gt;:    str     r0, [sp, #12]
   0x10008090 &lt;+12&gt;:    str     r0, [sp, #16]
   0x10008092 &lt;+14&gt;:    str     r1, [sp, #20]
=&gt; 0x10008094 &lt;+16&gt;:    b.n     0x10008096 &lt;_ZN4core3ptr14write_volatile17hc4948e781ca030f6E+18&gt;
   0x10008096 &lt;+18&gt;:    ldr     r2, [sp, #4]
   0x10008098 &lt;+20&gt;:    ldr     r0, [sp, #12]
   0x1000809a &lt;+22&gt;:    movs    r1, #4
   0x1000809c &lt;+24&gt;:    bl      0x100080ac &lt;_ZN4core3ptr14write_volatile18precondition_check17h8beabfccc7ba3236E&gt;
   0x100080a0 &lt;+28&gt;:    b.n     0x100080a2 &lt;_ZN4core3ptr14write_volatile17hc4948e781ca030f6E+30&gt;
   0x100080a2 &lt;+30&gt;:    ldr     r0, [sp, #8]
   0x100080a4 &lt;+32&gt;:    ldr     r1, [sp, #12]
   0x100080a6 &lt;+34&gt;:    str     r0, [r1, #0]
   0x100080a8 &lt;+36&gt;:    add     sp, #24
   0x100080aa &lt;+38&gt;:    pop     {r7, pc}
End of assembler dump.
</code></pre>
<p>The key instruction is at address 0x100080a6. This is the line that actually writes to the hardware register. At this point, r1 will contain the GPIO_OUT_SET address and r0 will contain the value that is going to be written.</p>
<p>Let’s take a closer look. We set another breakpoint right on that instruction:</p>
<pre><code class="language-sh">(gdb) break *0x100080a6
</code></pre>
<p>Then continue:</p>
<pre><code class="language-sh">(gdb) continue
</code></pre>
<p>If you get interrupted, continue again</p>
<pre><code class="language-sh">Thread 1 received signal SIGINT, Interrupt.
core::ptr::write_volatile&lt;u32&gt; (dst=0xd0000018, src=33554432)
    at /home/implrust/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:77
77                      precondition_check($($arg,)*);
</code></pre>
<p>Continue again:</p>
<pre><code class="language-sh">(gdb) c
Continuing.

Thread 1 hit Breakpoint 4, 0x100080a6 in core::ptr::write_volatile&lt;u32&gt; (dst=0xd0000018, src=33554432)
    at /home/implrust/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:2201
2201            intrinsics::volatile_store(dst, src);
</code></pre>
<p>GDB will stop exactly at the store instruction. If you run disas again, you’ll see the arrow pointing to that line:</p>
<pre><code class="language-sh">...
   0x100080a4 &lt;+32&gt;:    ldr     r1, [sp, #12]
=&gt; 0x100080a6 &lt;+34&gt;:    str     r0, [r1, #0]
   0x100080a8 &lt;+36&gt;:    add     sp, #24
</code></pre>
<p>Before we execute this write instruction, let’s check what values are in registers r0 and r1:</p>
<pre><code class="language-sh">(gdb) i r $r0
r0             0x2000000           33554432

(gdb) i r $r1
r1             0xd0000018          3489660952
</code></pre>
<p>Let’s also examine the current value in the GPIO_OUT register:</p>
<pre><code class="language-sh">(gdb) x/x 0xd0000010
0xd0000010:     0x00000000
</code></pre>
<p>Right now it shows all zeros. At this stage, the LED is still off because we haven’t executed the store instruction yet.</p>
<p>Now let’s step forward by one instruction:</p>
<pre><code class="language-sh">(gdb) nexti

#or

(gdb) ni
</code></pre>
<p>After executing this command, you should see the LED turn on. Now let’s examine the GPIO_OUT register again:</p>
<pre><code class="language-sh">(gdb) x/x 0xd0000010
0xd0000010:     0x02000000
</code></pre>
<p>The register now shows 0x02000000, which is exactly the bit mask for GPIO25. This confirms that our write operation successfully set the LED pin high.</p>
<h2 id="your-turn-try-it-yourself"><a class="header" href="#your-turn-try-it-yourself">Your Turn: Try It Yourself</a></h2>
<p>Now it’s time to practice what you’ve learned. Let the program continue running until it hits the set_low breakpoint. Then continue execution again until you reach the write_volatile function.</p>
<p>This time, things will be a bit different. The destination address will be 0xd0000020, which is the GPIO_OUT_CLR register. As the name suggests, this register is used to clear GPIO pins rather than set them.</p>
<p>Step through the code just like before. When you execute the str instruction, the LED will turn off. If you examine the GPIO_OUT register afterwards, you’ll see it contains all zeros again. This confirms that the bit for GPIO25 has been cleared, turning off the LED.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="为树莓派-pico-2-编写的-rust-精选项目列表"><a class="header" href="#为树莓派-pico-2-编写的-rust-精选项目列表">为树莓派 Pico 2 编写的 Rust 精选项目列表</a></h1>
<p>这是一个精选的项目列表，我在线找到的这些项目很有趣且与 Pico 2 和 Rust 相关。如果你有一些有趣的项目要展示，请发送 PR :)</p>
<ul>
<li><a href="https://github.com/ImplFerris/pico-rex">Pico Rex</a>: 用 Rust 为树莓派 Pico 2 (RP2350) 编写的恐龙游戏，带有 OLED 显示屏，使用 Embassy 框架。</li>
<li><a href="https://github.com/Altaflux/gb-rp2350">GB-RP2350 树莓派 Pico 2 的游戏男孩模拟器，用 Rust 编写</a>: 你也可以找到 OP 的 reddit 帖子<a href="https://www.reddit.com/r/raspberrypipico/comments/1h6hb3l/gbrp2350_a_game_boy_emulator_for_the_pi_pico_2/">在这里</a>。</li>
<li><a href="https://github.com/1-rafael-1/simple-robot">simple-robot</a>: 一个非常简单的机器人，配备 HC-SR04 距离传感器和自主以及远程控制运动，用 Rust(Embassy) 编写</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="有用的资源"><a class="header" href="#有用的资源">有用的资源</a></h1>
<p>本部分将包括我发现有帮助的资源列表。</p>
<h2 id="博客文章"><a class="header" href="#博客文章">博客文章</a></h2>
<ul>
<li><a href="https://thejpster.org.uk/blog/blog-2024-08-08/">RP2350 发布博客，由 theJPster 发布</a></li>
</ul>
<h2 id="教程"><a class="header" href="#教程">教程</a></h2>
<ul>
<li><a href="https://projects.raspberrypi.org/en/projects/introduction-to-the-pico/0">官方树莓派 Pico 指南</a></li>
</ul>
<h2 id="其他资源"><a class="header" href="#其他资源">其他资源</a></h2>
<ul>
<li><a href="https://github.com/rust-embedded/awesome-embedded-rust">嵌入式 Rust 的精选资源列表</a></li>
<li><a href="https://os.phil-opp.com/">用 Rust 编写 OS</a>: 这里解释了许多有用的概念</li>
<li><a href="https://embassy.dev/book/">Embassy 书</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
